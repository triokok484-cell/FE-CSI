<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CEA201 - Master Tool (Updated UI)</title>
    <style>
        :root {
            --primary-color: #6f42c1;
            --primary-light: #f3f0ff;
            --secondary-color: #28a745;
            --danger-color: #dc3545;
            --warning-color: #fd7e14;
            --selected-border: #6f42c1;
            --selected-bg: #e0d4fc;
            --light-bg: #f8f9fa;
            --dark-text: #333;
            --card-shadow: 0 10px 25px rgba(111, 66, 193, 0.1);
        }
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        
        * { box-sizing: border-box; }
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--light-bg);
            color: var(--dark-text);
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        /* --- UI Components --- */
        .top-bar {
            background: white; padding: 15px 30px; box-shadow: 0 2px 15px rgba(0,0,0,0.05);
            display: flex; justify-content: space-between; align-items: center; z-index: 100; flex-shrink: 0;
        }
        .tabs { display: flex; background: #f0f2f5; padding: 5px; border-radius: 30px; gap: 5px; }
        .tab-btn {
            padding: 8px 24px; border: none; background: transparent; cursor: pointer; border-radius: 25px;
            font-weight: 600; color: #666; transition: all 0.3s ease; font-size: 14px;
        }
        .tab-btn.active { background-color: var(--primary-color); color: white; box-shadow: 0 4px 12px rgba(111, 66, 193, 0.3); }
        .lang-btn {
            background: white; border: 2px solid #e0d4fc; color: var(--primary-color); padding: 6px 16px;
            border-radius: 20px; cursor: pointer; font-size: 14px; font-weight: 700; transition: all 0.2s;
        }

        /* --- Main Layout --- */
        .main-container { display: flex; flex: 1; overflow: hidden; position: relative; height: 100%; }
        .content-area {
            flex: 1; padding: 30px; overflow-y: auto; width: 100%;
            display: flex; flex-direction: column; align-items: center; position: relative; 
        }
        .view-section { display: none !important; width: 100%; max-width: 900px; animation: fadeIn 0.3s cubic-bezier(0.16, 1, 0.3, 1); }
        .view-section.active-view { display: block !important; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .hidden { display: none !important; }
        .flex-between { display: flex; justify-content: space-between; align-items: center; }

        /* --- Buttons --- */
        .start-btn, .nav-btn, .submit-btn {
            background: var(--primary-color); color: white; border: none; padding: 14px 30px; border-radius: 30px;
            font-size: 16px; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; font-weight: 600;
            box-shadow: 0 4px 15px rgba(111, 66, 193, 0.2);
        }
        .start-btn:hover, .nav-btn:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(111, 66, 193, 0.3); }
        .submit-btn { background: var(--secondary-color); box-shadow: 0 4px 15px rgba(40, 167, 69, 0.3); }
        .nav-btn.secondary { background: #e9ecef; color: #495057; box-shadow: none; }
        .nav-btn.secondary:hover { background: #dee2e6; }
        .nav-btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }

        /* --- Question Card Styling --- */
        .question-card { background: white; border-radius: 20px; padding: 30px; box-shadow: var(--card-shadow); margin-bottom: 20px; position: relative; }
        .question-text { font-size: 18px; line-height: 1.6; margin-bottom: 25px; font-weight: 500; }
        
        .options-list { list-style: none; padding: 0; display: grid; gap: 12px; }
        .options-list li {
            background: #fff; border: 2px solid #f0f0f0; border-radius: 12px; padding: 15px 20px 15px 50px;
            cursor: pointer; position: relative; transition: all 0.15s; font-size: 15px; user-select: none;
        }
        .options-list li:hover:not(.disabled) { border-color: var(--primary-color); background: #fcfaff; }
        
        /* Label A, B, C */
        .options-list li::before {
            content: attr(data-label); position: absolute; left: 15px; top: 50%; transform: translateY(-50%);
            width: 28px; height: 28px; background: #e9ecef; color: #495057; border-radius: 8px;
            text-align: center; line-height: 28px; font-weight: 700; font-size: 13px; transition: all 0.2s;
        }

        /* --- STATES: SELECTED --- */
        .options-list li.selected {
            border-color: var(--primary-color);
            background-color: var(--primary-light);
            box-shadow: 0 0 0 1px var(--primary-color) inset;
            font-weight: 600;
        }
        .options-list li.selected::before {
            background-color: var(--primary-color);
            color: white;
        }

        /* --- STATES: CHECKED --- */
        .options-list.checked li { cursor: default; opacity: 0.6; }
        
        /* ƒê√∫ng */
        .options-list.checked li.is-correct-answer {
            background-color: #d1e7dd !important;
            border-color: #0f5132 !important;
            color: #0f5132 !important;
            opacity: 1 !important;
            box-shadow: 0 0 0 1px #0f5132 inset;
        }
        .options-list.checked li.is-correct-answer::before {
            background-color: #198754; color: white; content: "‚úî";
        }

        /* Sai (User ch·ªçn sai) */
        .options-list.checked li.is-wrong-answer {
            background-color: #f8d7da !important;
            border-color: #842029 !important;
            color: #842029 !important;
            opacity: 1 !important;
            box-shadow: 0 0 0 1px #842029 inset;
        }
        .options-list.checked li.is-wrong-answer::before {
            background-color: #dc3545; color: white; content: "‚úò";
        }

        /* Gi·∫£i th√≠ch */
        .instant-explanation {
            margin-top: 20px; padding: 15px; border-radius: 12px;
            background-color: #e2e3e5; color: #41464b; font-size: 15px;
            display: none; animation: fadeIn 0.3s ease; line-height: 1.5;
        }
        .instant-explanation.show { display: block; }
        .instant-explanation.correct { background-color: #d1e7dd; color: #0f5132; border: 1px solid #badbcc; }
        .instant-explanation.wrong { background-color: #f8d7da; color: #842029; border: 1px solid #f5c2c7; }

        /* N√∫t Check ƒê·∫∑c Bi·ªát */
        .btn-check-wrapper { text-align: center; margin-top: 20px; }
        .btn-check-multi {
            background-color: var(--warning-color); color: white; border: none;
            padding: 12px 30px; border-radius: 30px; font-weight: 700; font-size: 15px; cursor: pointer;
            transition: all 0.2s; box-shadow: 0 4px 10px rgba(253, 126, 20, 0.3);
            display: inline-flex; align-items: center; gap: 8px;
        }
        .btn-check-multi:hover:not(:disabled) { background-color: #e36d0a; transform: translateY(-2px); }
        .btn-check-multi:disabled {
            background-color: #ced4da; color: #6c757d; cursor: not-allowed; box-shadow: none; transform: none;
        }

        /* --- FLASHCARD STYLING (UPDATED) --- */
        .flashcard-wrapper { display: flex; justify-content: center; perspective: 1000px; margin-bottom: 30px; }
        .flashcard {
            width: 100%; max-width: 700px; position: relative; transform-style: preserve-3d;
            transition: transform 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275); cursor: pointer; display: grid;
        }
        .flashcard.flipped { transform: rotateY(180deg); }
        
        .card-face {
            grid-area: 1 / 1; width: 100%; min-height: 450px; /* TƒÉng chi·ªÅu cao x√≠u cho ƒë·∫πp */
            backface-visibility: hidden; -webkit-backface-visibility: hidden;
            border-radius: 24px;
            box-shadow: var(--card-shadow); 
            padding: 40px; display: flex; flex-direction: column;
            justify-content: flex-start; align-items: center; text-align: center; 
            border: 1px solid rgba(0,0,0,0.05);
        }
        
        .card-front { 
            background: white; 
            z-index: 2; 
            transform: rotateY(0deg); 
        }

        /* --- UPDATED CARD BACK (EYE CATCHING) --- */
        .card-back { 
            transform: rotateY(180deg); 
            /* Gradient n·ªÅn b·∫Øt m·∫Øt (T√≠m nh·∫°t -> Xanh nh·∫°t) */
            background: linear-gradient(135deg, #e0c3fc 0%, #8ec5fc 100%);
            border: none;
            justify-content: center; /* CƒÉn gi·ªØa n·ªôi dung */
        }

        /* Style cho ph·∫ßn ƒê√°p √°n ch√≠nh b√™n trong Card Back */
        #fc-answer {
            font-size: 22px; 
            font-weight: 800; 
            margin-bottom: 25px; 
            color: #2c3e50;
            width: 100%;
            /* Hi·ªáu ·ª©ng k√≠nh m·ªù */
            background: rgba(255, 255, 255, 0.85);
            padding: 20px;
            border-radius: 16px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.1);
            border: 2px solid rgba(255,255,255,0.8);
            text-align: center;
        }

        /* Style cho ph·∫ßn Gi·∫£i th√≠ch b√™n trong Card Back */
        .explanation-box {
            width: 100%; 
            font-size: 15px; 
            color: #444; 
            background: #ffffff; 
            padding: 20px; 
            border-radius: 16px;
            text-align: left;
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
            line-height: 1.6;
        }
        
        /* Badge (N√∫t tag tr√™n flashcard) */
        .category-badge {
            font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; background: #f1f3f5;
            color: #868e96; padding: 6px 12px; border-radius: 20px; font-weight: 700; margin-bottom: 20px; display: inline-block;
        }
        /* Tag tr√™n m·∫∑t sau c≈©ng n√™n n·ªïi b·∫≠t h∆°n */
        .card-back .category-badge {
            background: #28a745; color: white; box-shadow: 0 3px 10px rgba(40, 167, 69, 0.3);
        }

        /* --- Utils --- */
        .quiz-sidebar {
            width: 300px; background: white; border-left: 1px solid #f0f0f0; display: flex;
            flex-direction: column; padding: 25px; overflow-y: auto; flex-shrink: 0; z-index: 90;
        }
        .question-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; }
        .map-btn {
            width: 100%; aspect-ratio: 1; border: none; border-radius: 10px; background: #f1f3f5;
            color: #868e96; cursor: pointer; font-weight: 700; transition: all 0.2s;
        }
        .map-btn:hover { background: #e9ecef; transform: scale(1.05); }
        .map-btn.active { background: white; border: 2px solid var(--primary-color); color: var(--primary-color); }
        .map-btn.answered { background: var(--primary-light); color: var(--primary-color); }
        .map-btn.correct { background: var(--secondary-color); color: white; }
        .map-btn.wrong { background: var(--danger-color); color: white; }
        .result-header { text-align: center; background: white; padding: 40px; border-radius: 24px; margin-bottom: 30px; box-shadow: var(--card-shadow); }
        
        .multi-select-hint {
            font-size: 13px; color: #856404; background: #fff3cd; border: 1px solid #ffeeba;
            padding: 5px 10px; border-radius: 20px; margin-left: 10px; display: inline-block; font-weight: 600;
        }
        
        #quiz-setup { background: white; padding: 50px; border-radius: 24px; box-shadow: var(--card-shadow); text-align: center; max-width: 600px; margin: auto; }
        .custom-select { width: 100%; padding: 12px 20px; border: 2px solid #e0e0e0; border-radius: 12px; font-size: 16px; background: #fff; margin-top: 10px; cursor: pointer; }

        @media (max-width: 768px) {
            .main-container { flex-direction: column; }
            .quiz-sidebar { width: 100%; height: auto; max-height: 120px; border-left: none; border-top: 1px solid #eee; order: -1; padding: 15px; }
            .question-grid { grid-template-columns: repeat(10, 1fr); }
            .content-area { padding: 15px; }
        }
    </style>
</head>
<body>

    <div class="top-bar">
        <div class="tabs">
            <button class="tab-btn active" onclick="switchTab('flashcard')">üìö Flashcards</button>
            <button class="tab-btn" onclick="switchTab('quiz')">üìù Quiz</button>
        </div>
        <button class="lang-btn" onclick="toggleLanguage()">
            <span style="font-size: 16px;">üåê</span> <span id="current-lang-text">VN</span>
        </button>
    </div>

    <div class="main-container">
        <div class="content-area">

            <div id="flashcard-view" class="view-section active-view">
                <div class="filter-container" style="max-width: 700px; margin: 0 auto 20px auto;">
                    <label style="font-weight:bold; color:var(--primary-color); display:block; margin-bottom:8px;">üìñ Ch·ªçn n·ªôi dung h·ªçc:</label>
                    <select id="fc-category-select" onchange="updateFlashcardFilter()" class="custom-select"></select>
                </div>
                <div class="flashcard-wrapper">
                    <div class="flashcard" onclick="this.classList.toggle('flipped')">
                        <div class="card-face card-front">
                            <div class="category-badge" id="fc-tag"></div>
                            <div style="flex:1; display:flex; align-items:center; justify-content:center; width:100%;">
                                <div id="fc-content" style="font-size: 20px; font-weight: 500; line-height: 1.5;"></div>
                            </div>
                            <div style="margin-top: auto; font-size: 12px; color: #aaa;">(Ch·∫°m ƒë·ªÉ l·∫≠t / Click to flip)</div>
                        </div>
                        <div class="card-face card-back">
                            <div id="fc-answer-label" class="category-badge"></div>
                            <div id="fc-answer"></div>
                            <div class="explanation-box">
                                <strong id="fc-explanation-label" style="color:var(--primary-color);"></strong><br>
                                <span id="fc-explanation"></span>
                            </div>
                        </div>
                    </div>
                </div>
                <div style="display:flex; justify-content:center; gap:20px; align-items: center;">
                    <button class="nav-btn secondary" onclick="navFlashcard(-1)">‚Üê Tr∆∞·ªõc</button>
                    <span id="fc-counter" style="font-weight:700; color:#868e96; font-size: 16px; min-width: 80px; text-align: center;"></span>
                    <button class="nav-btn secondary" onclick="navFlashcard(1)">Sau ‚Üí</button>
                </div>
                <div id="shortcut-help" style="text-align: center; margin-top: 15px; color: #adb5bd; font-size: 12px;"></div>
            </div>

            <div id="quiz-setup" class="view-section">
                <h2 id="txt-setup-title" style="color: var(--primary-color); margin-bottom: 30px;"></h2>
                <div style="text-align: left; margin-bottom: 25px;">
                    <label style="font-weight:600; margin-bottom: 5px; display:block;">1. Ch·ªçn ch·ªß ƒë·ªÅ √¥n t·∫≠p:</label>
                    <select id="quiz-category-select" onchange="updateQuizCountMax()" class="custom-select"></select>
                </div>
                <div style="text-align: left; margin-bottom: 35px;">
                    <label id="txt-q-count" style="font-weight:600; margin-bottom: 5px; display:block;"></label>
                    <div style="display: flex; align-items: center; gap: 15px;">
                        <input type="number" id="quiz-count-input" min="1" value="10" style="padding: 12px; border: 2px solid #e0e0e0; border-radius: 12px; font-size: 18px; font-weight:bold; width: 100px; text-align: center; color: var(--primary-color);">
                        <div style="font-size: 14px; color: #868e96;">
                            <span id="txt-total"></span> <strong id="total-qs" style="color:var(--dark-text)">0</strong> c√¢u
                        </div>
                    </div>
                </div>
                <button class="start-btn" onclick="startQuiz()" id="txt-start" style="width: 100%;"></button>
            </div>

            <div id="quiz-active" class="view-section">
                <div class="question-card">
                    <div class="flex-between" style="margin-bottom:20px; color:#868e96; font-size: 14px; font-weight: 600;">
                        <span id="quiz-progress"></span>
                        <div>
                            <div class="category-badge" id="q-category-badge" style="margin-bottom:0; font-size:10px;"></div>
                            <span id="multi-select-badge" class="multi-select-hint hidden"></span>
                        </div>
                    </div>
                    <div id="q-content" class="question-text"></div>
                    
                    <ul class="options-list" id="q-options"></ul>
                    
                    <div id="check-btn-container" class="btn-check-wrapper hidden">
                        <button id="btn-manual-check" class="btn-check-multi" disabled>Ki·ªÉm tra ƒë√°p √°n ‚ú®</button>
                    </div>
                    <div id="instant-explain-area" class="instant-explanation"></div>
                </div>

                <div class="flex-between" style="max-width: 100%;">
                    <button class="nav-btn secondary" onclick="navQuiz(-1)" id="btn-prev"></button>
                    <button class="submit-btn" onclick="finishQuiz()" id="btn-submit"></button>
                    <button class="nav-btn" onclick="navQuiz(1)" id="btn-next"></button>
                </div>
            </div>

            <div id="quiz-result" class="view-section">
                <div class="result-header">
                    <h2 id="txt-result-title"></h2>
                    <div id="score-val" style="font-size:48px; font-weight:700; color:var(--primary-color);"></div>
                    <p id="score-percent" style="color: #868e96; font-weight: 600; font-size: 20px; margin-top: 0;"></p>
                    <button class="start-btn" onclick="resetQuiz()" style="margin-top: 20px;">L√†m ƒë·ªÅ m·ªõi üîÑ</button>
                </div>
                <div id="review-list"></div>
            </div>

        </div>

        <div class="quiz-sidebar hidden" id="quiz-sidebar">
            <div id="txt-map-title" style="font-weight:700; margin-bottom:20px; font-size: 16px;"></div>
            <div class="question-grid" id="map-grid"></div>
            <div style="margin-top:auto; padding-top: 20px; font-size:13px; color:#868e96; border-top: 1px solid #f0f0f0;">
                <div class="flex-between" style="justify-content: flex-start; margin-bottom:8px;"><div style="width:12px; height:12px; border:2px solid var(--primary-color); border-radius: 3px; margin-right:10px;"></div><span id="leg-current"></span></div>
                <div class="flex-between" style="justify-content: flex-start; margin-bottom:8px;"><div style="width:12px; height:12px; background:var(--secondary-color); border-radius: 3px; margin-right:10px;"></div><span id="leg-correct"></span></div>
                <div class="flex-between" style="justify-content: flex-start;"><div style="width:12px; height:12px; background:var(--danger-color); border-radius: 3px; margin-right:10px;"></div><span id="leg-wrong"></span></div>
            </div>
        </div>
    </div>

<script>
    // ======================================================
    // 1. D·ªÆ LI·ªÜU (GI·ªÆ NGUY√äN D·ªÆ LI·ªÜU C≈® C·ª¶A B·∫†N)
    // ======================================================
    
    // --- D√ÅN JSON V√ÄO D∆Ø·ªöI ƒê√ÇY (Ch·ªâ copy paste l·∫°i c√°i c≈© c·ªßa b·∫°n) ---
    const quizData = [
        // ... D√°n l·∫°i to√†n b·ªô d·ªØ li·ªáu JSON c·ªßa b·∫°n ·ªü ƒë√¢y ...
        // (T√¥i gi·ªØ l·∫°i 2 c√¢u v√≠ d·ª• ƒë·ªÉ code ch·∫°y ƒë∆∞·ª£c, b·∫°n h√£y paste ƒë√® d·ªØ li·ªáu full c·ªßa b·∫°n v√†o nh√©)
        {
        "id": 1,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "The _______ model is the basis for today's computers.",
            "options": [
                "A. Leibnitz",
                "B. von Neumann",
                "C. Pascal",
                "D. Charles Babbage"
            ],
            "answer": "B. von Neumann",
            "explanation": "The von Neumann architecture, which includes the stored-program concept (storing both data and instructions in the same memory), is the foundational model for almost all modern computers. **Key takeaway: von Neumann = Stored-Program Computers.**"
        },
        "vi": {
            "question": "M√¥ h√¨nh _______ l√† n·ªÅn t·∫£ng cho c√°c m√°y t√≠nh ng√†y nay.",
            "options": [
                "A. Leibnitz",
                "B. von Neumann",
                "C. Pascal",
                "D. Charles Babbage"
            ],
            "answer": "B. von Neumann",
            "explanation": "Ki·∫øn tr√∫c von Neumann, bao g·ªìm kh√°i ni·ªám ch∆∞∆°ng tr√¨nh ƒë∆∞·ª£c l∆∞u tr·ªØ (l∆∞u c·∫£ d·ªØ li·ªáu v√† l·ªánh trong c√πng m·ªôt b·ªô nh·ªõ), l√† m√¥ h√¨nh n·ªÅn t·∫£ng cho h·∫ßu h·∫øt c√°c m√°y t√≠nh hi·ªán ƒë·∫°i. **M·∫πo ghi nh·ªõ: von Neumann = M√°y t√≠nh c√≥ ch∆∞∆°ng tr√¨nh ƒë∆∞·ª£c l∆∞u tr·ªØ.**"
        }
    },
    {
        "id": 2,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "The first electronic special-purpose computer was called ___.",
            "options": [
                "A. Pascal",
                "B. Pascaline",
                "C. ABC (Atanasoff-Berry Computer)",
                "D. ENIAC"
            ],
            "answer": "C. ABC (Atanasoff-Berry Computer)",
            "explanation": "The Atanasoff-Berry Computer (ABC) is considered the first automatic electronic digital computer. It was designed for a special purpose: solving systems of linear equations. ENIAC was the first general-purpose one. **Key takeaway: ABC = First special-purpose electronic computer.**"
        },
        "vi": {
            "question": "M√°y t√≠nh ƒëi·ªán t·ª≠ chuy√™n d·ª•ng ƒë·∫ßu ti√™n ƒë∆∞·ª£c g·ªçi l√† ___.",
            "options": [
                "A. Pascal",
                "B. Pascaline",
                "C. ABC (M√°y t√≠nh Atanasoff-Berry)",
                "D. ENIAC"
            ],
            "answer": "C. ABC (M√°y t√≠nh Atanasoff-Berry)",
            "explanation": "M√°y t√≠nh Atanasoff-Berry (ABC) ƒë∆∞·ª£c coi l√† m√°y t√≠nh k·ªπ thu·∫≠t s·ªë ƒëi·ªán t·ª≠ t·ª± ƒë·ªông ƒë·∫ßu ti√™n. N√≥ ƒë∆∞·ª£c thi·∫øt k·∫ø cho m·ªôt m·ª•c ƒë√≠ch ƒë·∫∑c bi·ªát: gi·∫£i h·ªá ph∆∞∆°ng tr√¨nh tuy·∫øn t√≠nh. ENIAC l√† m√°y t√≠nh ƒëa nƒÉng ƒë·∫ßu ti√™n. **M·∫πo ghi nh·ªõ: ABC = M√°y t√≠nh ƒëi·ªán t·ª≠ chuy√™n d·ª•ng ƒë·∫ßu ti√™n.**"
        }
    },
    {
        "id": 3,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "One of the first computers based on the von Neumann model was called ___.",
            "options": [
                "A. Pascal",
                "B. Pascaline",
                "C. ABC",
                "D. EDVAC"
            ],
            "answer": "D. EDVAC",
            "explanation": "EDVAC (Electronic Discrete Variable Automatic Computer) was one of the earliest electronic computers to incorporate the stored-program concept proposed by von Neumann. **Key takeaway: EDVAC = Early von Neumann machine.**"
        },
        "vi": {
            "question": "M·ªôt trong nh·ªØng m√°y t√≠nh ƒë·∫ßu ti√™n d·ª±a tr√™n m√¥ h√¨nh von Neumann ƒë∆∞·ª£c g·ªçi l√† ___.",
            "options": [
                "A. Pascal",
                "B. Pascaline",
                "C. ABC",
                "D. EDVAC"
            ],
            "answer": "D. EDVAC",
            "explanation": "EDVAC (Electronic Discrete Variable Automatic Computer) l√† m·ªôt trong nh·ªØng m√°y t√≠nh ƒëi·ªán t·ª≠ s·ªõm nh·∫•t t√≠ch h·ª£p kh√°i ni·ªám ch∆∞∆°ng tr√¨nh ƒë∆∞·ª£c l∆∞u tr·ªØ do von Neumann ƒë·ªÅ xu·∫•t. **M·∫πo ghi nh·ªõ: EDVAC = M√°y t√≠nh von Neumann ƒë·ªùi ƒë·∫ßu.**"
        }
    },
    {
        "id": 4,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "The first computing machine to use the idea of storage and programming was called ___.",
            "options": [
                "A. the Madeline",
                "B. EDVAC",
                "C. the Babbage machine (Analytical Engine)",
                "D. the Jacquard loom"
            ],
            "answer": "C. the Babbage machine (Analytical Engine)",
            "explanation": "Charles Babbage's Analytical Engine, designed in the 19th century, was the first design for a general-purpose mechanical computer that included concepts of integrated memory (storage) and program control (using punched cards). **Key takeaway: Babbage's Analytical Engine = First programmable concept.**"
        },
        "vi": {
            "question": "C·ªó m√°y t√≠nh to√°n ƒë·∫ßu ti√™n s·ª≠ d·ª•ng √Ω t∆∞·ªüng v·ªÅ l∆∞u tr·ªØ v√† l·∫≠p tr√¨nh ƒë∆∞·ª£c g·ªçi l√† ___.",
            "options": [
                "A. the Madeline",
                "B. EDVAC",
                "C. c·ªó m√°y c·ªßa Babbage (M√°y ph√¢n t√≠ch)",
                "D. m√°y d·ªát Jacquard"
            ],
            "answer": "C. c·ªó m√°y c·ªßa Babbage (M√°y ph√¢n t√≠ch)",
            "explanation": "M√°y ph√¢n t√≠ch c·ªßa Charles Babbage, ƒë∆∞·ª£c thi·∫øt k·∫ø v√†o th·∫ø k·ª∑ 19, l√† thi·∫øt k·∫ø ƒë·∫ßu ti√™n cho m·ªôt m√°y t√≠nh c∆° h·ªçc ƒëa nƒÉng bao g·ªìm c√°c kh√°i ni·ªám v·ªÅ b·ªô nh·ªõ t√≠ch h·ª£p (l∆∞u tr·ªØ) v√† ƒëi·ªÅu khi·ªÉn ch∆∞∆°ng tr√¨nh (s·ª≠ d·ª•ng th·∫ª ƒë·ª•c l·ªó). **M·∫πo ghi nh·ªõ: M√°y ph√¢n t√≠ch c·ªßa Babbage = Kh√°i ni·ªám l·∫≠p tr√¨nh ƒë·∫ßu ti√™n.**"
        }
    },
    {
        "id": 5,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "A 17th-century computing machine that could perform addition and subtraction was the _______.",
            "options": [
                "A. Pascaline",
                "B. Jacquard loom",
                "C. Analytical Engine",
                "D. Babbage machine"
            ],
            "answer": "A. Pascaline",
            "explanation": "Invented by Blaise Pascal in the 1640s, the Pascaline was a mechanical calculator specifically designed to perform addition and subtraction. **Key takeaway: Pascaline = 17th-century addition/subtraction machine.**"
        },
        "vi": {
            "question": "M·ªôt c·ªó m√°y t√≠nh to√°n th·∫ø k·ª∑ 17 c√≥ th·ªÉ th·ª±c hi·ªán ph√©p c·ªông v√† tr·ª´ l√† _______.",
            "options": [
                "A. Pascaline",
                "B. m√°y d·ªát Jacquard",
                "C. M√°y ph√¢n t√≠ch",
                "D. m√°y Babbage"
            ],
            "answer": "A. Pascaline",
            "explanation": "ƒê∆∞·ª£c ph√°t minh b·ªüi Blaise Pascal v√†o nh·ªØng nƒÉm 1640, Pascaline l√† m·ªôt m√°y t√≠nh c∆° h·ªçc ƒë∆∞·ª£c thi·∫øt k·∫ø ƒë·∫∑c bi·ªát ƒë·ªÉ th·ª±c hi·ªán ph√©p c·ªông v√† tr·ª´. **M·∫πo ghi nh·ªõ: Pascaline = M√°y c·ªông/tr·ª´ th·∫ø k·ª∑ 17.**"
        }
    },
    {
        "id": 6,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "Symbolic languages were developed in _______.",
            "options": [
                "A. 1962",
                "B. 1974",
                "C. 1980",
                "D. 1950"
            ],
            "answer": "D. 1950",
            "explanation": "The 1950s marked the development of early symbolic languages (assembly languages) and the first high-level languages like FORTRAN. This was part of the second generation of computing. **Key takeaway: 1950s = Era of symbolic and early high-level languages.**"
        },
        "vi": {
            "question": "Ng√¥n ng·ªØ k√Ω hi·ªáu ƒë∆∞·ª£c ph√°t tri·ªÉn v√†o nh·ªØng nƒÉm _______.",
            "options": [
                "A. 1962",
                "B. 1974",
                "C. 1980",
                "D. 1950"
            ],
            "answer": "D. 1950",
            "explanation": "Nh·ªØng nƒÉm 1950 ƒë√°nh d·∫•u s·ª± ph√°t tri·ªÉn c·ªßa c√°c ng√¥n ng·ªØ k√Ω hi·ªáu s∆° khai (h·ª£p ng·ªØ) v√† c√°c ng√¥n ng·ªØ b·∫≠c cao ƒë·∫ßu ti√™n nh∆∞ FORTRAN. ƒê√¢y l√† m·ªôt ph·∫ßn c·ªßa th·∫ø h·ªá m√°y t√≠nh th·ª© hai. **M·∫πo ghi nh·ªõ: Th·∫≠p ni√™n 1950 = K·ª∑ nguy√™n c·ªßa ng√¥n ng·ªØ k√Ω hi·ªáu v√† ng√¥n ng·ªØ b·∫≠c cao s∆° khai.**"
        }
    },
    {
        "id": 7,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "When was Apple Macintosh II microcomputer introduced in the market?",
            "options": [
                "A. 1964",
                "B. 1970",
                "C. 1986",
                "D. 1987"
            ],
            "answer": "D. 1987",
            "explanation": "The Macintosh II was a high-end model in the Macintosh line, introduced by Apple in 1987. It was notable for its color graphics capabilities. **Key takeaway: Macintosh II = 1987.**"
        },
        "vi": {
            "question": "M√°y vi t√≠nh Apple Macintosh II ƒë∆∞·ª£c gi·ªõi thi·ªáu ra th·ªã tr∆∞·ªùng khi n√†o?",
            "options": [
                "A. 1964",
                "B. 1970",
                "C. 1986",
                "D. 1987"
            ],
            "answer": "D. 1987",
            "explanation": "Macintosh II l√† m·ªôt m·∫´u m√°y cao c·∫•p trong d√≤ng Macintosh, ƒë∆∞·ª£c Apple gi·ªõi thi·ªáu v√†o nƒÉm 1987. N√≥ n·ªïi b·∫≠t v·ªõi kh·∫£ nƒÉng ƒë·ªì h·ªça m√†u. **M·∫πo ghi nh·ªõ: Macintosh II = 1987.**"
        }
    },
    {
        "id": 8,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "What is the name given to the molecular-scale computer?",
            "options": [
                "A. Supercomputer",
                "B. Femtocomputer",
                "C. Nanocomputer",
                "D. Microcomputer"
            ],
            "answer": "C. Nanocomputer",
            "explanation": "Nanotechnology deals with structures at the nanometer scale (molecular scale). A computer built at this scale is called a nanocomputer. **Key takeaway: Molecular-scale = Nano.**"
        },
        "vi": {
            "question": "T√™n g·ªçi ƒë∆∞·ª£c ƒë·∫∑t cho m√°y t√≠nh ·ªü quy m√¥ ph√¢n t·ª≠ l√† g√¨?",
            "options": [
                "A. Si√™u m√°y t√≠nh",
                "B. Femtocomputer",
                "C. Nanocomputer",
                "D. M√°y vi t√≠nh"
            ],
            "answer": "C. Nanocomputer",
            "explanation": "C√¥ng ngh·ªá nano x·ª≠ l√Ω c√°c c·∫•u tr√∫c ·ªü quy m√¥ nanomet (quy m√¥ ph√¢n t·ª≠). M·ªôt m√°y t√≠nh ƒë∆∞·ª£c ch·∫ø t·∫°o ·ªü quy m√¥ n√†y ƒë∆∞·ª£c g·ªçi l√† nanocomputer. **M·∫πo ghi nh·ªõ: Quy m√¥ ph√¢n t·ª≠ = Nano.**"
        }
    },
    {
        "id": 9,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "Human beings are referred to as Homosapiens. Which device is called Silico sapiens?",
            "options": [
                "A. Monitor",
                "B. Hardware",
                "C. Robot",
                "D. Computer"
            ],
            "answer": "D. Computer",
            "explanation": "'Silico sapiens' means 'wise being of silicon'. Since computers are built using silicon chips and perform intelligent tasks, this term is sometimes used to refer to them metaphorically. **Key takeaway: Silico (Silicon) = Computer.**"
        },
        "vi": {
            "question": "Con ng∆∞·ªùi ƒë∆∞·ª£c g·ªçi l√† Homosapiens. Thi·∫øt b·ªã n√†o ƒë∆∞·ª£c g·ªçi l√† Silico sapiens?",
            "options": [
                "A. M√†n h√¨nh",
                "B. Ph·∫ßn c·ª©ng",
                "C. Robot",
                "D. M√°y t√≠nh"
            ],
            "answer": "D. M√°y t√≠nh",
            "explanation": "'Silico sapiens' c√≥ nghƒ©a l√† 'sinh v·∫≠t th√¥ng th√°i t·ª´ silicon'. V√¨ m√°y t√≠nh ƒë∆∞·ª£c ch·∫ø t·∫°o b·∫±ng chip silicon v√† th·ª±c hi·ªán c√°c nhi·ªám v·ª• th√¥ng minh, thu·∫≠t ng·ªØ n√†y ƒë√¥i khi ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ ch·ªâ ch√∫ng m·ªôt c√°ch ·∫©n d·ª•. **M·∫πo ghi nh·ªõ: Silico (Silicon) = M√°y t√≠nh.**"
        }
    },
    {
        "id": 10,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "What generation appeared high-level programming language?",
            "options": [
                "A. First generation",
                "B. Second generation",
                "C. Third generation",
                "D. Fourth generation"
            ],
            "answer": "C. Third generation",
            "explanation": "While early high-level languages like FORTRAN appeared in the late second generation, they became widespread and more sophisticated during the third generation (1965-1975) along with operating systems. **Key takeaway: 3rd Gen = Widespread High-Level Languages.**"
        },
        "vi": {
            "question": "Ng√¥n ng·ªØ l·∫≠p tr√¨nh b·∫≠c cao xu·∫•t hi·ªán ·ªü th·∫ø h·ªá n√†o?",
            "options": [
                "A. Th·∫ø h·ªá th·ª© nh·∫•t",
                "B. Th·∫ø h·ªá th·ª© hai",
                "C. Th·∫ø h·ªá th·ª© ba",
                "D. Th·∫ø h·ªá th·ª© t∆∞"
            ],
            "answer": "C. Th·∫ø h·ªá th·ª© ba",
            "explanation": "M·∫∑c d√π c√°c ng√¥n ng·ªØ b·∫≠c cao s∆° khai nh∆∞ FORTRAN ƒë√£ xu·∫•t hi·ªán v√†o cu·ªëi th·∫ø h·ªá th·ª© hai, ch√∫ng tr·ªü n√™n ph·ªï bi·∫øn v√† ph·ª©c t·∫°p h∆°n trong th·∫ø h·ªá th·ª© ba (1965-1975) c√πng v·ªõi c√°c h·ªá ƒëi·ªÅu h√†nh. **M·∫πo ghi nh·ªõ: Th·∫ø h·ªá 3 = Ng√¥n ng·ªØ b·∫≠c cao ph·ªï bi·∫øn.**"
        }
    },
    {
        "id": 11,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "When Minicomputers appeared on the market?",
            "options": [
                "A. First generation",
                "B. Second generation",
                "C. Third generation",
                "D. Fourth generation"
            ],
            "answer": "C. Third generation",
            "explanation": "Minicomputers, like the PDP series, emerged during the third generation of computing, made possible by the use of integrated circuits (ICs) which reduced size and cost compared to mainframes. **Key takeaway: Minicomputers = 3rd Generation (ICs).**"
        },
        "vi": {
            "question": "M√°y t√≠nh mini (Minicomputers) xu·∫•t hi·ªán tr√™n th·ªã tr∆∞·ªùng khi n√†o?",
            "options": [
                "A. Th·∫ø h·ªá th·ª© nh·∫•t",
                "B. Th·∫ø h·ªá th·ª© hai",
                "C. Th·∫ø h·ªá th·ª© ba",
                "D. Th·∫ø h·ªá th·ª© t∆∞"
            ],
            "answer": "C. Th·∫ø h·ªá th·ª© ba",
            "explanation": "M√°y t√≠nh mini, nh∆∞ d√≤ng PDP, ƒë√£ xu·∫•t hi·ªán trong th·∫ø h·ªá m√°y t√≠nh th·ª© ba, ƒë∆∞·ª£c t·∫°o ra nh·ªù vi·ªác s·ª≠ d·ª•ng c√°c m·∫°ch t√≠ch h·ª£p (IC) gi√∫p gi·∫£m k√≠ch th∆∞·ªõc v√† chi ph√≠ so v·ªõi m√°y t√≠nh l·ªõn (mainframe). **M·∫πo ghi nh·ªõ: M√°y t√≠nh mini = Th·∫ø h·ªá 3 (IC).**"
        }
    },
    {
        "id": 12,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "Which generation of computers is covered by the period 1964-77?",
            "options": [
                "A. First",
                "B. Second",
                "C. Third",
                "D. Forth"
            ],
            "answer": "C. Third",
            "explanation": "The third generation is generally defined by the use of integrated circuits and spans from the mid-1960s to the mid-1970s. The period 1964-1977 falls squarely within this era. **Key takeaway: Mid-60s to Mid-70s = 3rd Generation.**"
        },
        "vi": {
            "question": "Th·∫ø h·ªá m√°y t√≠nh n√†o bao g·ªìm giai ƒëo·∫°n 1964-77?",
            "options": [
                "A. Th·ª© nh·∫•t",
                "B. Th·ª© hai",
                "C. Th·ª© ba",
                "D. Th·ª© t∆∞"
            ],
            "answer": "C. Th·ª© ba",
            "explanation": "Th·∫ø h·ªá th·ª© ba th∆∞·ªùng ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a b·ªüi vi·ªác s·ª≠ d·ª•ng m·∫°ch t√≠ch h·ª£p v√† k√©o d√†i t·ª´ gi·ªØa nh·ªØng nƒÉm 1960 ƒë·∫øn gi·ªØa nh·ªØng nƒÉm 1970. Giai ƒëo·∫°n 1964-1977 ho√†n to√†n n·∫±m trong k·ª∑ nguy√™n n√†y. **M·∫πo ghi nh·ªõ: Gi·ªØa 60 - Gi·ªØa 70 = Th·∫ø h·ªá 3.**"
        }
    },
    {
        "id": 13,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "Who is considered the 'father' of the minicomputer and one of the founder fathers of the modern computer industry world-wide?",
            "options": [
                "A. George Tate",
                "B. Kenneth H. Olsen",
                "C. Seymour Cray",
                "D. Basic Pascal"
            ],
            "answer": "B. Kenneth H. Olsen",
            "explanation": "Kenneth H. Olsen was the co-founder of Digital Equipment Corporation (DEC), which produced the highly influential PDP series of minicomputers. **Key takeaway: Kenneth Olsen = Father of the Minicomputer (DEC).**"
        },
        "vi": {
            "question": "Ai ƒë∆∞·ª£c coi l√† 'cha ƒë·∫ª' c·ªßa m√°y t√≠nh mini v√† l√† m·ªôt trong nh·ªØng ng∆∞·ªùi s√°ng l·∫≠p ng√†nh c√¥ng nghi·ªáp m√°y t√≠nh hi·ªán ƒë·∫°i tr√™n to√†n th·∫ø gi·ªõi?",
            "options": [
                "A. George Tate",
                "B. Kenneth H. Olsen",
                "C. Seymour Cray",
                "D. Basic Pascal"
            ],
            "answer": "B. Kenneth H. Olsen",
            "explanation": "Kenneth H. Olsen l√† ƒë·ªìng s√°ng l·∫≠p c·ªßa Digital Equipment Corporation (DEC), c√¥ng ty ƒë√£ s·∫£n xu·∫•t d√≤ng m√°y t√≠nh mini PDP c√≥ ·∫£nh h∆∞·ªüng l·ªõn. **M·∫πo ghi nh·ªõ: Kenneth Olsen = Cha ƒë·∫ª c·ªßa m√°y t√≠nh mini (DEC).**"
        }
    },
    {
        "id": 14,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "What is meant by a dedicated computer?",
            "options": [
                "A. Which is used by one person only",
                "B. Which is assigned one and only one task",
                "C. Which uses on kind of software",
                "D. Which is meant for application software only"
            ],
            "answer": "B. Which is assigned one and only one task",
            "explanation": "A dedicated computer is designed and optimized to perform a single, specific function, such as a web server, a router, or the control system in a car. **Key takeaway: Dedicated = One Task.**"
        },
        "vi": {
            "question": "M√°y t√≠nh chuy√™n d·ª•ng (dedicated computer) c√≥ nghƒ©a l√† g√¨?",
            "options": [
                "A. M√°y ch·ªâ ƒë∆∞·ª£c s·ª≠ d·ª•ng b·ªüi m·ªôt ng∆∞·ªùi",
                "B. M√°y ƒë∆∞·ª£c giao cho m·ªôt v√† ch·ªâ m·ªôt nhi·ªám v·ª•",
                "C. M√°y s·ª≠ d·ª•ng m·ªôt lo·∫°i ph·∫ßn m·ªÅm",
                "D. M√°y ch·ªâ d√†nh cho ph·∫ßn m·ªÅm ·ª©ng d·ª•ng"
            ],
            "answer": "B. M√°y ƒë∆∞·ª£c giao cho m·ªôt v√† ch·ªâ m·ªôt nhi·ªám v·ª•",
            "explanation": "M·ªôt m√°y t√≠nh chuy√™n d·ª•ng ƒë∆∞·ª£c thi·∫øt k·∫ø v√† t·ªëi ∆∞u h√≥a ƒë·ªÉ th·ª±c hi·ªán m·ªôt ch·ª©c nƒÉng duy nh·∫•t, c·ª• th·ªÉ, ch·∫≥ng h·∫°n nh∆∞ m√°y ch·ªß web, b·ªô ƒë·ªãnh tuy·∫øn, ho·∫∑c h·ªá th·ªëng ƒëi·ªÅu khi·ªÉn trong √¥ t√¥. **M·∫πo ghi nh·ªõ: Chuy√™n d·ª•ng = M·ªôt nhi·ªám v·ª•.**"
        }
    },
    {
        "id": 15,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "First CAD system called AutoCAD for the PCs was announced in the year 1982. Can you tell who announced it?",
            "options": [
                "A. Intel Corpn.",
                "B. Rolta India Ltd.",
                "C. Autodesk Inc",
                "D. AT & T Corp."
            ],
            "answer": "C. Autodesk Inc",
            "explanation": "AutoCAD is the flagship product of Autodesk, Inc. Its release in 1982 was a landmark event that brought computer-aided design (CAD) to personal computers. **Key takeaway: AutoCAD = Autodesk.**"
        },
        "vi": {
            "question": "H·ªá th·ªëng CAD ƒë·∫ßu ti√™n c√≥ t√™n AutoCAD cho PC ƒë∆∞·ª£c c√¥ng b·ªë v√†o nƒÉm 1982. Ai ƒë√£ c√¥ng b·ªë n√≥?",
            "options": [
                "A. Intel Corpn.",
                "B. Rolta India Ltd.",
                "C. Autodesk Inc",
                "D. AT & T Corp."
            ],
            "answer": "C. Autodesk Inc",
            "explanation": "AutoCAD l√† s·∫£n ph·∫©m ch·ªß l·ª±c c·ªßa Autodesk, Inc. Vi·ªác ph√°t h√†nh n√≥ v√†o nƒÉm 1982 l√† m·ªôt s·ª± ki·ªán mang t√≠nh b∆∞·ªõc ngo·∫∑t, ƒë∆∞a thi·∫øt k·∫ø c√≥ s·ª± h·ªó tr·ª£ c·ªßa m√°y t√≠nh (CAD) ƒë·∫øn v·ªõi m√°y t√≠nh c√° nh√¢n. **M·∫πo ghi nh·ªõ: AutoCAD = Autodesk.**"
        }
    },
    {
        "id": 16,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "Who in 1988 announced the latest version of CD-ROM called CD-ROMXA (extended architecture) which provides a documented means of integrating digital audio with computer data on a CD-ROM disk?",
            "options": [
                "A. Sony",
                "B. Philips",
                "C. Microsoft",
                "D. All of the others"
            ],
            "answer": "B. Philips",
            "explanation": "Philips, along with Sony and Microsoft, was a key player in the development of CD-ROM standards. Philips led the announcement of the CD-ROM XA standard. **Key takeaway: CD-ROM XA = Philips.**"
        },
        "vi": {
            "question": "Ai ƒë√£ c√¥ng b·ªë phi√™n b·∫£n m·ªõi nh·∫•t c·ªßa CD-ROM v√†o nƒÉm 1988 c√≥ t√™n l√† CD-ROMXA (ki·∫øn tr√∫c m·ªü r·ªông) cung c·∫•p m·ªôt ph∆∞∆°ng ti·ªán ƒë∆∞·ª£c ghi nh·∫≠n ƒë·ªÉ t√≠ch h·ª£p √¢m thanh k·ªπ thu·∫≠t s·ªë v·ªõi d·ªØ li·ªáu m√°y t√≠nh tr√™n ƒëƒ©a CD-ROM?",
            "options": [
                "A. Sony",
                "B. Philips",
                "C. Microsoft",
                "D. T·∫•t c·∫£ c√°c b√™n c√≤n l·∫°i"
            ],
            "answer": "B. Philips",
            "explanation": "Philips, c√πng v·ªõi Sony v√† Microsoft, l√† nh·ªØng nh√¢n t·ªë ch√≠nh trong vi·ªác ph√°t tri·ªÉn c√°c ti√™u chu·∫©n CD-ROM. Philips ƒë√£ d·∫´n ƒë·∫ßu trong vi·ªác c√¥ng b·ªë ti√™u chu·∫©n CD-ROM XA. **M·∫πo ghi nh·ªõ: CD-ROM XA = Philips.**"
        }
    },
    {
        "id": 17,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "IBM-PC is an example of _______.",
            "options": [
                "A. A main frame",
                "B. Machine-in-built",
                "C. Micro computer",
                "D. Special purpose"
            ],
            "answer": "C. Micro computer",
            "explanation": "The IBM Personal Computer (PC) was a landmark microcomputer that defined the standard for personal computing for decades. **Key takeaway: IBM-PC = Microcomputer.**"
        },
        "vi": {
            "question": "IBM-PC l√† m·ªôt v√≠ d·ª• v·ªÅ _______.",
            "options": [
                "A. M√°y t√≠nh l·ªõn (Mainframe)",
                "B. M√°y ƒë∆∞·ª£c t√≠ch h·ª£p s·∫µn",
                "C. M√°y vi t√≠nh",
                "D. M√°y chuy√™n d·ª•ng"
            ],
            "answer": "C. M√°y vi t√≠nh",
            "explanation": "M√°y t√≠nh c√° nh√¢n IBM (PC) l√† m·ªôt m√°y vi t√≠nh mang t√≠nh b∆∞·ªõc ngo·∫∑t ƒë√£ ƒë·ªãnh h√¨nh ti√™u chu·∫©n cho m√°y t√≠nh c√° nh√¢n trong nhi·ªÅu th·∫≠p k·ª∑. **M·∫πo ghi nh·ªõ: IBM-PC = M√°y vi t√≠nh.**"
        }
    },
    {
        "id": 18,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "Which 32-bit microprocessor is used in IBM's PS/2 model-80 computer?",
            "options": [
                "A. 8088",
                "B. 80286",
                "C. 80386",
                "D. 80486"
            ],
            "answer": "C. 80386",
            "explanation": "The IBM PS/2 Model 80 was a high-end machine that utilized the powerful Intel 80386, one of the first widely available 32-bit microprocessors. **Key takeaway: PS/2 Model 80 = 80386 (32-bit).**"
        },
        "vi": {
            "question": "Vi x·ª≠ l√Ω 32-bit n√†o ƒë∆∞·ª£c s·ª≠ d·ª•ng trong m√°y t√≠nh PS/2 model-80 c·ªßa IBM?",
            "options": [
                "A. 8088",
                "B. 80286",
                "C. 80386",
                "D. 80486"
            ],
            "answer": "C. 80386",
            "explanation": "IBM PS/2 Model 80 l√† m·ªôt c·ªó m√°y cao c·∫•p s·ª≠ d·ª•ng b·ªô vi x·ª≠ l√Ω Intel 80386 m·∫°nh m·∫Ω, m·ªôt trong nh·ªØng b·ªô vi x·ª≠ l√Ω 32-bit ƒë·∫ßu ti√™n ƒë∆∞·ª£c ph·ªï bi·∫øn r·ªông r√£i. **M·∫πo ghi nh·ªõ: PS/2 Model 80 = 80386 (32-bit).**"
        }
    },
    {
        "id": 19,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "A device invented by Dr. Bobeck in 1966, for mass storage of data is _______.",
            "options": [
                "A. Punched paper tape",
                "B. Magnetic bubble storage",
                "C. Magnetic tape",
                "D. Magnetic disk"
            ],
            "answer": "B. Magnetic bubble storage",
            "explanation": "Magnetic bubble memory was a type of non-volatile computer memory that used a thin film of a magnetic material to hold small magnetized areas, known as bubbles, which each stored one bit of data. **Key takeaway: Dr. Bobeck = Magnetic Bubble Storage.**"
        },
        "vi": {
            "question": "M·ªôt thi·∫øt b·ªã ƒë∆∞·ª£c ph√°t minh b·ªüi Ti·∫øn sƒ© Bobeck v√†o nƒÉm 1966, d√πng ƒë·ªÉ l∆∞u tr·ªØ d·ªØ li·ªáu h√†ng lo·∫°t l√† _______.",
            "options": [
                "A. BƒÉng gi·∫•y ƒë·ª•c l·ªó",
                "B. B·ªô nh·ªõ bong b√≥ng t·ª´",
                "C. BƒÉng t·ª´",
                "D. ƒêƒ©a t·ª´"
            ],
            "answer": "B. B·ªô nh·ªõ bong b√≥ng t·ª´",
            "explanation": "B·ªô nh·ªõ bong b√≥ng t·ª´ l√† m·ªôt lo·∫°i b·ªô nh·ªõ m√°y t√≠nh b·∫•t bi·∫øn s·ª≠ d·ª•ng m·ªôt l·ªõp m√†ng m·ªèng v·∫≠t li·ªáu t·ª´ t√≠nh ƒë·ªÉ gi·ªØ c√°c v√πng t·ª´ h√≥a nh·ªè, ƒë∆∞·ª£c g·ªçi l√† bong b√≥ng, m·ªói bong b√≥ng l∆∞u tr·ªØ m·ªôt bit d·ªØ li·ªáu. **M·∫πo ghi nh·ªõ: Dr. Bobeck = B·ªô nh·ªõ bong b√≥ng t·ª´.**"
        }
    },
    {
        "id": 20,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "A computer is a box full of electronic _______.",
            "options": [
                "A. Switching devices",
                "B. Chips",
                "C. Circuits",
                "D. Registers"
            ],
            "answer": "A. Switching devices",
            "explanation": "At the most fundamental level, all digital computation is performed by millions or billions of tiny electronic switches (transistors) that can be either ON or OFF, representing 1s and 0s. **Key takeaway: Computer = Electronic Switches (Transistors).**"
        },
        "vi": {
            "question": "M·ªôt m√°y t√≠nh l√† m·ªôt chi·∫øc h·ªôp ch·ª©a ƒë·∫ßy c√°c _______ ƒëi·ªán t·ª≠.",
            "options": [
                "A. Thi·∫øt b·ªã chuy·ªÉn m·∫°ch",
                "B. Chip",
                "C. M·∫°ch ƒëi·ªán",
                "D. Thanh ghi"
            ],
            "answer": "A. Thi·∫øt b·ªã chuy·ªÉn m·∫°ch",
            "explanation": "·ªû c·∫•p ƒë·ªô c∆° b·∫£n nh·∫•t, t·∫•t c·∫£ c√°c ph√©p t√≠nh to√°n k·ªπ thu·∫≠t s·ªë ƒë∆∞·ª£c th·ª±c hi·ªán b·ªüi h√†ng tri·ªáu ho·∫∑c h√†ng t·ª∑ c√¥ng t·∫Øc ƒëi·ªán t·ª≠ nh·ªè (b√≥ng b√°n d·∫´n) c√≥ th·ªÉ ·ªü tr·∫°ng th√°i B·∫¨T ho·∫∑c T·∫ÆT, ƒë·∫°i di·ªán cho 1 v√† 0. **M·∫πo ghi nh·ªõ: M√°y t√≠nh = C√¥ng t·∫Øc ƒëi·ªán t·ª≠ (Transistors).**"
        }
    },
    {
        "id": 21,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "The device that can both feed data into and accept data from a computer is _______.",
            "options": [
                "A. ALU",
                "B. CPU",
                "C. Input-Output device",
                "D. All of the others"
            ],
            "answer": "C. Input-Output device",
            "explanation": "An I/O device's purpose is to facilitate communication between the computer and the outside world. For example, a touchscreen is both an input (touch) and output (display) device. **Key takeaway: Two-way communication = I/O device.**"
        },
        "vi": {
            "question": "Thi·∫øt b·ªã c√≥ th·ªÉ v·ª´a ƒë∆∞a d·ªØ li·ªáu v√†o v·ª´a nh·∫≠n d·ªØ li·ªáu t·ª´ m√°y t√≠nh l√† _______.",
            "options": [
                "A. ALU",
                "B. CPU",
                "C. Thi·∫øt b·ªã V√†o-Ra",
                "D. T·∫•t c·∫£ c√°c ph∆∞∆°ng √°n kh√°c"
            ],
            "answer": "C. Thi·∫øt b·ªã V√†o-Ra",
            "explanation": "M·ª•c ƒë√≠ch c·ªßa m·ªôt thi·∫øt b·ªã I/O l√† t·∫°o ƒëi·ªÅu ki·ªán giao ti·∫øp gi·ªØa m√°y t√≠nh v√† th·∫ø gi·ªõi b√™n ngo√†i. V√≠ d·ª•, m·ªôt m√†n h√¨nh c·∫£m ·ª©ng v·ª´a l√† thi·∫øt b·ªã ƒë·∫ßu v√†o (ch·∫°m) v·ª´a l√† thi·∫øt b·ªã ƒë·∫ßu ra (hi·ªÉn th·ªã). **M·∫πo ghi nh·ªõ: Giao ti·∫øp hai chi·ªÅu = Thi·∫øt b·ªã I/O.**"
        }
    },
    {
        "id": 22,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "The organization and interconnection of the various components of a computer system is _______.",
            "options": [
                "A. Architecture",
                "B. Networks",
                "C. Graphics",
                "D. Designing"
            ],
            "answer": "A. Architecture",
            "explanation": "Computer architecture defines the functional behavior of a computer system, including its instruction set, registers, and memory organization. It's the 'blueprint' of the system. **Key takeaway: Interconnection of components = Architecture.**"
        },
        "vi": {
            "question": "S·ª± t·ªï ch·ª©c v√† k·∫øt n·ªëi c·ªßa c√°c th√†nh ph·∫ßn kh√°c nhau trong m·ªôt h·ªá th·ªëng m√°y t√≠nh l√† _______.",
            "options": [
                "A. Ki·∫øn tr√∫c",
                "B. M·∫°ng",
                "C. ƒê·ªì h·ªça",
                "D. Thi·∫øt k·∫ø"
            ],
            "answer": "A. Ki·∫øn tr√∫c",
            "explanation": "Ki·∫øn tr√∫c m√°y t√≠nh ƒë·ªãnh nghƒ©a h√†nh vi ch·ª©c nƒÉng c·ªßa m·ªôt h·ªá th·ªëng m√°y t√≠nh, bao g·ªìm t·∫≠p l·ªánh, thanh ghi v√† t·ªï ch·ª©c b·ªô nh·ªõ c·ªßa n√≥. N√≥ l√† 'b·∫£n thi·∫øt k·∫ø' c·ªßa h·ªá th·ªëng. **M·∫πo ghi nh·ªõ: K·∫øt n·ªëi c√°c th√†nh ph·∫ßn = Ki·∫øn tr√∫c.**"
        }
    },
    {
        "id": 23,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "In a computer, the _______ subsystem performs calculations and logical operations.",
            "options": [
                "A. ALU",
                "B. input/output",
                "C. memory",
                "D. control unit"
            ],
            "answer": "A. ALU",
            "explanation": "The Arithmetic Logic Unit (ALU) is the part of the CPU that carries out arithmetic (add, subtract) and logic (AND, OR, NOT) operations. **Key takeaway: Calculations + Logic = ALU.**"
        },
        "vi": {
            "question": "Trong m√°y t√≠nh, h·ªá th·ªëng con _______ th·ª±c hi·ªán c√°c ph√©p t√≠nh v√† c√°c ho·∫°t ƒë·ªông logic.",
            "options": [
                "A. ALU",
                "B. v√†o/ra",
                "C. b·ªô nh·ªõ",
                "D. ƒë∆°n v·ªã ƒëi·ªÅu khi·ªÉn"
            ],
            "answer": "A. ALU",
            "explanation": "ƒê∆°n v·ªã S·ªë h·ªçc v√† Logic (ALU) l√† m·ªôt ph·∫ßn c·ªßa CPU th·ª±c hi·ªán c√°c ph√©p to√°n s·ªë h·ªçc (c·ªông, tr·ª´) v√† logic (AND, OR, NOT). **M·∫πo ghi nh·ªõ: T√≠nh to√°n + Logic = ALU.**"
        }
    },
    {
        "id": 24,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "In a computer, the _______ subsystem stores data and programs.",
            "options": [
                "A. ALU",
                "B. input/output",
                "C. memory",
                "D. control unit"
            ],
            "answer": "C. memory",
            "explanation": "The memory subsystem (including RAM and other forms of storage) is responsible for holding the data and the program instructions that the CPU needs to access. **Key takeaway: Stores data/programs = Memory.**"
        },
        "vi": {
            "question": "Trong m√°y t√≠nh, h·ªá th·ªëng con _______ l∆∞u tr·ªØ d·ªØ li·ªáu v√† ch∆∞∆°ng tr√¨nh.",
            "options": [
                "A. ALU",
                "B. v√†o/ra",
                "C. b·ªô nh·ªõ",
                "D. ƒë∆°n v·ªã ƒëi·ªÅu khi·ªÉn"
            ],
            "answer": "C. b·ªô nh·ªõ",
            "explanation": "H·ªá th·ªëng con b·ªô nh·ªõ (bao g·ªìm RAM v√† c√°c d·∫°ng l∆∞u tr·ªØ kh√°c) ch·ªãu tr√°ch nhi·ªám gi·ªØ d·ªØ li·ªáu v√† c√°c ch·ªâ th·ªã ch∆∞∆°ng tr√¨nh m√† CPU c·∫ßn truy c·∫≠p. **M·∫πo ghi nh·ªõ: L∆∞u tr·ªØ d·ªØ li·ªáu/ch∆∞∆°ng tr√¨nh = B·ªô nh·ªõ.**"
        }
    },
    {
        "id": 25,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "In a computer, the _______ subsystem accepts data and programs and sends processing results to output devices.",
            "options": [
                "A. ALU",
                "B. input/output",
                "C. memory",
                "D. control unit"
            ],
            "answer": "B. input/output",
            "explanation": "The Input/Output (I/O) subsystem is the bridge between the computer's internal components (CPU, memory) and the outside world (keyboards, monitors, networks). **Key takeaway: Bridge to outside world = I/O.**"
        },
        "vi": {
            "question": "Trong m√°y t√≠nh, h·ªá th·ªëng con _______ nh·∫≠n d·ªØ li·ªáu v√† ch∆∞∆°ng tr√¨nh v√† g·ª≠i k·∫øt qu·∫£ x·ª≠ l√Ω ƒë·∫øn c√°c thi·∫øt b·ªã ƒë·∫ßu ra.",
            "options": [
                "A. ALU",
                "B. v√†o/ra",
                "C. b·ªô nh·ªõ",
                "D. ƒë∆°n v·ªã ƒëi·ªÅu khi·ªÉn"
            ],
            "answer": "B. v√†o/ra",
            "explanation": "H·ªá th·ªëng con V√†o/Ra (I/O) l√† c·∫ßu n·ªëi gi·ªØa c√°c th√†nh ph·∫ßn b√™n trong c·ªßa m√°y t√≠nh (CPU, b·ªô nh·ªõ) v√† th·∫ø gi·ªõi b√™n ngo√†i (b√†n ph√≠m, m√†n h√¨nh, m·∫°ng). **M·∫πo ghi nh·ªõ: C·∫ßu n·ªëi v·ªõi th·∫ø gi·ªõi b√™n ngo√†i = I/O.**"
        }
    },
    {
        "id": 26,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "In a computer, the _______ subsystem serves as a manager of the other subsystems.",
            "options": [
                "A. ALU",
                "B. input/output",
                "C. memory",
                "D. control unit"
            ],
            "answer": "D. control unit",
            "explanation": "The Control Unit (CU) is the 'brain' of the CPU. It directs the flow of data, fetches instructions from memory, and coordinates the actions of the ALU, memory, and I/O devices. **Key takeaway: Manager/Director = Control Unit.**"
        },
        "vi": {
            "question": "Trong m√°y t√≠nh, h·ªá th·ªëng con _______ ƒë√≥ng vai tr√≤ l√† ng∆∞·ªùi qu·∫£n l√Ω c·ªßa c√°c h·ªá th·ªëng con kh√°c.",
            "options": [
                "A. ALU",
                "B. v√†o/ra",
                "C. b·ªô nh·ªõ",
                "D. ƒë∆°n v·ªã ƒëi·ªÅu khi·ªÉn"
            ],
            "answer": "D. ƒë∆°n v·ªã ƒëi·ªÅu khi·ªÉn",
            "explanation": "ƒê∆°n v·ªã ƒêi·ªÅu khi·ªÉn (CU) l√† 'b·ªô n√£o' c·ªßa CPU. N√≥ ch·ªâ ƒë·∫°o lu·ªìng d·ªØ li·ªáu, l·∫•y l·ªánh t·ª´ b·ªô nh·ªõ v√† ƒëi·ªÅu ph·ªëi c√°c ho·∫°t ƒë·ªông c·ªßa ALU, b·ªô nh·ªõ v√† c√°c thi·∫øt b·ªã I/O. **M·∫πo ghi nh·ªõ: Ng∆∞·ªùi qu·∫£n l√Ω/Ch·ªâ ƒë·∫°o = ƒê∆°n v·ªã ƒëi·ªÅu khi·ªÉn.**"
        }
    },
    {
        "id": 27,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "In a computer, the _______ subsystem stores data and programs",
            "options": [
                "A. ALU",
                "B. Input/output",
                "C. Memory",
                "D. Control unit"
            ],
            "answer": "C. Memory",
            "explanation": "This is a repeated question. The memory subsystem's primary role is storage of active data and programs. **Key takeaway: Storage = Memory.**"
        },
        "vi": {
            "question": "Trong m√°y t√≠nh, h·ªá th·ªëng con _______ l∆∞u tr·ªØ d·ªØ li·ªáu v√† ch∆∞∆°ng tr√¨nh",
            "options": [
                "A. ALU",
                "B. V√†o/ra",
                "C. B·ªô nh·ªõ",
                "D. ƒê∆°n v·ªã ƒëi·ªÅu khi·ªÉn"
            ],
            "answer": "C. B·ªô nh·ªõ",
            "explanation": "ƒê√¢y l√† m·ªôt c√¢u h·ªèi l·∫∑p l·∫°i. Vai tr√≤ ch√≠nh c·ªßa h·ªá th·ªëng con b·ªô nh·ªõ l√† l∆∞u tr·ªØ d·ªØ li·ªáu v√† ch∆∞∆°ng tr√¨nh ƒëang ho·∫°t ƒë·ªông. **M·∫πo ghi nh·ªõ: L∆∞u tr·ªØ = B·ªô nh·ªõ.**"
        }
    },
    {
        "id": 28,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "According to the von Neumann model, _______ are stored in memory.",
            "options": [
                "A. only data",
                "B. only programs",
                "C. data and programs",
                "D. neither data nor programs"
            ],
            "answer": "C. data and programs",
            "explanation": "The core principle of the von Neumann architecture is the 'stored-program concept', where both the instructions (program) and the data they operate on are held in the same memory space. **Key takeaway: von Neumann = Data + Program in same memory.**"
        },
        "vi": {
            "question": "Theo m√¥ h√¨nh von Neumann, _______ ƒë∆∞·ª£c l∆∞u tr·ªØ trong b·ªô nh·ªõ.",
            "options": [
                "A. ch·ªâ d·ªØ li·ªáu",
                "B. ch·ªâ ch∆∞∆°ng tr√¨nh",
                "C. d·ªØ li·ªáu v√† ch∆∞∆°ng tr√¨nh",
                "D. c·∫£ d·ªØ li·ªáu v√† ch∆∞∆°ng tr√¨nh ƒë·ªÅu kh√¥ng"
            ],
            "answer": "C. d·ªØ li·ªáu v√† ch∆∞∆°ng tr√¨nh",
            "explanation": "Nguy√™n t·∫Øc c·ªët l√µi c·ªßa ki·∫øn tr√∫c von Neumann l√† 'kh√°i ni·ªám ch∆∞∆°ng tr√¨nh ƒë∆∞·ª£c l∆∞u tr·ªØ', trong ƒë√≥ c·∫£ ch·ªâ th·ªã (ch∆∞∆°ng tr√¨nh) v√† d·ªØ li·ªáu m√† ch√∫ng ho·∫°t ƒë·ªông tr√™n ƒë·ªÅu ƒë∆∞·ª£c gi·ªØ trong c√πng m·ªôt kh√¥ng gian b·ªô nh·ªõ. **M·∫πo ghi nh·ªõ: von Neumann = D·ªØ li·ªáu + Ch∆∞∆°ng tr√¨nh trong c√πng b·ªô nh·ªõ.**"
        }
    },
    {
        "id": 29,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "The _______ is a computer subsystem that performs operations on data.",
            "options": [
                "A. Memory",
                "B. CPU",
                "C. I/O subsystem",
                "D. Control Unit"
            ],
            "answer": "B. CPU",
            "explanation": "The Central Processing Unit (CPU) is the component responsible for executing instructions and performing operations on data. It contains the ALU and Control Unit. **Key takeaway: Performs operations = CPU.**"
        },
        "vi": {
            "question": "_______ l√† m·ªôt h·ªá th·ªëng con c·ªßa m√°y t√≠nh th·ª±c hi·ªán c√°c ho·∫°t ƒë·ªông tr√™n d·ªØ li·ªáu.",
            "options": [
                "A. B·ªô nh·ªõ",
                "B. CPU",
                "C. H·ªá th·ªëng con I/O",
                "D. ƒê∆°n v·ªã ƒëi·ªÅu khi·ªÉn"
            ],
            "answer": "B. CPU",
            "explanation": "ƒê∆°n v·ªã x·ª≠ l√Ω trung t√¢m (CPU) l√† th√†nh ph·∫ßn ch·ªãu tr√°ch nhi·ªám th·ª±c thi c√°c ch·ªâ th·ªã v√† th·ª±c hi·ªán c√°c ho·∫°t ƒë·ªông tr√™n d·ªØ li·ªáu. N√≥ ch·ª©a ALU v√† ƒê∆°n v·ªã ƒëi·ªÅu khi·ªÉn. **M·∫πo ghi nh·ªõ: Th·ª±c hi·ªán ho·∫°t ƒë·ªông = CPU.**"
        }
    },
    {
        "id": 30,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "_______ is a stand-alone storage location that holds data temporarily.",
            "options": [
                "A. An ALU",
                "B. A register",
                "C. A control unit",
                "D. A bus"
            ],
            "answer": "B. A register",
            "explanation": "Registers are small, extremely fast storage locations located directly within the CPU. They are used to temporarily hold data, instructions, and addresses that are being actively processed. **Key takeaway: Fast, temporary CPU storage = Register.**"
        },
        "vi": {
            "question": "_______ l√† m·ªôt v·ªã tr√≠ l∆∞u tr·ªØ ƒë·ªôc l·∫≠p d√πng ƒë·ªÉ gi·ªØ d·ªØ li·ªáu t·∫°m th·ªùi.",
            "options": [
                "A. M·ªôt ALU",
                "B. M·ªôt thanh ghi",
                "C. M·ªôt ƒë∆°n v·ªã ƒëi·ªÅu khi·ªÉn",
                "D. M·ªôt bus"
            ],
            "answer": "B. M·ªôt thanh ghi",
            "explanation": "Thanh ghi l√† c√°c v·ªã tr√≠ l∆∞u tr·ªØ nh·ªè, c·ª±c k·ª≥ nhanh n·∫±m tr·ª±c ti·∫øp b√™n trong CPU. Ch√∫ng ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ t·∫°m th·ªùi gi·ªØ d·ªØ li·ªáu, ch·ªâ th·ªã v√† ƒë·ªãa ch·ªâ ƒëang ƒë∆∞·ª£c x·ª≠ l√Ω t√≠ch c·ª±c. **M·∫πo ghi nh·ªõ: L∆∞u tr·ªØ t·∫°m th·ªùi, nhanh trong CPU = Thanh ghi.**"
        }
    },
    {
        "id": 31,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "A register in a CPU can hold _______.",
            "options": [
                "A. only data",
                "B. only instructions",
                "C. only program counter values",
                "D. data, instructions, or program counter values"
            ],
            "answer": "D. data, instructions, or program counter values",
            "explanation": "Different types of registers exist for different purposes. Data registers hold data, the Instruction Register (IR) holds the current instruction, and the Program Counter (PC) holds an address (a type of data). **Key takeaway: Registers have diverse roles.**"
        },
        "vi": {
            "question": "M·ªôt thanh ghi trong CPU c√≥ th·ªÉ ch·ª©a _______.",
            "options": [
                "A. ch·ªâ d·ªØ li·ªáu",
                "B. ch·ªâ ch·ªâ th·ªã",
                "C. ch·ªâ gi√° tr·ªã b·ªô ƒë·∫øm ch∆∞∆°ng tr√¨nh",
                "D. d·ªØ li·ªáu, ch·ªâ th·ªã, ho·∫∑c gi√° tr·ªã b·ªô ƒë·∫øm ch∆∞∆°ng tr√¨nh"
            ],
            "answer": "D. d·ªØ li·ªáu, ch·ªâ th·ªã, ho·∫∑c gi√° tr·ªã b·ªô ƒë·∫øm ch∆∞∆°ng tr√¨nh",
            "explanation": "C√≥ nhi·ªÅu lo·∫°i thanh ghi kh√°c nhau cho c√°c m·ª•c ƒë√≠ch kh√°c nhau. Thanh ghi d·ªØ li·ªáu ch·ª©a d·ªØ li·ªáu, Thanh ghi Ch·ªâ th·ªã (IR) ch·ª©a ch·ªâ th·ªã hi·ªán t·∫°i, v√† B·ªô ƒë·∫øm Ch∆∞∆°ng tr√¨nh (PC) ch·ª©a m·ªôt ƒë·ªãa ch·ªâ (m·ªôt lo·∫°i d·ªØ li·ªáu). **M·∫πo ghi nh·ªõ: Thanh ghi c√≥ vai tr√≤ ƒëa d·∫°ng.**"
        }
    },
    {
        "id": 32,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "A control unit with five wires can define up to _______ operations.",
            "options": [
                "A. 5",
                "B. 10",
                "C. 16",
                "D. 32"
            ],
            "answer": "D. 32",
            "explanation": "The number of unique combinations that can be represented by 'n' wires (or bits) is 2^n. Therefore, with 5 wires, you can define 2^5 = 32 unique operations. **Key takeaway: n wires = 2^n combinations.**"
        },
        "vi": {
            "question": "M·ªôt ƒë∆°n v·ªã ƒëi·ªÅu khi·ªÉn v·ªõi nƒÉm d√¢y c√≥ th·ªÉ ƒë·ªãnh nghƒ©a t·ªëi ƒëa _______ ho·∫°t ƒë·ªông.",
            "options": [
                "A. 5",
                "B. 10",
                "C. 16",
                "D. 32"
            ],
            "answer": "D. 32",
            "explanation": "S·ªë l∆∞·ª£ng t·ªï h·ª£p duy nh·∫•t c√≥ th·ªÉ ƒë∆∞·ª£c bi·ªÉu di·ªÖn b·∫±ng 'n' d√¢y (ho·∫∑c bit) l√† 2^n. Do ƒë√≥, v·ªõi 5 d√¢y, b·∫°n c√≥ th·ªÉ ƒë·ªãnh nghƒ©a 2^5 = 32 ho·∫°t ƒë·ªông duy nh·∫•t. **M·∫πo ghi nh·ªõ: n d√¢y = 2^n t·ªï h·ª£p.**"
        }
    },
    {
        "id": 33,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "Where have the program and data to be located before the ALU and control unit of a computer can operate on it?",
            "options": [
                "A. Internal memory",
                "B. Secondary memory",
                "C. Microprocessor",
                "D. Magnetic tapes"
            ],
            "answer": "A. Internal memory",
            "explanation": "The CPU can only directly access data and instructions that are in the internal memory (main memory, or RAM). Data from secondary memory (like an SSD) must first be loaded into RAM to be processed. **Key takeaway: CPU operates on data in RAM (Internal Memory).**"
        },
        "vi": {
            "question": "Ch∆∞∆°ng tr√¨nh v√† d·ªØ li·ªáu ph·∫£i ƒë∆∞·ª£c ƒë·∫∑t ·ªü ƒë√¢u tr∆∞·ªõc khi ALU v√† ƒë∆°n v·ªã ƒëi·ªÅu khi·ªÉn c·ªßa m√°y t√≠nh c√≥ th·ªÉ ho·∫°t ƒë·ªông tr√™n n√≥?",
            "options": [
                "A. B·ªô nh·ªõ trong",
                "B. B·ªô nh·ªõ ngo√†i",
                "C. Vi x·ª≠ l√Ω",
                "D. BƒÉng t·ª´"
            ],
            "answer": "A. B·ªô nh·ªõ trong",
            "explanation": "CPU ch·ªâ c√≥ th·ªÉ truy c·∫≠p tr·ª±c ti·∫øp d·ªØ li·ªáu v√† ch·ªâ th·ªã n·∫±m trong b·ªô nh·ªõ trong (b·ªô nh·ªõ ch√≠nh, ho·∫∑c RAM). D·ªØ li·ªáu t·ª´ b·ªô nh·ªõ ngo√†i (nh∆∞ SSD) ph·∫£i ƒë∆∞·ª£c n·∫°p v√†o RAM tr∆∞·ªõc khi ƒë∆∞·ª£c x·ª≠ l√Ω. **M·∫πo ghi nh·ªõ: CPU ho·∫°t ƒë·ªông tr√™n d·ªØ li·ªáu trong RAM (B·ªô nh·ªõ trong).**"
        }
    },
    {
        "id": 34,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "Where does a computer add and compare data?",
            "options": [
                "A. Hard disk",
                "B. Floppy disk",
                "C. CPU chip",
                "D. Memory chip"
            ],
            "answer": "C. CPU chip",
            "explanation": "These operations are performed by the Arithmetic Logic Unit (ALU), which is a core component inside the CPU chip. **Key takeaway: Calculation/Comparison happens in the CPU.**"
        },
        "vi": {
            "question": "M√°y t√≠nh c·ªông v√† so s√°nh d·ªØ li·ªáu ·ªü ƒë√¢u?",
            "options": [
                "A. ƒêƒ©a c·ª©ng",
                "B. ƒêƒ©a m·ªÅm",
                "C. Chip CPU",
                "D. Chip b·ªô nh·ªõ"
            ],
            "answer": "C. Chip CPU",
            "explanation": "C√°c ho·∫°t ƒë·ªông n√†y ƒë∆∞·ª£c th·ª±c hi·ªán b·ªüi ƒê∆°n v·ªã S·ªë h·ªçc v√† Logic (ALU), l√† m·ªôt th√†nh ph·∫ßn c·ªët l√µi b√™n trong chip CPU. **M·∫πo ghi nh·ªõ: T√≠nh to√°n/So s√°nh di·ªÖn ra trong CPU.**"
        }
    },
    {
        "id": 35,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "The smallest storage area on a magnetic disk that can be accessed at one time is a _______.",
            "options": [
                "A. sector",
                "B. track",
                "C. head",
                "D. frame"
            ],
            "answer": "A. sector",
            "explanation": "A magnetic disk is organized into tracks (concentric circles) and sectors (pie-shaped wedges). A sector is the smallest addressable unit of storage on the disk. **Key takeaway: Smallest disk unit = Sector.**"
        },
        "vi": {
            "question": "V√πng l∆∞u tr·ªØ nh·ªè nh·∫•t tr√™n m·ªôt ƒëƒ©a t·ª´ c√≥ th·ªÉ ƒë∆∞·ª£c truy c·∫≠p t·∫°i m·ªôt th·ªùi ƒëi·ªÉm l√† m·ªôt _______.",
            "options": [
                "A. sector (cung)",
                "B. track (r√£nh)",
                "C. head (ƒë·∫ßu ƒë·ªçc)",
                "D. frame (khung)"
            ],
            "answer": "A. sector (cung)",
            "explanation": "M·ªôt ƒëƒ©a t·ª´ ƒë∆∞·ª£c t·ªï ch·ª©c th√†nh c√°c track (v√≤ng tr√≤n ƒë·ªìng t√¢m) v√† sector (c√°c m·∫£nh h√¨nh n√™m). M·ªôt sector l√† ƒë∆°n v·ªã l∆∞u tr·ªØ c√≥ th·ªÉ ƒë·ªãnh ƒë·ªãa ch·ªâ nh·ªè nh·∫•t tr√™n ƒëƒ©a. **M·∫πo ghi nh·ªõ: ƒê∆°n v·ªã ƒëƒ©a nh·ªè nh·∫•t = Sector.**"
        }
    },
    {
        "id": 36,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "Any device that performs signal conversion is a _______.",
            "options": [
                "A. Modulator",
                "B. Modem",
                "C. Keyboard",
                "D. Plotter"
            ],
            "answer": "B. Modem",
            "explanation": "A Modem (Modulator-Demodulator) is a device that converts digital signals from a computer into analog signals for transmission over phone lines (modulation) and converts incoming analog signals back into digital signals (demodulation). **Key takeaway: Modem = MOdulator + DEModulator.**"
        },
        "vi": {
            "question": "B·∫•t k·ª≥ thi·∫øt b·ªã n√†o th·ª±c hi·ªán chuy·ªÉn ƒë·ªïi t√≠n hi·ªáu ƒë·ªÅu l√† m·ªôt _______.",
            "options": [
                "A. B·ªô ƒëi·ªÅu ch·∫ø",
                "B. Modem",
                "C. B√†n ph√≠m",
                "D. M√°y v·∫Ω"
            ],
            "answer": "B. Modem",
            "explanation": "Modem (Modulator-Demodulator) l√† m·ªôt thi·∫øt b·ªã chuy·ªÉn ƒë·ªïi t√≠n hi·ªáu s·ªë t·ª´ m√°y t√≠nh th√†nh t√≠n hi·ªáu analog ƒë·ªÉ truy·ªÅn qua ƒë∆∞·ªùng d√¢y ƒëi·ªán tho·∫°i (ƒëi·ªÅu ch·∫ø) v√† chuy·ªÉn ƒë·ªïi t√≠n hi·ªáu analog ƒë·∫øn th√†nh t√≠n hi·ªáu s·ªë (gi·∫£i ƒëi·ªÅu ch·∫ø). **M·∫πo ghi nh·ªõ: Modem = MOdulator + DEModulator.**"
        }
    },
    {
        "id": 37,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "The most important advantage of a video disk is _______.",
            "options": [
                "A. Compactness",
                "B. Potential capacity",
                "C. Durability",
                "D. Cost effectiveness"
            ],
            "answer": "B. Potential capacity",
            "explanation": "Compared to other storage media of its time (like floppy disks or magnetic tape), optical video disks (like LaserDisc, DVD, Blu-ray) offered a vastly larger storage capacity, making them suitable for large video files. **Key takeaway: Video Disk = High Capacity.**"
        },
        "vi": {
            "question": "∆Øu ƒëi·ªÉm quan tr·ªçng nh·∫•t c·ªßa ƒëƒ©a video l√† _______.",
            "options": [
                "A. S·ª± nh·ªè g·ªçn",
                "B. Dung l∆∞·ª£ng ti·ªÅm nƒÉng",
                "C. ƒê·ªô b·ªÅn",
                "D. Hi·ªáu qu·∫£ chi ph√≠"
            ],
            "answer": "B. Dung l∆∞·ª£ng ti·ªÅm nƒÉng",
            "explanation": "So v·ªõi c√°c ph∆∞∆°ng ti·ªán l∆∞u tr·ªØ kh√°c c√πng th·ªùi (nh∆∞ ƒëƒ©a m·ªÅm ho·∫∑c bƒÉng t·ª´), ƒëƒ©a video quang h·ªçc (nh∆∞ LaserDisc, DVD, Blu-ray) cung c·∫•p dung l∆∞·ª£ng l∆∞u tr·ªØ l·ªõn h∆°n r·∫•t nhi·ªÅu, l√†m cho ch√∫ng ph√π h·ª£p v·ªõi c√°c t·ªáp video l·ªõn. **M·∫πo ghi nh·ªõ: ƒêƒ©a Video = Dung l∆∞·ª£ng cao.**"
        }
    },
    {
        "id": 38,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "Registers which are partially visible to users and used to hold conditional codes are known as _______.",
            "options": [
                "A. General purpose registers",
                "B. PC (Program Counter)",
                "C. Flags",
                "D. Memory Address Registers"
            ],
            "answer": "C. Flags",
            "explanation": "The flags register (or status register) contains individual bits (flags) that are set or cleared by the ALU after an operation. These flags (like Zero Flag, Carry Flag) represent the outcome of the operation and are used for conditional branching. **Key takeaway: Conditional codes = Flags.**"
        },
        "vi": {
            "question": "C√°c thanh ghi m√† ng∆∞·ªùi d√πng c√≥ th·ªÉ th·∫•y m·ªôt ph·∫ßn v√† ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ gi·ªØ c√°c m√£ ƒëi·ªÅu ki·ªán ƒë∆∞·ª£c g·ªçi l√† _______.",
            "options": [
                "A. Thanh ghi ƒëa d·ª•ng",
                "B. PC (B·ªô ƒë·∫øm ch∆∞∆°ng tr√¨nh)",
                "C. C·ªù (Flags)",
                "D. Thanh ghi ƒë·ªãa ch·ªâ b·ªô nh·ªõ"
            ],
            "answer": "C. C·ªù (Flags)",
            "explanation": "Thanh ghi c·ªù (ho·∫∑c thanh ghi tr·∫°ng th√°i) ch·ª©a c√°c bit ri√™ng l·∫ª (c·ªù) ƒë∆∞·ª£c ALU thi·∫øt l·∫≠p ho·∫∑c x√≥a sau m·ªôt ho·∫°t ƒë·ªông. Nh·ªØng c·ªù n√†y (nh∆∞ C·ªù Zero, C·ªù Nh·ªõ) ƒë·∫°i di·ªán cho k·∫øt qu·∫£ c·ªßa ho·∫°t ƒë·ªông v√† ƒë∆∞·ª£c s·ª≠ d·ª•ng cho r·∫Ω nh√°nh c√≥ ƒëi·ªÅu ki·ªán. **M·∫πo ghi nh·ªõ: M√£ ƒëi·ªÅu ki·ªán = C·ªù.**"
        }
    },
    {
        "id": 39,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "The data in _______ is erased if the computer is powered down.",
            "options": [
                "A. ROM",
                "B. RAM",
                "C. PROM",
                "D. EPROM"
            ],
            "answer": "B. RAM",
            "explanation": "RAM (Random Access Memory) is volatile, meaning it requires power to maintain the stored information. ROM (Read-Only Memory) and its variants are non-volatile. **Key takeaway: Data erased on power down = Volatile = RAM.**"
        },
        "vi": {
            "question": "D·ªØ li·ªáu trong _______ s·∫Ω b·ªã x√≥a n·∫øu m√°y t√≠nh b·ªã t·∫Øt ngu·ªìn.",
            "options": [
                "A. ROM",
                "B. RAM",
                "C. PROM",
                "D. EPROM"
            ],
            "answer": "B. RAM",
            "explanation": "RAM (B·ªô nh·ªõ truy c·∫≠p ng·∫´u nhi√™n) l√† b·ªô nh·ªõ kh·∫£ bi·∫øn, c√≥ nghƒ©a l√† n√≥ c·∫ßn ngu·ªìn ƒëi·ªán ƒë·ªÉ duy tr√¨ th√¥ng tin ƒë∆∞·ª£c l∆∞u tr·ªØ. ROM (B·ªô nh·ªõ ch·ªâ ƒë·ªçc) v√† c√°c bi·∫øn th·ªÉ c·ªßa n√≥ l√† b·ªô nh·ªõ b·∫•t bi·∫øn. **M·∫πo ghi nh·ªõ: D·ªØ li·ªáu b·ªã x√≥a khi t·∫Øt ngu·ªìn = Kh·∫£ bi·∫øn = RAM.**"
        }
    },
    {
        "id": 40,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "_______ is a memory type with capacitors that need to be refreshed periodically.",
            "options": [
                "A. SRAM",
                "B. ROM",
                "C. DRAM",
                "D. EPROM"
            ],
            "answer": "C. DRAM",
            "explanation": "Dynamic RAM (DRAM) stores each bit of data in a separate capacitor within an integrated circuit. Since capacitors leak charge, the information eventually fades unless the capacitor charge is refreshed periodically. **Key takeaway: Dynamic/Capacitors/Refresh = DRAM.**"
        },
        "vi": {
            "question": "_______ l√† m·ªôt lo·∫°i b·ªô nh·ªõ v·ªõi c√°c t·ª• ƒëi·ªán c·∫ßn ƒë∆∞·ª£c l√†m t∆∞∆°i ƒë·ªãnh k·ª≥.",
            "options": [
                "A. SRAM",
                "B. ROM",
                "C. DRAM",
                "D. EPROM"
            ],
            "answer": "C. DRAM",
            "explanation": "RAM ƒë·ªông (DRAM) l∆∞u tr·ªØ m·ªói bit d·ªØ li·ªáu trong m·ªôt t·ª• ƒëi·ªán ri√™ng bi·ªát trong m·ªôt m·∫°ch t√≠ch h·ª£p. V√¨ c√°c t·ª• ƒëi·ªán b·ªã r√≤ r·ªâ ƒëi·ªán t√≠ch, th√¥ng tin cu·ªëi c√πng s·∫Ω m·∫•t ƒëi tr·ª´ khi ƒëi·ªán t√≠ch c·ªßa t·ª• ƒëi·ªán ƒë∆∞·ª£c l√†m t∆∞∆°i ƒë·ªãnh k·ª≥. **M·∫πo ghi nh·ªõ: ƒê·ªông/T·ª• ƒëi·ªán/L√†m t∆∞∆°i = DRAM.**"
        }
    },
    {
        "id": 41,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "_______ is a memory type with traditional flip-flop gates to hold data.",
            "options": [
                "A. SRAM",
                "B. DRAM",
                "C. EEPROM",
                "D. Hard Disk"
            ],
            "answer": "A. SRAM",
            "explanation": "Static RAM (SRAM) uses a bistable latching circuitry (flip-flop) to store each bit. It does not need to be refreshed, making it faster but less dense and more expensive than DRAM. **Key takeaway: Static/Flip-flop = SRAM.**"
        },
        "vi": {
            "question": "_______ l√† m·ªôt lo·∫°i b·ªô nh·ªõ v·ªõi c√°c c·ªïng flip-flop truy·ªÅn th·ªëng ƒë·ªÉ gi·ªØ d·ªØ li·ªáu.",
            "options": [
                "A. SRAM",
                "B. DRAM",
                "C. EEPROM",
                "D. ƒêƒ©a c·ª©ng"
            ],
            "answer": "A. SRAM",
            "explanation": "RAM tƒ©nh (SRAM) s·ª≠ d·ª•ng m·ªôt m·∫°ch ch·ªët ·ªïn ƒë·ªãnh hai tr·∫°ng th√°i (flip-flop) ƒë·ªÉ l∆∞u tr·ªØ m·ªói bit. N√≥ kh√¥ng c·∫ßn ƒë∆∞·ª£c l√†m t∆∞∆°i, l√†m cho n√≥ nhanh h∆°n nh∆∞ng m·∫≠t ƒë·ªô th·∫•p h∆°n v√† ƒë·∫Øt h∆°n DRAM. **M·∫πo ghi nh·ªõ: Tƒ©nh/Flip-flop = SRAM.**"
        }
    },
    {
        "id": 42,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "_______ can be programmed and erased using electronic impulses but can remain in a computer during erasure.",
            "options": [
                "A. PROM",
                "B. EPROM",
                "C. EEPROM",
                "D. RAM"
            ],
            "answer": "C. EEPROM",
            "explanation": "Electrically Erasable Programmable Read-Only Memory (EEPROM) can be erased and reprogrammed electrically, byte by byte, without being removed from the circuit. EPROM needs UV light and must be removed. **Key takeaway: Electrically Erasable = EEPROM.**"
        },
        "vi": {
            "question": "_______ c√≥ th·ªÉ ƒë∆∞·ª£c l·∫≠p tr√¨nh v√† x√≥a b·∫±ng xung ƒëi·ªán nh∆∞ng c√≥ th·ªÉ v·∫´n ·ªü trong m√°y t√≠nh trong qu√° tr√¨nh x√≥a.",
            "options": [
                "A. PROM",
                "B. EPROM",
                "C. EEPROM",
                "D. RAM"
            ],
            "answer": "C. EEPROM",
            "explanation": "B·ªô nh·ªõ ch·ªâ ƒë·ªçc c√≥ th·ªÉ l·∫≠p tr√¨nh v√† x√≥a b·∫±ng ƒëi·ªán (EEPROM) c√≥ th·ªÉ ƒë∆∞·ª£c x√≥a v√† l·∫≠p tr√¨nh l·∫°i b·∫±ng ƒëi·ªán, t·ª´ng byte m·ªôt, m√† kh√¥ng c·∫ßn th√°o ra kh·ªèi m·∫°ch. EPROM c·∫ßn √°nh s√°ng tia c·ª±c t√≠m v√† ph·∫£i ƒë∆∞·ª£c th√°o ra. **M·∫πo ghi nh·ªõ: X√≥a b·∫±ng ƒëi·ªán = EEPROM.**"
        }
    },
    {
        "id": 43,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "_______ is a type of memory in which the user, not the manufacturer, stores programs that cannot be overwritten.",
            "options": [
                "A. PROM",
                "B. RAM",
                "C. DRAM",
                "D. EEPROM"
            ],
            "answer": "A. PROM",
            "explanation": "Programmable Read-Only Memory (PROM) can be written to exactly once by the user with a special device. After that, it becomes read-only and cannot be changed. **Key takeaway: Programmable once = PROM.**"
        },
        "vi": {
            "question": "_______ l√† m·ªôt lo·∫°i b·ªô nh·ªõ trong ƒë√≥ ng∆∞·ªùi d√πng, ch·ª© kh√¥ng ph·∫£i nh√† s·∫£n xu·∫•t, l∆∞u tr·ªØ c√°c ch∆∞∆°ng tr√¨nh kh√¥ng th·ªÉ b·ªã ghi ƒë√®.",
            "options": [
                "A. PROM",
                "B. RAM",
                "C. DRAM",
                "D. EEPROM"
            ],
            "answer": "A. PROM",
            "explanation": "B·ªô nh·ªõ ch·ªâ ƒë·ªçc c√≥ th·ªÉ l·∫≠p tr√¨nh (PROM) c√≥ th·ªÉ ƒë∆∞·ª£c ghi v√†o ƒë√∫ng m·ªôt l·∫ßn b·ªüi ng∆∞·ªùi d√πng b·∫±ng m·ªôt thi·∫øt b·ªã ƒë·∫∑c bi·ªát. Sau ƒë√≥, n√≥ tr·ªü th√†nh ch·ªâ ƒë·ªçc v√† kh√¥ng th·ªÉ thay ƒë·ªïi. **M·∫πo ghi nh·ªõ: L·∫≠p tr√¨nh m·ªôt l·∫ßn = PROM.**"
        }
    },
    {
        "id": 44,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "_______ can be programmed by the user, but can also be erased with a special device that applies ultraviolet light.",
            "options": [
                "A. ROM",
                "B. EEPROM",
                "C. PROM",
                "D. EPROM"
            ],
            "answer": "D. EPROM",
            "explanation": "Erasable Programmable Read-Only Memory (EPROM) is erased by exposing it to strong ultraviolet (UV) light through a quartz window on the chip. It must be removed from the computer for erasure. **Key takeaway: Erasable with UV light = EPROM.**"
        },
        "vi": {
            "question": "_______ c√≥ th·ªÉ ƒë∆∞·ª£c ng∆∞·ªùi d√πng l·∫≠p tr√¨nh, nh∆∞ng c≈©ng c√≥ th·ªÉ ƒë∆∞·ª£c x√≥a b·∫±ng m·ªôt thi·∫øt b·ªã ƒë·∫∑c bi·ªát ph√°t ra tia c·ª±c t√≠m.",
            "options": [
                "A. ROM",
                "B. EEPROM",
                "C. PROM",
                "D. EPROM"
            ],
            "answer": "D. EPROM",
            "explanation": "B·ªô nh·ªõ ch·ªâ ƒë·ªçc c√≥ th·ªÉ l·∫≠p tr√¨nh v√† x√≥a ƒë∆∞·ª£c (EPROM) ƒë∆∞·ª£c x√≥a b·∫±ng c√°ch cho n√≥ ti·∫øp x√∫c v·ªõi √°nh s√°ng c·ª±c t√≠m (UV) m·∫°nh qua m·ªôt c·ª≠a s·ªï th·∫°ch anh tr√™n chip. N√≥ ph·∫£i ƒë∆∞·ª£c th√°o ra kh·ªèi m√°y t√≠nh ƒë·ªÉ x√≥a. **M·∫πo ghi nh·ªõ: X√≥a b·∫±ng tia UV = EPROM.**"
        }
    },
    {
        "id": 45,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "Which of the following is the user programmed semiconductor memory?",
            "options": [
                "A. SRAM",
                "B. DRAM",
                "C. EPROM",
                "D. All of the others"
            ],
            "answer": "C. EPROM",
            "explanation": "SRAM and DRAM are read/write memory. EPROM (and PROM, EEPROM) are types of memory that a user can program (write to) to store permanent code, differing from factory-programmed ROM. **Key takeaway: User-programmed non-volatile memory includes EPROM.**"
        },
        "vi": {
            "question": "Lo·∫°i n√†o sau ƒë√¢y l√† b·ªô nh·ªõ b√°n d·∫´n do ng∆∞·ªùi d√πng l·∫≠p tr√¨nh?",
            "options": [
                "A. SRAM",
                "B. DRAM",
                "C. EPROM",
                "D. T·∫•t c·∫£ c√°c ph∆∞∆°ng √°n kh√°c"
            ],
            "answer": "C. EPROM",
            "explanation": "SRAM v√† DRAM l√† b·ªô nh·ªõ ƒë·ªçc/ghi. EPROM (v√† PROM, EEPROM) l√† c√°c lo·∫°i b·ªô nh·ªõ m√† ng∆∞·ªùi d√πng c√≥ th·ªÉ l·∫≠p tr√¨nh (ghi v√†o) ƒë·ªÉ l∆∞u tr·ªØ m√£ vƒ©nh vi·ªÖn, kh√°c v·ªõi ROM ƒë∆∞·ª£c l·∫≠p tr√¨nh t·∫°i nh√† m√°y. **M·∫πo ghi nh·ªõ: B·ªô nh·ªõ b·∫•t bi·∫øn do ng∆∞·ªùi d√πng l·∫≠p tr√¨nh bao g·ªìm EPROM.**"
        }
    },
    {
        "id": 46,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "The difference between memory and storages is that memory is _______ and storage is _______.",
            "options": [
                "A. Temporary, permanent",
                "B. Permanent, temporary",
                "C. Slow, fast",
                "D. All of the others"
            ],
            "answer": "A. Temporary, permanent",
            "explanation": "'Memory' usually refers to main memory (RAM), which is volatile and temporary. 'Storage' refers to secondary storage devices (like SSDs, HDDs), which are non-volatile and provide permanent storage. **Key takeaway: Memory = RAM = Temporary. Storage = SSD/HDD = Permanent.**"
        },
        "vi": {
            "question": "S·ª± kh√°c bi·ªát gi·ªØa b·ªô nh·ªõ (memory) v√† b·ªô l∆∞u tr·ªØ (storage) l√† b·ªô nh·ªõ th√¨ _______ v√† b·ªô l∆∞u tr·ªØ th√¨ _______.",
            "options": [
                "A. T·∫°m th·ªùi, vƒ©nh vi·ªÖn",
                "B. Vƒ©nh vi·ªÖn, t·∫°m th·ªùi",
                "C. Ch·∫≠m, nhanh",
                "D. T·∫•t c·∫£ c√°c ph∆∞∆°ng √°n kh√°c"
            ],
            "answer": "A. T·∫°m th·ªùi, vƒ©nh vi·ªÖn",
            "explanation": "'Memory' th∆∞·ªùng ch·ªâ b·ªô nh·ªõ ch√≠nh (RAM), l√† b·ªô nh·ªõ kh·∫£ bi·∫øn v√† t·∫°m th·ªùi. 'Storage' ch·ªâ c√°c thi·∫øt b·ªã l∆∞u tr·ªØ th·ª© c·∫•p (nh∆∞ SSD, HDD), l√† b·ªô nh·ªõ b·∫•t bi·∫øn v√† cung c·∫•p l∆∞u tr·ªØ vƒ©nh vi·ªÖn. **M·∫πo ghi nh·ªõ: Memory = RAM = T·∫°m th·ªùi. Storage = SSD/HDD = Vƒ©nh vi·ªÖn.**"
        }
    },
    {
        "id": 47,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "RISC ( reduced instruction set computer). The strategy behind RISC architecture is to have a small set of instructions that do a minimum number of _______.",
            "options": [
                "A. Complex instructions",
                "B. Complex operations",
                "C. Simple operations",
                "D. Simple instructions"
            ],
            "answer": "C. Simple operations",
            "explanation": "RISC philosophy focuses on having a small set of simple, highly optimized instructions. Each instruction performs a very simple operation (like add, load, store) that can be executed in a single clock cycle. **Key takeaway: RISC = Small set of simple operations.**"
        },
        "vi": {
            "question": "RISC (m√°y t√≠nh c√≥ t·∫≠p l·ªánh r√∫t g·ªçn). Chi·∫øn l∆∞·ª£c ƒë·∫±ng sau ki·∫øn tr√∫c RISC l√† c√≥ m·ªôt t·∫≠p l·ªánh nh·ªè th·ª±c hi·ªán m·ªôt s·ªë l∆∞·ª£ng t·ªëi thi·ªÉu c√°c _______.",
            "options": [
                "A. L·ªánh ph·ª©c t·∫°p",
                "B. Ho·∫°t ƒë·ªông ph·ª©c t·∫°p",
                "C. Ho·∫°t ƒë·ªông ƒë∆°n gi·∫£n",
                "D. L·ªánh ƒë∆°n gi·∫£n"
            ],
            "answer": "C. Ho·∫°t ƒë·ªông ƒë∆°n gi·∫£n",
            "explanation": "Tri·∫øt l√Ω c·ªßa RISC t·∫≠p trung v√†o vi·ªác c√≥ m·ªôt t·∫≠p l·ªánh nh·ªè g·ªìm c√°c ch·ªâ th·ªã ƒë∆°n gi·∫£n, ƒë∆∞·ª£c t·ªëi ∆∞u h√≥a cao. M·ªói ch·ªâ th·ªã th·ª±c hi·ªán m·ªôt ho·∫°t ƒë·ªông r·∫•t ƒë∆°n gi·∫£n (nh∆∞ c·ªông, n·∫°p, l∆∞u) c√≥ th·ªÉ ƒë∆∞·ª£c th·ª±c thi trong m·ªôt chu k·ª≥ xung nh·ªãp duy nh·∫•t. **M·∫πo ghi nh·ªõ: RISC = T·∫≠p h·ª£p nh·ªè c√°c ho·∫°t ƒë·ªông ƒë∆°n gi·∫£n.**"
        }
    },
    {
        "id": 48,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "All the instructions and procedures needed to start up a computer, to the point it can load an operating system, are stored in ROM chips. In IBM compatible PCs this is called the _______.",
            "options": [
                "A. RAM BIOS",
                "B. ROM BIOS",
                "C. EPROM",
                "D. POST"
            ],
            "answer": "B. ROM BIOS",
            "explanation": "The BIOS (Basic Input/Output System) is firmware stored on a ROM chip on the motherboard. It performs the initial hardware checks (POST - Power-On Self-Test) and loads the operating system. **Key takeaway: Startup instructions = ROM BIOS.**"
        },
        "vi": {
            "question": "T·∫•t c·∫£ c√°c ch·ªâ th·ªã v√† th·ªß t·ª•c c·∫ßn thi·∫øt ƒë·ªÉ kh·ªüi ƒë·ªông m·ªôt m√°y t√≠nh, ƒë·∫øn m·ª©c n√≥ c√≥ th·ªÉ n·∫°p m·ªôt h·ªá ƒëi·ªÅu h√†nh, ƒë∆∞·ª£c l∆∞u tr·ªØ trong chip ROM. Trong c√°c m√°y t√≠nh t∆∞∆°ng th√≠ch IBM, ƒëi·ªÅu n√†y ƒë∆∞·ª£c g·ªçi l√† _______.",
            "options": [
                "A. RAM BIOS",
                "B. ROM BIOS",
                "C. EPROM",
                "D. POST"
            ],
            "answer": "B. ROM BIOS",
            "explanation": "BIOS (H·ªá th·ªëng Nh·∫≠p/Xu·∫•t C∆° b·∫£n) l√† firmware ƒë∆∞·ª£c l∆∞u tr·ªØ tr√™n m·ªôt chip ROM tr√™n bo m·∫°ch ch·ªß. N√≥ th·ª±c hi·ªán c√°c ki·ªÉm tra ph·∫ßn c·ª©ng ban ƒë·∫ßu (POST - T·ª± ki·ªÉm tra khi b·∫≠t ngu·ªìn) v√† n·∫°p h·ªá ƒëi·ªÅu h√†nh. **M·∫πo ghi nh·ªõ: Ch·ªâ th·ªã kh·ªüi ƒë·ªông = ROM BIOS.**"
        }
    },
    {
        "id": 49,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "A billionth of a second is defined as a:",
            "options": [
                "A. Millisecond",
                "B. Microsecond",
                "C. Nanosecond",
                "D. Picoseconds"
            ],
            "answer": "C. Nanosecond",
            "explanation": "The metric prefixes for time are: millisecond (10^-3), microsecond (10^-6), nanosecond (10^-9, a billionth), and picosecond (10^-12). **Key takeaway: Billionth = Nano.**"
        },
        "vi": {
            "question": "M·ªôt ph·∫ßn t·ª∑ c·ªßa m·ªôt gi√¢y ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a l√† m·ªôt:",
            "options": [
                "A. Mili gi√¢y",
                "B. Micro gi√¢y",
                "C. Nano gi√¢y",
                "D. Pico gi√¢y"
            ],
            "answer": "C. Nano gi√¢y",
            "explanation": "C√°c ti·ªÅn t·ªë ƒëo l∆∞·ªùng cho th·ªùi gian l√†: mili gi√¢y (10^-3), micro gi√¢y (10^-6), nano gi√¢y (10^-9, m·ªôt ph·∫ßn t·ª∑), v√† pico gi√¢y (10^-12). **M·∫πo ghi nh·ªõ: Ph·∫ßn t·ª∑ = Nano.**"
        }
    },
    {
        "id": 50,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "The result of the decode step is the _______ for some operation that the system will perform.",
            "options": [
                "A. Output",
                "B. Data processing",
                "C. Binary code",
                "D. Code"
            ],
            "answer": "C. Binary code",
            "explanation": "In the instruction cycle, the 'decode' step involves the control unit interpreting the binary code (the opcode) of the fetched instruction to determine what operation needs to be performed. **Key takeaway: Decode step interprets binary code.**"
        },
        "vi": {
            "question": "K·∫øt qu·∫£ c·ªßa b∆∞·ªõc gi·∫£i m√£ l√† _______ cho m·ªôt s·ªë ho·∫°t ƒë·ªông m√† h·ªá th·ªëng s·∫Ω th·ª±c hi·ªán.",
            "options": [
                "A. ƒê·∫ßu ra",
                "B. X·ª≠ l√Ω d·ªØ li·ªáu",
                "C. M√£ nh·ªã ph√¢n",
                "D. M√£"
            ],
            "answer": "C. M√£ nh·ªã ph√¢n",
            "explanation": "Trong chu k·ª≥ l·ªánh, b∆∞·ªõc 'gi·∫£i m√£' li√™n quan ƒë·∫øn vi·ªác ƒë∆°n v·ªã ƒëi·ªÅu khi·ªÉn di·ªÖn gi·∫£i m√£ nh·ªã ph√¢n (opcode) c·ªßa l·ªánh ƒë√£ ƒë∆∞·ª£c n·∫°p ƒë·ªÉ x√°c ƒë·ªãnh ho·∫°t ƒë·ªông n√†o c·∫ßn ƒë∆∞·ª£c th·ª±c hi·ªán. **M·∫πo ghi nh·ªõ: B∆∞·ªõc gi·∫£i m√£ di·ªÖn gi·∫£i m√£ nh·ªã ph√¢n.**"
        }
    },
    {
        "id": 51,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "A path by which communication is achieved between a central processor and other devices is called _______.",
            "options": [
                "A. Audit trail",
                "B. Network",
                "C. Bus",
                "D. Channel"
            ],
            "answer": "C. Bus",
            "explanation": "A bus is a shared communication pathway that connects the major components of a computer system, such as the CPU, memory, and I/O modules. **Key takeaway: Communication path inside computer = Bus.**"
        },
        "vi": {
            "question": "M·ªôt ƒë∆∞·ªùng d·∫´n m√† qua ƒë√≥ vi·ªác giao ti·∫øp ƒë∆∞·ª£c th·ª±c hi·ªán gi·ªØa m·ªôt b·ªô x·ª≠ l√Ω trung t√¢m v√† c√°c thi·∫øt b·ªã kh√°c ƒë∆∞·ª£c g·ªçi l√† _______.",
            "options": [
                "A. D·∫•u v·∫øt ki·ªÉm to√°n",
                "B. M·∫°ng",
                "C. Bus",
                "D. K√™nh"
            ],
            "answer": "C. Bus",
            "explanation": "Bus l√† m·ªôt ƒë∆∞·ªùng truy·ªÅn th√¥ng ƒë∆∞·ª£c chia s·∫ª k·∫øt n·ªëi c√°c th√†nh ph·∫ßn ch√≠nh c·ªßa m·ªôt h·ªá th·ªëng m√°y t√≠nh, ch·∫≥ng h·∫°n nh∆∞ CPU, b·ªô nh·ªõ v√† c√°c m√¥-ƒëun I/O. **M·∫πo ghi nh·ªõ: ƒê∆∞·ªùng d·∫´n giao ti·∫øp b√™n trong m√°y t√≠nh = Bus.**"
        }
    },
    {
        "id": 52,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "In the fetch phase, the control unit orders the system to copy the next instruction into the _______ in the CPU.",
            "options": [
                "A. Program counter",
                "B. Instruction register",
                "C. Memory",
                "D. Register"
            ],
            "answer": "B. Instruction register",
            "explanation": "During the fetch phase, the instruction located at the address held by the Program Counter (PC) is copied from memory into the Instruction Register (IR) for decoding. **Key takeaway: Fetched instruction goes into the IR.**"
        },
        "vi": {
            "question": "Trong giai ƒëo·∫°n n·∫°p l·ªánh, ƒë∆°n v·ªã ƒëi·ªÅu khi·ªÉn ra l·ªánh cho h·ªá th·ªëng sao ch√©p l·ªánh ti·∫øp theo v√†o _______ trong CPU.",
            "options": [
                "A. B·ªô ƒë·∫øm ch∆∞∆°ng tr√¨nh",
                "B. Thanh ghi ch·ªâ th·ªã",
                "C. B·ªô nh·ªõ",
                "D. Thanh ghi"
            ],
            "answer": "B. Thanh ghi ch·ªâ th·ªã",
            "explanation": "Trong giai ƒëo·∫°n n·∫°p l·ªánh, l·ªánh n·∫±m t·∫°i ƒë·ªãa ch·ªâ ƒë∆∞·ª£c gi·ªØ b·ªüi B·ªô ƒë·∫øm Ch∆∞∆°ng tr√¨nh (PC) ƒë∆∞·ª£c sao ch√©p t·ª´ b·ªô nh·ªõ v√†o Thanh ghi Ch·ªâ th·ªã (IR) ƒë·ªÉ gi·∫£i m√£. **M·∫πo ghi nh·ªõ: L·ªánh ƒë∆∞·ª£c n·∫°p v√†o IR.**"
        }
    },
    {
        "id": 53,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "In the Turing model, the _______ depends on the combination of two factors: the input data and the program.",
            "options": [
                "A. Output data",
                "B. Instructions",
                "C. Algorithm",
                "D. Data processing"
            ],
            "answer": "A. Output data",
            "explanation": "A Turing machine (and any computer) is a data processor. The final result (output) is determined entirely by the initial state (input data) and the set of rules it follows (the program). **Key takeaway: Output = f(Input, Program).**"
        },
        "vi": {
            "question": "Trong m√¥ h√¨nh Turing, _______ ph·ª• thu·ªôc v√†o s·ª± k·∫øt h·ª£p c·ªßa hai y·∫øu t·ªë: d·ªØ li·ªáu ƒë·∫ßu v√†o v√† ch∆∞∆°ng tr√¨nh.",
            "options": [
                "A. D·ªØ li·ªáu ƒë·∫ßu ra",
                "B. C√°c ch·ªâ th·ªã",
                "C. Thu·∫≠t to√°n",
                "D. X·ª≠ l√Ω d·ªØ li·ªáu"
            ],
            "answer": "A. D·ªØ li·ªáu ƒë·∫ßu ra",
            "explanation": "M·ªôt m√°y Turing (v√† b·∫•t k·ª≥ m√°y t√≠nh n√†o) l√† m·ªôt b·ªô x·ª≠ l√Ω d·ªØ li·ªáu. K·∫øt qu·∫£ cu·ªëi c√πng (ƒë·∫ßu ra) ƒë∆∞·ª£c x√°c ƒë·ªãnh ho√†n to√†n b·ªüi tr·∫°ng th√°i ban ƒë·∫ßu (d·ªØ li·ªáu ƒë·∫ßu v√†o) v√† t·∫≠p h·ª£p c√°c quy t·∫Øc m√† n√≥ tu√¢n theo (ch∆∞∆°ng tr√¨nh). **M·∫πo ghi nh·ªõ: ƒê·∫ßu ra = f(ƒê·∫ßu v√†o, Ch∆∞∆°ng tr√¨nh).**"
        }
    },
    {
        "id": 54,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "Off-line operation is the operation of devices without the control of _______.",
            "options": [
                "A. Memory",
                "B. CPU",
                "C. ALU",
                "D. Control unit"
            ],
            "answer": "B. CPU",
            "explanation": "Off-line operation refers to tasks performed by peripheral devices independently of the central processing unit. For example, a printer printing a multi-page document from its own buffer. **Key takeaway: Off-line = Without CPU control.**"
        },
        "vi": {
            "question": "Ho·∫°t ƒë·ªông ngo·∫°i tuy·∫øn (off-line) l√† ho·∫°t ƒë·ªông c·ªßa c√°c thi·∫øt b·ªã m√† kh√¥ng c√≥ s·ª± ki·ªÉm so√°t c·ªßa _______.",
            "options": [
                "A. B·ªô nh·ªõ",
                "B. CPU",
                "C. ALU",
                "D. ƒê∆°n v·ªã ƒëi·ªÅu khi·ªÉn"
            ],
            "answer": "B. CPU",
            "explanation": "Ho·∫°t ƒë·ªông ngo·∫°i tuy·∫øn ch·ªâ c√°c t√°c v·ª• ƒë∆∞·ª£c th·ª±c hi·ªán b·ªüi c√°c thi·∫øt b·ªã ngo·∫°i vi ƒë·ªôc l·∫≠p v·ªõi ƒë∆°n v·ªã x·ª≠ l√Ω trung t√¢m. V√≠ d·ª•, m·ªôt m√°y in ƒëang in m·ªôt t√†i li·ªáu nhi·ªÅu trang t·ª´ b·ªô ƒë·ªám c·ªßa ch√≠nh n√≥. **M·∫πo ghi nh·ªõ: Ngo·∫°i tuy·∫øn = Kh√¥ng c√≥ s·ª± ki·ªÉm so√°t c·ªßa CPU.**"
        }
    },
    {
        "id": 55,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "Which printer uses a combination of laser-beam & electro photographic techniques?",
            "options": [
                "A. Laser printers",
                "B. Dot-Matrix",
                "C. Line printer",
                "D. Daisy wheel"
            ],
            "answer": "A. Laser printers",
            "explanation": "This is the definition of how a laser printer works. It uses a laser to create a static electricity image on a drum, which then attracts toner and transfers it to paper. **Key takeaway: Laser + Electrophotography = Laser printer.**"
        },
        "vi": {
            "question": "M√°y in n√†o s·ª≠ d·ª•ng s·ª± k·∫øt h·ª£p c·ªßa tia laser v√† k·ªπ thu·∫≠t ch·ª•p ·∫£nh tƒ©nh ƒëi·ªán?",
            "options": [
                "A. M√°y in laser",
                "B. M√°y in kim",
                "C. M√°y in d√≤ng",
                "D. M√°y in ch·ªØ"
            ],
            "answer": "A. M√°y in laser",
            "explanation": "ƒê√¢y l√† ƒë·ªãnh nghƒ©a v·ªÅ c√°ch ho·∫°t ƒë·ªông c·ªßa m·ªôt m√°y in laser. N√≥ s·ª≠ d·ª•ng tia laser ƒë·ªÉ t·∫°o ra m·ªôt h√¨nh ·∫£nh tƒ©nh ƒëi·ªán tr√™n m·ªôt tr·ªëng m·ª±c, sau ƒë√≥ h√∫t m·ª±c b·ªôt v√† chuy·ªÉn n√≥ l√™n gi·∫•y. **M·∫πo ghi nh·ªõ: Laser + Ch·ª•p ·∫£nh tƒ©nh ƒëi·ªán = M√°y in laser.**"
        }
    },
    {
        "id": 56,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "What is the name of the display feature that highlights areas of the screen which require operator attention?",
            "options": [
                "A. Pixel",
                "B. Reverse video",
                "C. Touch screen",
                "D. Cursor"
            ],
            "answer": "B. Reverse video",
            "explanation": "Reverse video (or inverse video) swaps the foreground and background colors (e.g., black text on a white background becomes white text on a black background) to make a specific area stand out. **Key takeaway: Highlighting text by swapping colors = Reverse video.**"
        },
        "vi": {
            "question": "T√™n c·ªßa t√≠nh nƒÉng hi·ªÉn th·ªã l√†m n·ªïi b·∫≠t c√°c v√πng c·ªßa m√†n h√¨nh ƒë√≤i h·ªèi s·ª± ch√∫ √Ω c·ªßa ng∆∞·ªùi v·∫≠n h√†nh l√† g√¨?",
            "options": [
                "A. Pixel",
                "B. Video ƒë·∫£o ng∆∞·ª£c",
                "C. M√†n h√¨nh c·∫£m ·ª©ng",
                "D. Con tr·ªè"
            ],
            "answer": "B. Video ƒë·∫£o ng∆∞·ª£c",
            "explanation": "Video ƒë·∫£o ng∆∞·ª£c (ho·∫∑c video ngh·ªãch ƒë·∫£o) ho√°n ƒë·ªïi m√†u n·ªÅn tr∆∞·ªõc v√† m√†u n·ªÅn sau (v√≠ d·ª•: vƒÉn b·∫£n ƒëen tr√™n n·ªÅn tr·∫Øng tr·ªü th√†nh vƒÉn b·∫£n tr·∫Øng tr√™n n·ªÅn ƒëen) ƒë·ªÉ l√†m cho m·ªôt khu v·ª±c c·ª• th·ªÉ n·ªïi b·∫≠t. **M·∫πo ghi nh·ªõ: L√†m n·ªïi b·∫≠t vƒÉn b·∫£n b·∫±ng c√°ch ho√°n ƒë·ªïi m√†u = Video ƒë·∫£o ng∆∞·ª£c.**"
        }
    },
    {
        "id": 57,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "Codes consisting of light and dark marks which may be optically read is known as",
            "options": [
                "A. Memonics",
                "B. Bar code",
                "C. Decoder",
                "D. All of the others"
            ],
            "answer": "B. Bar code",
            "explanation": "A bar code is a machine-readable representation of data, consisting of parallel lines (bars) and spaces of varying widths that can be read by an optical scanner. **Key takeaway: Light/Dark optical marks = Bar code.**"
        },
        "vi": {
            "question": "C√°c m√£ bao g·ªìm c√°c v·∫°ch s√°ng v√† t·ªëi c√≥ th·ªÉ ƒë∆∞·ª£c ƒë·ªçc b·∫±ng quang h·ªçc ƒë∆∞·ª£c g·ªçi l√†",
            "options": [
                "A. G·ª£i nh·ªõ",
                "B. M√£ v·∫°ch",
                "C. B·ªô gi·∫£i m√£",
                "D. T·∫•t c·∫£ c√°c ph∆∞∆°ng √°n kh√°c"
            ],
            "answer": "B. M√£ v·∫°ch",
            "explanation": "M√£ v·∫°ch l√† m·ªôt d·∫°ng bi·ªÉu di·ªÖn d·ªØ li·ªáu c√≥ th·ªÉ ƒë·ªçc ƒë∆∞·ª£c b·∫±ng m√°y, bao g·ªìm c√°c ƒë∆∞·ªùng th·∫≥ng song song (v·∫°ch) v√† c√°c kho·∫£ng tr·ªëng c√≥ ƒë·ªô r·ªông kh√°c nhau c√≥ th·ªÉ ƒë∆∞·ª£c ƒë·ªçc b·ªüi m·ªôt m√°y qu√©t quang h·ªçc. **M·∫πo ghi nh·ªõ: V·∫°ch s√°ng/t·ªëi quang h·ªçc = M√£ v·∫°ch.**"
        }
    },
    {
        "id": 58,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "What is taxonomy of computer organization?",
            "options": [
                "A. SIMD - Single Instruction-stream, Multiple Data-stream",
                "B. MISO - Multiple Instruction-stream, Single Data-stream",
                "C. MIMD - Multiple Instruction-stream, Multiple Data-stream",
                "D. All of others"
            ],
            "answer": "D. All of others",
            "explanation": "Flynn's taxonomy classifies computer architectures into four main types: SISD (Single Instruction, Single Data), SIMD, MISD, and MIMD. All the correct expansions are part of this taxonomy. **Key takeaway: Flynn's Taxonomy includes SISD, SIMD, MISD, MIMD.**"
        },
        "vi": {
            "question": "Ph√¢n lo·∫°i t·ªï ch·ª©c m√°y t√≠nh l√† g√¨?",
            "options": [
                "A. SIMD - D√≤ng l·ªánh ƒë∆°n, D√≤ng d·ªØ li·ªáu ƒëa",
                "B. MISO - D√≤ng l·ªánh ƒëa, D√≤ng d·ªØ li·ªáu ƒë∆°n",
                "C. MIMD - D√≤ng l·ªánh ƒëa, D√≤ng d·ªØ li·ªáu ƒëa",
                "D. T·∫•t c·∫£ c√°c ph∆∞∆°ng √°n kh√°c"
            ],
            "answer": "D. T·∫•t c·∫£ c√°c ph∆∞∆°ng √°n kh√°c",
            "explanation": "Ph√¢n lo·∫°i c·ªßa Flynn chia ki·∫øn tr√∫c m√°y t√≠nh th√†nh b·ªën lo·∫°i ch√≠nh: SISD (L·ªánh ƒë∆°n, D·ªØ li·ªáu ƒë∆°n), SIMD, MISD, v√† MIMD. T·∫•t c·∫£ c√°c di·ªÖn gi·∫£i ƒë√∫ng ƒë·ªÅu l√† m·ªôt ph·∫ßn c·ªßa ph√¢n lo·∫°i n√†y. **M·∫πo ghi nh·ªõ: Ph√¢n lo·∫°i c·ªßa Flynn bao g·ªìm SISD, SIMD, MISD, MIMD.**"
        }
    },
    {
        "id": 59,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "How many connections (in the data bus) do we need to transfer 4 bytes of a word at the same time?",
            "options": [
                "A. 4",
                "B. 8",
                "C. 16",
                "D. 32"
            ],
            "answer": "D. 32",
            "explanation": "Each byte consists of 8 bits. To transfer 4 bytes simultaneously, you need a separate connection (wire) for each bit. Therefore, you need 4 bytes * 8 bits/byte = 32 connections. **Key takeaway: Data bus width = bytes * 8.**"
        },
        "vi": {
            "question": "Ch√∫ng ta c·∫ßn bao nhi√™u k·∫øt n·ªëi (trong bus d·ªØ li·ªáu) ƒë·ªÉ truy·ªÅn 4 byte c·ªßa m·ªôt t·ª´ c√πng m·ªôt l√∫c?",
            "options": [
                "A. 4",
                "B. 8",
                "C. 16",
                "D. 32"
            ],
            "answer": "D. 32",
            "explanation": "M·ªói byte bao g·ªìm 8 bit. ƒê·ªÉ truy·ªÅn 4 byte ƒë·ªìng th·ªùi, b·∫°n c·∫ßn m·ªôt k·∫øt n·ªëi (d√¢y) ri√™ng cho m·ªói bit. Do ƒë√≥, b·∫°n c·∫ßn 4 byte * 8 bit/byte = 32 k·∫øt n·ªëi. **M·∫πo ghi nh·ªõ: ƒê·ªô r·ªông bus d·ªØ li·ªáu = s·ªë byte * 8.**"
        }
    },
    {
        "id": 60,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "A computer has 32 MB (megabytes) of memory. How many bits are needed to address any single byte in memory?",
            "options": [
                "A. 5 bits",
                "B. 20 bits",
                "C. 25 bits",
                "D. 32 bits"
            ],
            "answer": "C. 25 bits",
            "explanation": "First, convert memory size to bytes: 32 MB = 32 * 2^20 bytes = 2^5 * 2^20 = 2^25 bytes. The number of bits needed to address N unique locations is log2(N). So, we need log2(2^25) = 25 bits. **Key takeaway: Address bits = log2(number of bytes).**"
        },
        "vi": {
            "question": "M·ªôt m√°y t√≠nh c√≥ b·ªô nh·ªõ 32 MB (megabyte). C·∫ßn bao nhi√™u bit ƒë·ªÉ ƒë·ªãnh ƒë·ªãa ch·ªâ cho b·∫•t k·ª≥ byte ƒë∆°n l·∫ª n√†o trong b·ªô nh·ªõ?",
            "options": [
                "A. 5 bit",
                "B. 20 bit",
                "C. 25 bit",
                "D. 32 bit"
            ],
            "answer": "C. 25 bit",
            "explanation": "ƒê·∫ßu ti√™n, chuy·ªÉn ƒë·ªïi k√≠ch th∆∞·ªõc b·ªô nh·ªõ sang byte: 32 MB = 32 * 2^20 byte = 2^5 * 2^20 = 2^25 byte. S·ªë bit c·∫ßn thi·∫øt ƒë·ªÉ ƒë·ªãnh ƒë·ªãa ch·ªâ N v·ªã tr√≠ duy nh·∫•t l√† log2(N). V√¨ v·∫≠y, ch√∫ng ta c·∫ßn log2(2^25) = 25 bit. **M·∫πo ghi nh·ªõ: S·ªë bit ƒë·ªãa ch·ªâ = log2(s·ªë byte).**"
        }
    },
    {
        "id": 61,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "A _______ is a storage device that can undergo multiple writes and erasures.",
            "options": [
                "A. CD-ROM",
                "B. CD-R",
                "C. CD-RW",
                "D. CD-RR"
            ],
            "answer": "C. CD-RW",
            "explanation": "CD-RW stands for Compact Disc-ReWritable. It uses a phase-change metallic alloy that allows data to be erased and rewritten many times. CD-ROM is read-only, and CD-R is recordable once. **Key takeaway: RW = ReWritable.**"
        },
        "vi": {
            "question": "_______ l√† m·ªôt thi·∫øt b·ªã l∆∞u tr·ªØ c√≥ th·ªÉ tr·∫£i qua nhi·ªÅu l·∫ßn ghi v√† x√≥a.",
            "options": [
                "A. CD-ROM",
                "B. CD-R",
                "C. CD-RW",
                "D. CD-RR"
            ],
            "answer": "C. CD-RW",
            "explanation": "CD-RW l√† vi·∫øt t·∫Øt c·ªßa Compact Disc-ReWritable (ƒêƒ©a compact c√≥ th·ªÉ ghi l·∫°i). N√≥ s·ª≠ d·ª•ng m·ªôt h·ª£p kim kim lo·∫°i thay ƒë·ªïi pha cho ph√©p d·ªØ li·ªáu ƒë∆∞·ª£c x√≥a v√† ghi l·∫°i nhi·ªÅu l·∫ßn. CD-ROM l√† ch·ªâ ƒë·ªçc, v√† CD-R l√† c√≥ th·ªÉ ghi m·ªôt l·∫ßn. **M·∫πo ghi nh·ªõ: RW = ReWritable (C√≥ th·ªÉ ghi l·∫°i).**"
        }
    },
    {
        "id": 62,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "If the memory address space is 16 MB and the word size is 8 bits, then _______ bits are needed to access each word.",
            "options": [
                "A. 8",
                "B. 16",
                "C. 24",
                "D. 32"
            ],
            "answer": "C. 24",
            "explanation": "If the word size is 8 bits (1 byte), then accessing each word is the same as byte-addressing. 16 MB = 16 * 2^20 bytes = 2^4 * 2^20 = 2^24 bytes. To address 2^24 unique locations, you need 24 bits. **Key takeaway: Address bits = log2(number of addressable units).**"
        },
        "vi": {
            "question": "N·∫øu kh√¥ng gian ƒë·ªãa ch·ªâ b·ªô nh·ªõ l√† 16 MB v√† k√≠ch th∆∞·ªõc t·ª´ l√† 8 bit, th√¨ c·∫ßn _______ bit ƒë·ªÉ truy c·∫≠p m·ªói t·ª´.",
            "options": [
                "A. 8",
                "B. 16",
                "C. 24",
                "D. 32"
            ],
            "answer": "C. 24",
            "explanation": "N·∫øu k√≠ch th∆∞·ªõc t·ª´ l√† 8 bit (1 byte), th√¨ vi·ªác truy c·∫≠p m·ªói t·ª´ c≈©ng gi·ªëng nh∆∞ ƒë·ªãnh ƒë·ªãa ch·ªâ theo byte. 16 MB = 16 * 2^20 byte = 2^4 * 2^20 = 2^24 byte. ƒê·ªÉ ƒë·ªãnh ƒë·ªãa ch·ªâ 2^24 v·ªã tr√≠ duy nh·∫•t, b·∫°n c·∫ßn 24 bit. **M·∫πo ghi nh·ªõ: S·ªë bit ƒë·ªãa ch·ªâ = log2(s·ªë ƒë∆°n v·ªã c√≥ th·ªÉ ƒë·ªãnh ƒë·ªãa ch·ªâ).**"
        }
    },
    {
        "id": 63,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "What is the 80-20 rule in cache?",
            "options": [
                "A. Most computers typically spend 80 percent of their time accessing only 20 percent of the data",
                "B. Cache memory at any time contains a copy of a portion of main memory.",
                "C. It can hold data 20 percent to make access faster at least 80 percent of the time.",
                "D. The CPU to needs to checks the cache first."
            ],
            "answer": "A. Most computers typically spend 80 percent of their time accessing only 20 percent of the data",
            "explanation": "This is an application of the Pareto principle, also known as the principle of locality. It states that a program's access to memory is not random; it tends to concentrate on a small set of data and instructions (the 20%) for a significant period (the 80%). Caches are effective because they store this small, active set. **Key takeaway: 80-20 rule = Principle of Locality.**"
        },
        "vi": {
            "question": "Quy t·∫Øc 80-20 trong b·ªô nh·ªõ ƒë·ªám (cache) l√† g√¨?",
            "options": [
                "A. H·∫ßu h·∫øt c√°c m√°y t√≠nh th∆∞·ªùng d√†nh 80% th·ªùi gian ƒë·ªÉ truy c·∫≠p ch·ªâ 20% d·ªØ li·ªáu",
                "B. B·ªô nh·ªõ ƒë·ªám t·∫°i b·∫•t k·ª≥ th·ªùi ƒëi·ªÉm n√†o c≈©ng ch·ª©a m·ªôt b·∫£n sao c·ªßa m·ªôt ph·∫ßn b·ªô nh·ªõ ch√≠nh.",
                "C. N√≥ c√≥ th·ªÉ gi·ªØ 20% d·ªØ li·ªáu ƒë·ªÉ truy c·∫≠p nhanh h∆°n √≠t nh·∫•t 80% th·ªùi gian.",
                "D. CPU c·∫ßn ki·ªÉm tra b·ªô nh·ªõ ƒë·ªám tr∆∞·ªõc."
            ],
            "answer": "A. H·∫ßu h·∫øt c√°c m√°y t√≠nh th∆∞·ªùng d√†nh 80% th·ªùi gian ƒë·ªÉ truy c·∫≠p ch·ªâ 20% d·ªØ li·ªáu",
            "explanation": "ƒê√¢y l√† m·ªôt ·ª©ng d·ª•ng c·ªßa nguy√™n l√Ω Pareto, c√≤n ƒë∆∞·ª£c g·ªçi l√† nguy√™n t·∫Øc ƒë·ªãa ph∆∞∆°ng (principle of locality). N√≥ n√≥i r·∫±ng vi·ªác truy c·∫≠p b·ªô nh·ªõ c·ªßa m·ªôt ch∆∞∆°ng tr√¨nh kh√¥ng ph·∫£i l√† ng·∫´u nhi√™n; n√≥ c√≥ xu h∆∞·ªõng t·∫≠p trung v√†o m·ªôt t·∫≠p h·ª£p nh·ªè d·ªØ li·ªáu v√† ch·ªâ th·ªã (20%) trong m·ªôt kho·∫£ng th·ªùi gian ƒë√°ng k·ªÉ (80%). B·ªô nh·ªõ ƒë·ªám hi·ªáu qu·∫£ v√¨ ch√∫ng l∆∞u tr·ªØ t·∫≠p h·ª£p nh·ªè, ho·∫°t ƒë·ªông n√†y. **M·∫πo ghi nh·ªõ: Quy t·∫Øc 80-20 = Nguy√™n t·∫Øc ƒë·ªãa ph∆∞∆°ng.**"
        }
    },
    {
        "id": 64,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "According to the Turing model, what is a 'Universal Turing Machine' capable of?",
            "options": [
                "A. Performing only basic arithmetic operations.",
                "B. Performing any computation if provided with the appropriate program.",
                "C. Storing only the program without storing data.",
                "D. Operating faster than any modern computer."
            ],
            "answer": "B. Performing any computation if provided with the appropriate program.",
            "explanation": "A Universal Turing Machine is a theoretical machine that can simulate any other Turing machine. This means it can perform any computable task if given the correct program, forming the theoretical basis for modern general-purpose computers. **Key takeaway: Universal Turing Machine = can be programmed to do anything.**"
        },
        "vi": {
            "question": "Theo m√¥ h√¨nh Turing, m·ªôt 'Universal Turing Machine' c√≥ kh·∫£ nƒÉng g√¨?",
            "options": [
                "A. Ch·ªâ th·ª±c hi·ªán c√°c ph√©p to√°n s·ªë h·ªçc c∆° b·∫£n.",
                "B. Th·ª±c hi·ªán b·∫•t k·ª≥ ph√©p t√≠nh to√°n n√†o n·∫øu ƒë∆∞·ª£c cung c·∫•p ch∆∞∆°ng tr√¨nh ph√π h·ª£p.",
                "C. Ch·ªâ l∆∞u tr·ªØ ch∆∞∆°ng tr√¨nh m√† kh√¥ng l∆∞u tr·ªØ d·ªØ li·ªáu.",
                "D. Ho·∫°t ƒë·ªông nhanh h∆°n b·∫•t k·ª≥ m√°y t√≠nh hi·ªán ƒë·∫°i n√†o."
            ],
            "answer": "B. Th·ª±c hi·ªán b·∫•t k·ª≥ ph√©p t√≠nh to√°n n√†o n·∫øu ƒë∆∞·ª£c cung c·∫•p ch∆∞∆°ng tr√¨nh ph√π h·ª£p.",
            "explanation": "T√†i li·ªáu (M·ª•c 1.4) m√¥ t·∫£ Universal Turing Machine l√† m·ªôt c·ªó m√°y c√≥ th·ªÉ th·ª±c hi·ªán m·ªçi ph√©p t√≠nh n·∫øu c√≥ ch∆∞∆°ng tr√¨nh ƒë√∫ng, ƒë√¢y l√† n·ªÅn t·∫£ng l√Ω thuy·∫øt cho m√°y t√≠nh ƒëa nƒÉng hi·ªán ƒë·∫°i. **M·∫πo ghi nh·ªõ: Universal Turing Machine = c√≥ th·ªÉ l·∫≠p tr√¨nh ƒë·ªÉ l√†m m·ªçi vi·ªác.**"
        }
    },
    {
        "id": 65,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "What was the prominent technological feature of the second generation of computers (1959‚Äì1965)?",
            "options": [
                "A. The use of vacuum tubes.",
                "B. The introduction of integrated circuits (ICs).",
                "C. The use of transistors.",
                "D. Being based on artificial intelligence (AI)."
            ],
            "answer": "C. The use of transistors.",
            "explanation": "The second generation was defined by the switch from vacuum tubes to transistors, which made computers smaller, cheaper, faster, and more reliable. **Key takeaway: 2nd Gen = Transistors.**"
        },
        "vi": {
            "question": "ƒê·∫∑c ƒëi·ªÉm c√¥ng ngh·ªá n·ªïi b·∫≠t c·ªßa th·∫ø h·ªá m√°y t√≠nh th·ª© hai (Second Generation, 1959‚Äì1965) l√† g√¨?",
            "options": [
                "A. S·ª≠ d·ª•ng b√≥ng ƒë√®n ch√¢n kh√¥ng (vacuum tubes).",
                "B. Gi·ªõi thi·ªáu vi m·∫°ch t√≠ch h·ª£p (integrated circuits - ICs).",
                "C. S·ª≠ d·ª•ng b√≥ng b√°n d·∫´n (transistors).",
                "D. D·ª±a tr√™n tr√≠ tu·ªá nh√¢n t·∫°o (AI)."
            ],
            "answer": "C. S·ª≠ d·ª•ng b√≥ng b√°n d·∫´n (transistors).",
            "explanation": "T√†i li·ªáu (M·ª•c 3.2) ghi r√µ th·∫ø h·ªá th·ª© hai 'Used transistors instead of vacuum tubes', gi√∫p m√°y t√≠nh nh·ªè h∆°n, r·∫ª h∆°n v√† ƒë√°ng tin c·∫≠y h∆°n. **M·∫πo ghi nh·ªõ: Th·∫ø h·ªá 2 = Transistor.**"
        }
    },
    {
        "id": 66,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "What is the main difference between DRAM and SRAM memory?",
            "options": [
                "A. DRAM is faster but needs constant refreshing, while SRAM does not.",
                "B. SRAM is faster and does not need refreshing, while DRAM is slower and needs refreshing.",
                "C. DRAM is non-volatile memory, while SRAM is volatile.",
                "D. Both have the same speed, but SRAM is cheaper."
            ],
            "answer": "B. SRAM is faster and does not need refreshing, while DRAM is slower and needs refreshing.",
            "explanation": "Static RAM (SRAM) uses flip-flops, making it faster and not requiring a refresh. Dynamic RAM (DRAM) uses capacitors that must be constantly refreshed, making it slower but denser and less expensive. **Key takeaway: S (Static) = Faster, no refresh. D (Dynamic) = Slower, needs refresh.**"
        },
        "vi": {
            "question": "S·ª± kh√°c bi·ªát ch√≠nh gi·ªØa b·ªô nh·ªõ DRAM v√† SRAM l√† g√¨?",
            "options": [
                "A. DRAM nhanh h∆°n nh∆∞ng c·∫ßn ƒë∆∞·ª£c l√†m t∆∞∆°i li√™n t·ª•c, c√≤n SRAM th√¨ kh√¥ng.",
                "B. SRAM nhanh h∆°n v√† kh√¥ng c·∫ßn l√†m t∆∞∆°i, trong khi DRAM ch·∫≠m h∆°n v√† c·∫ßn l√†m t∆∞∆°i.",
                "C. DRAM l√† b·ªô nh·ªõ b·∫•t bi·∫øn (non-volatile), c√≤n SRAM l√† kh·∫£ bi·∫øn (volatile).",
                "D. C·∫£ hai ƒë·ªÅu c√≥ t·ªëc ƒë·ªô nh∆∞ nhau nh∆∞ng SRAM r·∫ª h∆°n."
            ],
            "answer": "B. SRAM nhanh h∆°n v√† kh√¥ng c·∫ßn l√†m t∆∞∆°i, trong khi DRAM ch·∫≠m h∆°n v√† c·∫ßn l√†m t∆∞∆°i.",
            "explanation": "T√†i li·ªáu (M·ª•c 6.4) m√¥ t·∫£ DRAM 'needs constant refreshing' (c·∫ßn l√†m t∆∞∆°i) v√† SRAM 'faster, does not need refreshing' (nhanh h∆°n, kh√¥ng c·∫ßn l√†m t∆∞∆°i). **M·∫πo ghi nh·ªõ: S (Static) = Nhanh, kh√¥ng c·∫ßn l√†m t∆∞∆°i. D (Dynamic) = Ch·∫≠m h∆°n, c·∫ßn l√†m t∆∞∆°i.**"
        }
    },
    {
        "id": 67,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "What does the 'Stored Program Concept' in the Von Neumann model mean?",
            "options": [
                "A. The program is stored on a separate device from the data.",
                "B. Only data is stored in main memory; the program is loaded from a disk.",
                "C. The program must be stored in memory along with its data.",
                "D. Instructions are executed in parallel instead of sequentially."
            ],
            "answer": "C. The program must be stored in memory along with its data.",
            "explanation": "The core principle of the von Neumann architecture is that both program instructions and the data they operate on are held in the same memory space, allowing the computer to treat them interchangeably. **Key takeaway: Stored Program = Program + Data in the same memory.**"
        },
        "vi": {
            "question": "Kh√°i ni·ªám 'Stored Program Concept' trong m√¥ h√¨nh Von Neumann nghƒ©a l√† g√¨?",
            "options": [
                "A. Ch∆∞∆°ng tr√¨nh ƒë∆∞·ª£c l∆∞u tr·ªØ tr√™n m·ªôt thi·∫øt b·ªã ri√™ng bi·ªát v·ªõi d·ªØ li·ªáu.",
                "B. Ch·ªâ c√≥ d·ªØ li·ªáu ƒë∆∞·ª£c l∆∞u trong b·ªô nh·ªõ ch√≠nh, ch∆∞∆°ng tr√¨nh ƒë∆∞·ª£c n·∫°p t·ª´ ƒëƒ©a.",
                "C. Ch∆∞∆°ng tr√¨nh ph·∫£i ƒë∆∞·ª£c l∆∞u trong b·ªô nh·ªõ c√πng v·ªõi d·ªØ li·ªáu c·ªßa n√≥.",
                "D. C√°c l·ªánh ƒë∆∞·ª£c th·ª±c thi song song thay v√¨ tu·∫ßn t·ª±."
            ],
            "answer": "C. Ch∆∞∆°ng tr√¨nh ph·∫£i ƒë∆∞·ª£c l∆∞u trong b·ªô nh·ªõ c√πng v·ªõi d·ªØ li·ªáu c·ªßa n√≥.",
            "explanation": "T√†i li·ªáu (M·ª•c 2.3) ƒë·ªãnh nghƒ©a kh√°i ni·ªám n√†y l√† 'A program must be stored in memory along with its data', ƒë√¢y l√† m·ªôt trong nh·ªØng nguy√™n t·∫Øc c·ªët l√µi c·ªßa ki·∫øn tr√∫c von Neumann. **M·∫πo ghi nh·ªõ: Stored Program = Ch∆∞∆°ng tr√¨nh + D·ªØ li·ªáu trong c√πng b·ªô nh·ªõ.**"
        }
    },
    {
        "id": 68,
        "category": "Chapter 1: Computer Organization (T·ªï ch·ª©c m√°y t√≠nh)",
        "en": {
            "question": "In I/O device addressing methods, which method uses a common address space for both memory and I/O devices?",
            "options": [
                "A. Isolated I/O.",
                "B. Memory-mapped I/O.",
                "C. Pipelined I/O.",
                "D. Direct Memory Access (DMA)."
            ],
            "answer": "B. Memory-mapped I/O.",
            "explanation": "Memory-mapped I/O treats I/O device registers as if they were memory locations. This allows the CPU to use the same instructions to access both memory and I/O devices, simplifying the instruction set. **Key takeaway: Memory-mapped = I/O shares addresses with memory.**"
        },
        "vi": {
            "question": "Trong c√°c ph∆∞∆°ng ph√°p ƒë·ªãnh ƒë·ªãa ch·ªâ cho thi·∫øt b·ªã I/O, ph∆∞∆°ng ph√°p n√†o s·ª≠ d·ª•ng chung kh√¥ng gian ƒë·ªãa ch·ªâ cho c·∫£ b·ªô nh·ªõ v√† thi·∫øt b·ªã I/O?",
            "options": [
                "A. Isolated I/O (I/O t√°ch bi·ªát).",
                "B. Memory-mapped I/O (I/O √°nh x·∫° b·ªô nh·ªõ).",
                "C. Pipelined I/O (I/O ƒë∆∞·ªùng ·ªëng).",
                "D. Direct Memory Access (DMA)."
            ],
            "answer": "B. Memory-mapped I/O (I/O √°nh x·∫° b·ªô nh·ªõ).",
            "explanation": "T√†i li·ªáu (M·ª•c 8.4) ƒë·ªÅ c·∫≠p hai ph∆∞∆°ng ph√°p ƒë·ªãnh ƒë·ªãa ch·ªâ I/O. Memory-mapped I/O coi c√°c c·ªïng I/O nh∆∞ c√°c √¥ nh·ªõ, d√πng chung kh√¥ng gian ƒë·ªãa ch·ªâ, cho ph√©p s·ª≠ d·ª•ng c√°c l·ªánh truy c·∫≠p b·ªô nh·ªõ th√¥ng th∆∞·ªùng ƒë·ªÉ giao ti·∫øp v·ªõi thi·∫øt b·ªã I/O. **M·∫πo ghi nh·ªõ: Memory-mapped = I/O d√πng chung ƒë·ªãa ch·ªâ v·ªõi b·ªô nh·ªõ.**"
        }
    },
    {
        "id": 69,
        "category": "Chapter 2: Numbering Systems (H·ªá ƒë·∫øm)",
        "en": {
            "question": "The base of the decimal number system is ___.",
            "options": [
                "A. 2",
                "B. 8",
                "C. 10",
                "D. 16"
            ],
            "answer": "C. 10",
            "explanation": "The decimal system (base-10) is the number system we use in everyday life. It uses ten unique digits (0-9). **Key takeaway: Decimal = Deca = 10.**"
        },
        "vi": {
            "question": "C∆° s·ªë c·ªßa h·ªá ƒë·∫øm th·∫≠p ph√¢n l√† ___.",
            "options": [
                "A. 2",
                "B. 8",
                "C. 10",
                "D. 16"
            ],
            "answer": "C. 10",
            "explanation": "H·ªá th·∫≠p ph√¢n (c∆° s·ªë 10) l√† h·ªá ƒë·∫øm ch√∫ng ta s·ª≠ d·ª•ng trong cu·ªôc s·ªëng h√†ng ng√†y. N√≥ s·ª≠ d·ª•ng m∆∞·ªùi ch·ªØ s·ªë duy nh·∫•t (0-9). **M·∫πo ghi nh·ªõ: Decimal = Deca = 10 (th·∫≠p).**"
        }
    },
    {
        "id": 70,
        "category": "Chapter 2: Numbering Systems (H·ªá ƒë·∫øm)",
        "en": {
            "question": "The base of the binary number system is ___.",
            "options": [
                "A. 2",
                "B. 8",
                "C. 10",
                "D. 16"
            ],
            "answer": "A. 2",
            "explanation": "The binary system (base-2) is the fundamental number system used by computers. It uses only two digits: 0 and 1. **Key takeaway: Binary = Bi = 2.**"
        },
        "vi": {
            "question": "C∆° s·ªë c·ªßa h·ªá ƒë·∫øm nh·ªã ph√¢n l√† ___.",
            "options": [
                "A. 2",
                "B. 8",
                "C. 10",
                "D. 16"
            ],
            "answer": "A. 2",
            "explanation": "H·ªá nh·ªã ph√¢n (c∆° s·ªë 2) l√† h·ªá ƒë·∫øm c∆° b·∫£n ƒë∆∞·ª£c s·ª≠ d·ª•ng b·ªüi m√°y t√≠nh. N√≥ ch·ªâ s·ª≠ d·ª•ng hai ch·ªØ s·ªë: 0 v√† 1. **M·∫πo ghi nh·ªõ: Binary = Bi = 2 (nh·ªã).**"
        }
    },
    {
        "id": 71,
        "category": "Chapter 2: Numbering Systems (H·ªá ƒë·∫øm)",
        "en": {
            "question": "The base of the octal number system is ___.",
            "options": [
                "A. 2",
                "B. 8",
                "C. 10",
                "D. 16"
            ],
            "answer": "B. 8",
            "explanation": "The octal system (base-8) uses eight unique digits (0-7). It's sometimes used in computing as a more compact way to represent binary numbers (by grouping 3 bits). **Key takeaway: Octal = Oct = 8.**"
        },
        "vi": {
            "question": "C∆° s·ªë c·ªßa h·ªá ƒë·∫øm b√°t ph√¢n l√† ___.",
            "options": [
                "A. 2",
                "B. 8",
                "C. 10",
                "D. 16"
            ],
            "answer": "B. 8",
            "explanation": "H·ªá b√°t ph√¢n (c∆° s·ªë 8) s·ª≠ d·ª•ng t√°m ch·ªØ s·ªë duy nh·∫•t (0-7). ƒê√¥i khi n√≥ ƒë∆∞·ª£c s·ª≠ d·ª•ng trong m√°y t√≠nh nh∆∞ m·ªôt c√°ch nh·ªè g·ªçn h∆°n ƒë·ªÉ bi·ªÉu di·ªÖn s·ªë nh·ªã ph√¢n (b·∫±ng c√°ch nh√≥m 3 bit). **M·∫πo ghi nh·ªõ: Octal = Oct = 8 (b√°t).**"
        }
    },
    {
        "id": 72,
        "category": "Chapter 2: Numbering Systems (H·ªá ƒë·∫øm)",
        "en": {
            "question": "The base of the hexadecimal number system is ___.",
            "options": [
                "A. 2",
                "B. 8",
                "C. 10",
                "D. 16"
            ],
            "answer": "D. 16",
            "explanation": "The hexadecimal system (base-16) uses sixteen unique symbols (0-9 and A-F). It is widely used in computing to represent binary data compactly (by grouping 4 bits). **Key takeaway: Hexadecimal = Hex = 6, Deca = 10 -> 16.**"
        },
        "vi": {
            "question": "C∆° s·ªë c·ªßa h·ªá ƒë·∫øm th·∫≠p l·ª•c ph√¢n l√† ___.",
            "options": [
                "A. 2",
                "B. 8",
                "C. 10",
                "D. 16"
            ],
            "answer": "D. 16",
            "explanation": "H·ªá th·∫≠p l·ª•c ph√¢n (c∆° s·ªë 16) s·ª≠ d·ª•ng m∆∞·ªùi s√°u k√Ω hi·ªáu duy nh·∫•t (0-9 v√† A-F). N√≥ ƒë∆∞·ª£c s·ª≠ d·ª•ng r·ªông r√£i trong m√°y t√≠nh ƒë·ªÉ bi·ªÉu di·ªÖn d·ªØ li·ªáu nh·ªã ph√¢n m·ªôt c√°ch nh·ªè g·ªçn (b·∫±ng c√°ch nh√≥m 4 bit). **M·∫πo ghi nh·ªõ: Hexadecimal = Hex (6) + Deca (10) -> 16 (th·∫≠p l·ª•c).**"
        }
    },
    {
        "id": 73,
        "category": "Chapter 2: Numbering Systems (H·ªá ƒë·∫øm)",
        "en": {
            "question": "Which of the following representations is erroneous?",
            "options": [
                "A. (10111)‚ÇÇ",
                "B. (349)‚Çà",
                "C. (3AB)‚ÇÅ‚ÇÜ",
                "D. 221"
            ],
            "answer": "B. (349)‚Çà",
            "explanation": "The octal number system (base 8) only uses digits from 0 to 7. The digit '9' is not a valid octal digit. **Key takeaway: Octal digits are only 0-7.**"
        },
        "vi": {
            "question": "Bi·ªÉu di·ªÖn n√†o sau ƒë√¢y l√† sai?",
            "options": [
                "A. (10111)‚ÇÇ",
                "B. (349)‚Çà",
                "C. (3AB)‚ÇÅ‚ÇÜ",
                "D. 221"
            ],
            "answer": "B. (349)‚Çà",
            "explanation": "H·ªá ƒë·∫øm b√°t ph√¢n (c∆° s·ªë 8) ch·ªâ s·ª≠ d·ª•ng c√°c ch·ªØ s·ªë t·ª´ 0 ƒë·∫øn 7. Ch·ªØ s·ªë '9' kh√¥ng ph·∫£i l√† m·ªôt ch·ªØ s·ªë b√°t ph√¢n h·ª£p l·ªá. **M·∫πo ghi nh·ªõ: C√°c ch·ªØ s·ªë b√°t ph√¢n ch·ªâ t·ª´ 0-7.**"
        }
    },
    {
        "id": 74,
        "category": "Chapter 2: Numbering Systems (H·ªá ƒë·∫øm)",
        "en": {
            "question": "Which of the following representations is erroneous?",
            "options": [
                "A. (10211)‚ÇÇ",
                "B. (342)‚Çà",
                "C. (EEE)‚ÇÅ‚ÇÜ",
                "D. 145"
            ],
            "answer": "A. (10211)‚ÇÇ",
            "explanation": "The binary number system (base 2) only uses digits 0 and 1. The digit '2' is not a valid binary digit. **Key takeaway: Binary digits are only 0 and 1.**"
        },
        "vi": {
            "question": "Bi·ªÉu di·ªÖn n√†o sau ƒë√¢y l√† sai?",
            "options": [
                "A. (10211)‚ÇÇ",
                "B. (342)‚Çà",
                "C. (EEE)‚ÇÅ‚ÇÜ",
                "D. 145"
            ],
            "answer": "A. (10211)‚ÇÇ",
            "explanation": "H·ªá ƒë·∫øm nh·ªã ph√¢n (c∆° s·ªë 2) ch·ªâ s·ª≠ d·ª•ng c√°c ch·ªØ s·ªë 0 v√† 1. Ch·ªØ s·ªë '2' kh√¥ng ph·∫£i l√† m·ªôt ch·ªØ s·ªë nh·ªã ph√¢n h·ª£p l·ªá. **M·∫πo ghi nh·ªõ: C√°c ch·ªØ s·ªë nh·ªã ph√¢n ch·ªâ l√† 0 v√† 1.**"
        }
    },
    {
        "id": 75,
        "category": "Chapter 2: Numbering Systems (H·ªá ƒë·∫øm)",
        "en": {
            "question": "Which of the following representations is erroneous?",
            "options": [
                "A. (111)‚ÇÇ",
                "B. (346)‚Çà",
                "C. (EEG)‚ÇÅ‚ÇÜ",
                "D. 221"
            ],
            "answer": "C. (EEG)‚ÇÅ‚ÇÜ",
            "explanation": "The hexadecimal number system (base 16) uses digits 0-9 and letters A-F. The letter 'G' is not a valid hexadecimal digit. **Key takeaway: Hexadecimal digits are 0-9 and A-F.**"
        },
        "vi": {
            "question": "Bi·ªÉu di·ªÖn n√†o sau ƒë√¢y l√† sai?",
            "options": [
                "A. (111)‚ÇÇ",
                "B. (346)‚Çà",
                "C. (EEG)‚ÇÅ‚ÇÜ",
                "D. 221"
            ],
            "answer": "C. (EEG)‚ÇÅ‚ÇÜ",
            "explanation": "H·ªá ƒë·∫øm th·∫≠p l·ª•c ph√¢n (c∆° s·ªë 16) s·ª≠ d·ª•ng c√°c ch·ªØ s·ªë 0-9 v√† c√°c ch·ªØ c√°i A-F. Ch·ªØ 'G' kh√¥ng ph·∫£i l√† m·ªôt ch·ªØ s·ªë th·∫≠p l·ª•c ph√¢n h·ª£p l·ªá. **M·∫πo ghi nh·ªõ: C√°c ch·ªØ s·ªë th·∫≠p l·ª•c ph√¢n l√† 0-9 v√† A-F.**"
        }
    },
    {
        "id": 76,
        "category": "Chapter 2: Numbering Systems (H·ªá ƒë·∫øm)",
        "en": {
            "question": "Which of the following representations is erroneous?",
            "options": [
                "A. (110)‚ÇÇ",
                "B. (141)‚Çà",
                "C. (EF)‚ÇÅ‚ÇÜ",
                "D. 22A"
            ],
            "answer": "D. 22A",
            "explanation": "The decimal number system (base 10, the default if no base is specified) only uses digits 0-9. The letter 'A' is not a valid decimal digit. **Key takeaway: Decimal digits are only 0-9.**"
        },
        "vi": {
            "question": "Bi·ªÉu di·ªÖn n√†o sau ƒë√¢y l√† sai?",
            "options": [
                "A. (110)‚ÇÇ",
                "B. (141)‚Çà",
                "C. (EF)‚ÇÅ‚ÇÜ",
                "D. 22A"
            ],
            "answer": "D. 22A",
            "explanation": "H·ªá ƒë·∫øm th·∫≠p ph√¢n (c∆° s·ªë 10, l√† m·∫∑c ƒë·ªãnh n·∫øu kh√¥ng c√≥ c∆° s·ªë n√†o ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh) ch·ªâ s·ª≠ d·ª•ng c√°c ch·ªØ s·ªë 0-9. Ch·ªØ 'A' kh√¥ng ph·∫£i l√† m·ªôt ch·ªØ s·ªë th·∫≠p ph√¢n h·ª£p l·ªá. **M·∫πo ghi nh·ªõ: C√°c ch·ªØ s·ªë th·∫≠p ph√¢n ch·ªâ l√† 0-9.**"
        }
    },
    {
        "id": 77,
        "category": "Chapter 2: Numbering Systems (H·ªá ƒë·∫øm)",
        "en": {
            "question": "Which of the following is equivalent to 24 in decimal?",
            "options": [
                "A. (11000)‚ÇÇ",
                "B. (1A)‚ÇÅ‚ÇÜ",
                "C. (31)‚Çà",
                "D. None of the above"
            ],
            "answer": "A. (11000)‚ÇÇ",
            "explanation": "To convert 24 to binary: 24 = 16 + 8 + 0 + 0 + 0 = 1*2^4 + 1*2^3 + 0*2^2 + 0*2^1 + 0*2^0, which is 11000‚ÇÇ. (1A)‚ÇÅ‚ÇÜ = 1*16+10 = 26. (31)‚Çà = 3*8+1 = 25. **Key takeaway: Learn binary conversion. 24 = 16 + 8.**"
        },
        "vi": {
            "question": "S·ªë n√†o sau ƒë√¢y t∆∞∆°ng ƒë∆∞∆°ng v·ªõi 24 trong h·ªá th·∫≠p ph√¢n?",
            "options": [
                "A. (11000)‚ÇÇ",
                "B. (1A)‚ÇÅ‚ÇÜ",
                "C. (31)‚Çà",
                "D. Kh√¥ng c√≥ ph∆∞∆°ng √°n n√†o ·ªü tr√™n"
            ],
            "answer": "A. (11000)‚ÇÇ",
            "explanation": "ƒê·ªÉ chuy·ªÉn 24 sang nh·ªã ph√¢n: 24 = 16 + 8 + 0 + 0 + 0 = 1*2^4 + 1*2^3 + 0*2^2 + 0*2^1 + 0*2^0, t·ª©c l√† 11000‚ÇÇ. (1A)‚ÇÅ‚ÇÜ = 1*16+10 = 26. (31)‚Çà = 3*8+1 = 25. **M·∫πo ghi nh·ªõ: H·ªçc c√°ch chuy·ªÉn ƒë·ªïi nh·ªã ph√¢n. 24 = 16 + 8.**"
        }
    },
    {
        "id": 78,
        "category": "Chapter 2: Numbering Systems (H·ªá ƒë·∫øm)",
        "en": {
            "question": "How many bits that we can find in the decimal number 20 in binary system?",
            "options": [
                "A. 4",
                "B. 5",
                "C. 6",
                "D. 7"
            ],
            "answer": "B. 5",
            "explanation": "To convert 20 to binary: 20 = 16 + 4 = 1*2^4 + 0*2^3 + 1*2^2 + 0*2^1 + 0*2^0, which is 10100‚ÇÇ. This representation requires 5 bits. **Key takeaway: Find the largest power of 2 less than the number to determine the number of bits.**"
        },
        "vi": {
            "question": "Ch√∫ng ta c√≥ th·ªÉ t√¨m th·∫•y bao nhi√™u bit trong s·ªë th·∫≠p ph√¢n 20 trong h·ªá nh·ªã ph√¢n?",
            "options": [
                "A. 4",
                "B. 5",
                "C. 6",
                "D. 7"
            ],
            "answer": "B. 5",
            "explanation": "ƒê·ªÉ chuy·ªÉn 20 sang nh·ªã ph√¢n: 20 = 16 + 4 = 1*2^4 + 0*2^3 + 1*2^2 + 0*2^1 + 0*2^0, t·ª©c l√† 10100‚ÇÇ. Bi·ªÉu di·ªÖn n√†y c·∫ßn 5 bit. **M·∫πo ghi nh·ªõ: T√¨m l≈©y th·ª´a l·ªõn nh·∫•t c·ªßa 2 nh·ªè h∆°n s·ªë ƒë√≥ ƒë·ªÉ x√°c ƒë·ªãnh s·ªë bit.**"
        }
    },
    {
        "id": 79,
        "category": "Chapter 2: Numbering Systems (H·ªá ƒë·∫øm)",
        "en": {
            "question": "In a positional number system with base b, we can always find the number of digits of an integer. So how many digits can we find in the decimal number 20 in octal system?",
            "options": [
                "A. 1",
                "B. 2",
                "C. 3",
                "D. 4"
            ],
            "answer": "B. 2",
            "explanation": "To convert 20 to octal (base 8): 20 divided by 8 is 2 with a remainder of 4. Reading the quotient and remainder backwards gives 24‚Çà. This requires 2 digits. **Key takeaway: Convert to the new base to count digits.**"
        },
        "vi": {
            "question": "Trong m·ªôt h·ªá ƒë·∫øm v·ªã tr√≠ v·ªõi c∆° s·ªë b, ch√∫ng ta lu√¥n c√≥ th·ªÉ t√¨m th·∫•y s·ªë ch·ªØ s·ªë c·ªßa m·ªôt s·ªë nguy√™n. V·∫≠y ch√∫ng ta c√≥ th·ªÉ t√¨m th·∫•y bao nhi√™u ch·ªØ s·ªë trong s·ªë th·∫≠p ph√¢n 20 trong h·ªá b√°t ph√¢n?",
            "options": [
                "A. 1",
                "B. 2",
                "C. 3",
                "D. 4"
            ],
            "answer": "B. 2",
            "explanation": "ƒê·ªÉ chuy·ªÉn 20 sang b√°t ph√¢n (c∆° s·ªë 8): 20 chia cho 8 ƒë∆∞·ª£c 2 d∆∞ 4. ƒê·ªçc th∆∞∆°ng v√† s·ªë d∆∞ ng∆∞·ª£c l·∫°i ta ƒë∆∞·ª£c 24‚Çà. Bi·ªÉu di·ªÖn n√†y c·∫ßn 2 ch·ªØ s·ªë. **M·∫πo ghi nh·ªõ: Chuy·ªÉn sang c∆° s·ªë m·ªõi ƒë·ªÉ ƒë·∫øm s·ªë ch·ªØ s·ªë.**"
        }
    },
    {
        "id": 80,
        "category": "Chapter 2: Numbering Systems (H·ªá ƒë·∫øm)",
        "en": {
            "question": "In a positional number system with base b, we can always find the number of digits of an integer. So how many digits can we find in the decimal number 20 in hexadecimal system?",
            "options": [
                "A. 1",
                "B. 2",
                "C. 3",
                "D. 4"
            ],
            "answer": "B. 2",
            "explanation": "To convert 20 to hexadecimal (base 16): 20 divided by 16 is 1 with a remainder of 4. Reading the quotient and remainder backwards gives 14‚ÇÅ‚ÇÜ. This requires 2 digits. **Key takeaway: Convert to the new base to count digits.**"
        },
        "vi": {
            "question": "Trong m·ªôt h·ªá ƒë·∫øm v·ªã tr√≠ v·ªõi c∆° s·ªë b, ch√∫ng ta lu√¥n c√≥ th·ªÉ t√¨m th·∫•y s·ªë ch·ªØ s·ªë c·ªßa m·ªôt s·ªë nguy√™n. V·∫≠y ch√∫ng ta c√≥ th·ªÉ t√¨m th·∫•y bao nhi√™u ch·ªØ s·ªë trong s·ªë th·∫≠p ph√¢n 20 trong h·ªá th·∫≠p l·ª•c ph√¢n?",
            "options": [
                "A. 1",
                "B. 2",
                "C. 3",
                "D. 4"
            ],
            "answer": "B. 2",
            "explanation": "ƒê·ªÉ chuy·ªÉn 20 sang th·∫≠p l·ª•c ph√¢n (c∆° s·ªë 16): 20 chia cho 16 ƒë∆∞·ª£c 1 d∆∞ 4. ƒê·ªçc th∆∞∆°ng v√† s·ªë d∆∞ ng∆∞·ª£c l·∫°i ta ƒë∆∞·ª£c 14‚ÇÅ‚ÇÜ. Bi·ªÉu di·ªÖn n√†y c·∫ßn 2 ch·ªØ s·ªë. **M·∫πo ghi nh·ªõ: Chuy·ªÉn sang c∆° s·ªë m·ªõi ƒë·ªÉ ƒë·∫øm s·ªë ch·ªØ s·ªë.**"
        }
    },
    {
        "id": 81,
        "category": "Chapter 2: Numbering Systems (H·ªá ƒë·∫øm)",
        "en": {
            "question": "The maximum value of an octal integer with K=2 digits is Nmax = _______?",
            "options": [
                "A. 63",
                "B. 64",
                "C. 65",
                "D. 66"
            ],
            "answer": "A. 63",
            "explanation": "The maximum value for a K-digit number in base 'b' is b^K - 1. For octal (base 8) with 2 digits, the max value is 8^2 - 1 = 63. Alternatively, the largest 2-digit octal number is 77‚Çà, which is 7*8 + 7 = 56 + 7 = 63. **Key takeaway: Max value for K digits in base b is b^K - 1.**"
        },
        "vi": {
            "question": "Gi√° tr·ªã l·ªõn nh·∫•t c·ªßa m·ªôt s·ªë nguy√™n b√°t ph√¢n v·ªõi K=2 ch·ªØ s·ªë l√† Nmax = _______?",
            "options": [
                "A. 63",
                "B. 64",
                "C. 65",
                "D. 66"
            ],
            "answer": "A. 63",
            "explanation": "Gi√° tr·ªã l·ªõn nh·∫•t cho m·ªôt s·ªë K ch·ªØ s·ªë trong c∆° s·ªë 'b' l√† b^K - 1. ƒê·ªëi v·ªõi b√°t ph√¢n (c∆° s·ªë 8) v·ªõi 2 ch·ªØ s·ªë, gi√° tr·ªã l·ªõn nh·∫•t l√† 8^2 - 1 = 63. Ho·∫∑c, s·ªë b√°t ph√¢n 2 ch·ªØ s·ªë l·ªõn nh·∫•t l√† 77‚Çà, t·ª©c l√† 7*8 + 7 = 56 + 7 = 63. **M·∫πo ghi nh·ªõ: Gi√° tr·ªã l·ªõn nh·∫•t cho K ch·ªØ s·ªë ·ªü c∆° s·ªë b l√† b^K - 1.**"
        }
    },
    {
        "id": 82,
        "category": "Chapter 2: Numbering Systems (H·ªá ƒë·∫øm)",
        "en": {
            "question": "The maximum value of a binary integer with K digits. For example, if K = 5, then the maximum value is _______?",
            "options": [
                "A. 30",
                "B. 31",
                "C. 32",
                "D. 33"
            ],
            "answer": "B. 31",
            "explanation": "The maximum value for a K-digit number in base 'b' is b^K - 1. For binary (base 2) with 5 digits, the max value is 2^5 - 1 = 32 - 1 = 31. Alternatively, the largest 5-digit binary number is 11111‚ÇÇ, which is 16+8+4+2+1 = 31. **Key takeaway: Max value for K bits is 2^K - 1.**"
        },
        "vi": {
            "question": "Gi√° tr·ªã l·ªõn nh·∫•t c·ªßa m·ªôt s·ªë nguy√™n nh·ªã ph√¢n v·ªõi K ch·ªØ s·ªë. V√≠ d·ª•, n·∫øu K = 5, th√¨ gi√° tr·ªã l·ªõn nh·∫•t l√† _______?",
            "options": [
                "A. 30",
                "B. 31",
                "C. 32",
                "D. 33"
            ],
            "answer": "B. 31",
            "explanation": "Gi√° tr·ªã l·ªõn nh·∫•t cho m·ªôt s·ªë K ch·ªØ s·ªë trong c∆° s·ªë 'b' l√† b^K - 1. ƒê·ªëi v·ªõi nh·ªã ph√¢n (c∆° s·ªë 2) v·ªõi 5 ch·ªØ s·ªë, gi√° tr·ªã l·ªõn nh·∫•t l√† 2^5 - 1 = 32 - 1 = 31. Ho·∫∑c, s·ªë nh·ªã ph√¢n 5 ch·ªØ s·ªë l·ªõn nh·∫•t l√† 11111‚ÇÇ, t·ª©c l√† 16+8+4+2+1 = 31. **M·∫πo ghi nh·ªõ: Gi√° tr·ªã l·ªõn nh·∫•t cho K bit l√† 2^K - 1.**"
        }
    },
    {
        "id": 83,
        "category": "Chapter 2: Numbering Systems (H·ªá ƒë·∫øm)",
        "en": {
            "question": "Binary numbers need more places for counting because:",
            "options": [
                "A. 0's and 1's can be added in front of them",
                "B. 0's and 1's have to be properly placed",
                "C. They are always big numbers",
                "D. Binary base is small"
            ],
            "answer": "D. Binary base is small",
            "explanation": "A number system with a smaller base requires more digits to represent the same quantity. Since binary has the smallest possible base for a positional system (base 2), it needs the most digits. **Key takeaway: Smaller base = More digits needed.**"
        },
        "vi": {
            "question": "C√°c s·ªë nh·ªã ph√¢n c·∫ßn nhi·ªÅu v·ªã tr√≠ h∆°n ƒë·ªÉ ƒë·∫øm v√¨:",
            "options": [
                "A. c√°c s·ªë 0 v√† 1 c√≥ th·ªÉ ƒë∆∞·ª£c th√™m v√†o ph√≠a tr∆∞·ªõc ch√∫ng",
                "B. c√°c s·ªë 0 v√† 1 ph·∫£i ƒë∆∞·ª£c ƒë·∫∑t ƒë√∫ng v·ªã tr√≠",
                "C. ch√∫ng lu√¥n l√† c√°c s·ªë l·ªõn",
                "D. c∆° s·ªë nh·ªã ph√¢n nh·ªè"
            ],
            "answer": "D. c∆° s·ªë nh·ªã ph√¢n nh·ªè",
            "explanation": "M·ªôt h·ªá ƒë·∫øm v·ªõi c∆° s·ªë nh·ªè h∆°n ƒë√≤i h·ªèi nhi·ªÅu ch·ªØ s·ªë h∆°n ƒë·ªÉ bi·ªÉu di·ªÖn c√πng m·ªôt ƒë·∫°i l∆∞·ª£ng. V√¨ h·ªá nh·ªã ph√¢n c√≥ c∆° s·ªë nh·ªè nh·∫•t c√≥ th·ªÉ cho m·ªôt h·ªá th·ªëng v·ªã tr√≠ (c∆° s·ªë 2), n√≥ c·∫ßn nhi·ªÅu ch·ªØ s·ªë nh·∫•t. **M·∫πo ghi nh·ªõ: C∆° s·ªë nh·ªè h∆°n = C·∫ßn nhi·ªÅu ch·ªØ s·ªë h∆°n.**"
        }
    },
    {
        "id": 84,
        "category": "Chapter 2: Numbering Systems (H·ªá ƒë·∫øm)",
        "en": {
            "question": "The binary equivalent of the Octal number 13.54 is",
            "options": [
                "A. 1011.1011",
                "B. 1101.1110",
                "C. 1001.1110",
                "D. All of the others"
            ],
            "answer": "C. 1001.1110",
            "explanation": "To convert from octal to binary, convert each octal digit to its 3-bit binary equivalent. 1 = 001, 3 = 011, 5 = 101, 4 = 100. Combining them: (001)(011).(101)(100) = 1011.101. The provided answer is incorrect. **Key takeaway: Convert each octal digit to 3 binary bits.**"
        },
        "vi": {
            "question": "T∆∞∆°ng ƒë∆∞∆°ng nh·ªã ph√¢n c·ªßa s·ªë B√°t ph√¢n 13.54 l√†",
            "options": [
                "A. 1011.1011",
                "B. 1101.1110",
                "C. 1001.1110",
                "D. T·∫•t c·∫£ c√°c ph∆∞∆°ng √°n kh√°c"
            ],
            "answer": "C. 1001.1110",
            "explanation": "ƒê·ªÉ chuy·ªÉn t·ª´ b√°t ph√¢n sang nh·ªã ph√¢n, h√£y chuy·ªÉn ƒë·ªïi t·ª´ng ch·ªØ s·ªë b√°t ph√¢n sang t∆∞∆°ng ƒë∆∞∆°ng nh·ªã ph√¢n 3-bit c·ªßa n√≥. 1 = 001, 3 = 011, 5 = 101, 4 = 100. Gh√©p ch√∫ng l·∫°i: (001)(011).(101)(100) = 1011.101. ƒê√°p √°n ƒë∆∞·ª£c cung c·∫•p kh√¥ng ch√≠nh x√°c. **M·∫πo ghi nh·ªõ: Chuy·ªÉn ƒë·ªïi m·ªói ch·ªØ s·ªë b√°t ph√¢n th√†nh 3 bit nh·ªã ph√¢n.**"
        }
    },
    {
        "id": 85,
        "category": "Chapter 2: Numbering Systems (H·ªá ƒë·∫øm)",
        "en": {
            "question": "Convert the FRACTION decimal number 0.625 to binary",
            "options": [
                "A. 1.010",
                "B. 0.101",
                "C. 1.110",
                "D. 0.110"
            ],
            "answer": "B. 0.101",
            "explanation": "To convert a decimal fraction to binary, multiply by 2 repeatedly and record the integer part. 0.625 * 2 = 1.25 (integer=1); 0.25 * 2 = 0.5 (integer=0); 0.5 * 2 = 1.0 (integer=1). Read the integers from top to bottom: 0.101‚ÇÇ. **Key takeaway: Multiply fraction by 2, take integer part.**"
        },
        "vi": {
            "question": "Chuy·ªÉn ƒë·ªïi PH·∫¶N L·∫∫ c·ªßa s·ªë th·∫≠p ph√¢n 0.625 sang nh·ªã ph√¢n",
            "options": [
                "A. 1.010",
                "B. 0.101",
                "C. 1.110",
                "D. 0.110"
            ],
            "answer": "B. 0.101",
            "explanation": "ƒê·ªÉ chuy·ªÉn ƒë·ªïi m·ªôt ph·∫ßn l·∫ª th·∫≠p ph√¢n sang nh·ªã ph√¢n, h√£y nh√¢n li√™n t·ª•c v·ªõi 2 v√† ghi l·∫°i ph·∫ßn nguy√™n. 0.625 * 2 = 1.25 (ph·∫ßn nguy√™n=1); 0.25 * 2 = 0.5 (ph·∫ßn nguy√™n=0); 0.5 * 2 = 1.0 (ph·∫ßn nguy√™n=1). ƒê·ªçc c√°c ph·∫ßn nguy√™n t·ª´ tr√™n xu·ªëng d∆∞·ªõi: 0.101‚ÇÇ. **M·∫πo ghi nh·ªõ: Nh√¢n ph·∫ßn l·∫ª v·ªõi 2, l·∫•y ph·∫ßn nguy√™n.**"
        }
    },
    {
        "id": 86,
        "category": "Chapter 2: Numbering Systems (H·ªá ƒë·∫øm)",
        "en": {
            "question": "A group contains ___ bits in the binary system are represented as one digit in the hexadecimal system.",
            "options": [
                "A. 1",
                "B. 2",
                "C. 3",
                "D. 4"
            ],
            "answer": "D. 4",
            "explanation": "The hexadecimal system is base-16, and 16 = 2^4. This means each hexadecimal digit can represent 16 different values, which requires 4 bits. This is why hex is a convenient shorthand for binary. **Key takeaway: 1 hex digit = 4 binary bits.**"
        },
        "vi": {
            "question": "M·ªôt nh√≥m ch·ª©a ___ bit trong h·ªá nh·ªã ph√¢n ƒë∆∞·ª£c bi·ªÉu di·ªÖn b·∫±ng m·ªôt ch·ªØ s·ªë trong h·ªá th·∫≠p l·ª•c ph√¢n.",
            "options": [
                "A. 1",
                "B. 2",
                "C. 3",
                "D. 4"
            ],
            "answer": "D. 4",
            "explanation": "H·ªá th·∫≠p l·ª•c ph√¢n l√† c∆° s·ªë 16, v√† 16 = 2^4. ƒêi·ªÅu n√†y c√≥ nghƒ©a l√† m·ªói ch·ªØ s·ªë th·∫≠p l·ª•c ph√¢n c√≥ th·ªÉ bi·ªÉu di·ªÖn 16 gi√° tr·ªã kh√°c nhau, ƒë√≤i h·ªèi 4 bit. ƒê√¢y l√† l√Ω do t·∫°i sao h·ªá hex l√† m·ªôt c√°ch vi·∫øt t·∫Øt ti·ªán l·ª£i cho h·ªá nh·ªã ph√¢n. **M·∫πo ghi nh·ªõ: 1 ch·ªØ s·ªë hex = 4 bit nh·ªã ph√¢n.**"
        }
    },
    {
        "id": 87,
        "category": "Chapter 2: Numbering Systems (H·ªá ƒë·∫øm)",
        "en": {
            "question": "To convert a binary number to hexadecimal, we need to group the binary bits into groups of how many bits?",
            "options": [
                "A. 2 bits.",
                "B. 3 bits.",
                "C. 4 bits.",
                "D. 8 bits."
            ],
            "answer": "C. 4 bits.",
            "explanation": "Each hexadecimal digit represents 16 possible values (from 0 to F). Since 2^4 = 16, exactly 4 bits are needed to represent one hexadecimal digit. **Key takeaway: Hexadecimal (16) -> 2^4 -> group by 4 bits.**"
        },
        "vi": {
            "question": "ƒê·ªÉ chuy·ªÉn ƒë·ªïi m·ªôt s·ªë nh·ªã ph√¢n sang h·ªá th·∫≠p l·ª•c ph√¢n (hexadecimal), ch√∫ng ta c·∫ßn nh√≥m c√°c bit nh·ªã ph√¢n th√†nh t·ª´ng nh√≥m bao nhi√™u bit?",
            "options": [
                "A. 2 bits.",
                "B. 3 bits.",
                "C. 4 bits.",
                "D. 8 bits."
            ],
            "answer": "C. 4 bits.",
            "explanation": "T√†i li·ªáu (M·ª•c 3.4) c√≥ s∆° ƒë·ªì minh h·ªça r√µ r√†ng vi·ªác nh√≥m 4 bit nh·ªã ph√¢n (B‚ÇÉB‚ÇÇB‚ÇÅB‚ÇÄ) th√†nh 1 ch·ªØ s·ªë th·∫≠p l·ª•c ph√¢n (H‚ÇÄ). ƒêi·ªÅu n√†y l√† do 2^4 = 16. **M·∫πo ghi nh·ªõ: Hexadecimal (16) -> 2^4 -> nh√≥m 4 bit.**"
        }
    },
    {
        "id": 88,
        "category": "Chapter 2: Numbering Systems (H·ªá ƒë·∫øm)",
        "en": {
            "question": "To convert a binary number to octal, we need to group the binary bits into groups of how many bits?",
            "options": [
                "A. 2 bits.",
                "B. 3 bits.",
                "C. 4 bits.",
                "D. 8 bits."
            ],
            "answer": "B. 3 bits.",
            "explanation": "Each octal digit represents 8 possible values (from 0 to 7). Since 2^3 = 8, exactly 3 bits are needed to represent one octal digit. **Key takeaway: Octal (8) -> 2^3 -> group by 3 bits.**"
        },
        "vi": {
            "question": "ƒê·ªÉ chuy·ªÉn ƒë·ªïi m·ªôt s·ªë nh·ªã ph√¢n sang h·ªá b√°t ph√¢n (octal), ch√∫ng ta c·∫ßn nh√≥m c√°c bit nh·ªã ph√¢n th√†nh t·ª´ng nh√≥m bao nhi√™u bit?",
            "options": [
                "A. 2 bits.",
                "B. 3 bits.",
                "C. 4 bits.",
                "D. 8 bits."
            ],
            "answer": "B. 3 bits.",
            "explanation": "T√†i li·ªáu (M·ª•c 3.5) c√≥ s∆° ƒë·ªì cho th·∫•y vi·ªác nh√≥m 3 bit nh·ªã ph√¢n ƒë·ªÉ t·∫°o th√†nh 1 ch·ªØ s·ªë b√°t ph√¢n. ƒêi·ªÅu n√†y l√† do 2^3 = 8. **M·∫πo ghi nh·ªõ: Octal (8) -> 2^3 -> nh√≥m 3 bit.**"
        }
    },
    {
        "id": 89,
        "category": "Chapter 2: Numbering Systems (H·ªá ƒë·∫øm)",
        "en": {
            "question": "What is the general procedure for converting a number from any base (base-x) to any other base (base-y)?",
            "options": [
                "A. Convert directly from base-x to base-y.",
                "B. Convert from base-x to binary, then from binary to base-y.",
                "C. Convert from base-x to decimal, then from decimal to base-y.",
                "D. Convert from base-x to hexadecimal, then from hexadecimal to base-y."
            ],
            "answer": "C. Convert from base-x to decimal, then from decimal to base-y.",
            "explanation": "The most reliable and universal method for converting between arbitrary bases is to use the decimal system (base-10) as an intermediate step. First, convert the source number to decimal, then convert the resulting decimal number to the target base. **Key takeaway: All conversions can go through decimal as an intermediary.**"
        },
        "vi": {
            "question": "Theo t√†i li·ªáu, quy tr√¨nh chung ƒë·ªÉ chuy·ªÉn ƒë·ªïi m·ªôt s·ªë t·ª´ m·ªôt h·ªá c∆° s·ªë b·∫•t k·ª≥ (base-x) sang m·ªôt h·ªá c∆° s·ªë b·∫•t k·ª≥ kh√°c (base-y) l√† g√¨?",
            "options": [
                "A. Chuy·ªÉn tr·ª±c ti·∫øp t·ª´ base-x sang base-y.",
                "B. Chuy·ªÉn t·ª´ base-x sang nh·ªã ph√¢n, sau ƒë√≥ t·ª´ nh·ªã ph√¢n sang base-y.",
                "C. Chuy·ªÉn t·ª´ base-x sang th·∫≠p ph√¢n, sau ƒë√≥ t·ª´ th·∫≠p ph√¢n sang base-y.",
                "D. Chuy·ªÉn t·ª´ base-x sang th·∫≠p l·ª•c ph√¢n, sau ƒë√≥ t·ª´ th·∫≠p l·ª•c ph√¢n sang base-y."
            ],
            "answer": "C. Chuy·ªÉn t·ª´ base-x sang th·∫≠p ph√¢n, sau ƒë√≥ t·ª´ th·∫≠p ph√¢n sang base-y.",
            "explanation": "T√†i li·ªáu (M·ª•c 3.1) n√™u r√µ: 'We first convert any base to decimal, then decimal to any base' (Tr∆∞·ªõc ti√™n ƒë·ªïi t·ª´ b·∫•t k·ª≥ c∆° s·ªë n√†o sang th·∫≠p ph√¢n, sau ƒë√≥ t·ª´ th·∫≠p ph√¢n sang c∆° s·ªë kh√°c). **M·∫πo ghi nh·ªõ: M·ªçi chuy·ªÉn ƒë·ªïi ƒë·ªÅu qua 'trung gian' l√† h·ªá th·∫≠p ph√¢n.**"
        }
    },
    {
        "id": 90,
        "category": "Chapter 2: Numbering Systems (H·ªá ƒë·∫øm)",
        "en": {
            "question": "In a positional number system, the value of a symbol is determined by what factor?",
            "options": [
                "A. The symbol itself only.",
                "B. The position of the symbol in the number string.",
                "C. The total number of symbols in the string.",
                "D. The base of the number system."
            ],
            "answer": "B. The position of the symbol in the number string.",
            "explanation": "The defining characteristic of a positional number system is that the contribution of a digit to the total value of the number depends on its place or position. For example, the '5' in '50' is different from the '5' in '5'. **Key takeaway: Positional system -> value depends on position.**"
        },
        "vi": {
            "question": "Trong m·ªôt h·ªá ƒë·∫øm v·ªã tr√≠ (Positional Number System), gi√° tr·ªã c·ªßa m·ªôt k√Ω hi·ªáu ƒë∆∞·ª£c quy·∫øt ƒë·ªãnh b·ªüi y·∫øu t·ªë n√†o?",
            "options": [
                "A. Ch·ªâ b·∫£n th√¢n k√Ω hi·ªáu ƒë√≥.",
                "B. V·ªã tr√≠ c·ªßa k√Ω hi·ªáu trong chu·ªói s·ªë.",
                "C. T·ªïng s·ªë c√°c k√Ω hi·ªáu trong chu·ªói.",
                "D. C∆° s·ªë c·ªßa h·ªá ƒë·∫øm."
            ],
            "answer": "B. V·ªã tr√≠ c·ªßa k√Ω hi·ªáu trong chu·ªói s·ªë.",
            "explanation": "T√†i li·ªáu (M·ª•c 2) ƒë·ªãnh nghƒ©a: 'In a positional system, the position of a symbol determines its value' (Trong h·ªá th·ªëng v·ªã tr√≠, v·ªã tr√≠ c·ªßa k√Ω hi·ªáu quy·∫øt ƒë·ªãnh gi√° tr·ªã c·ªßa n√≥). **M·∫πo ghi nh·ªõ: H·ªá v·ªã tr√≠ -> gi√° tr·ªã ph·ª• thu·ªôc v·ªã tr√≠.**"
        }
    },
    {
        "id": 91,
        "category": "Chapter 2: Numbering Systems (H·ªá ƒë·∫øm)",
        "en": {
            "question": "Where does the term 'Hexadecimal' originate from?",
            "options": [
                "A. Latin 'hexa' (six) and 'decem' (ten).",
                "B. Greek 'hex' (six) and Latin 'decem' (ten).",
                "C. Only from the Latin 'hexadecimalis'.",
                "D. From the name of the Greek mathematician Alex Hecimal."
            ],
            "answer": "B. Greek 'hex' (six) and Latin 'decem' (ten).",
            "explanation": "The term is a hybrid word. 'Hex' comes from the Greek word for six, and 'decem' is the Latin word for ten, combining to mean 'base sixteen'. **Key takeaway: Hex (Greek) + Decem (Latin).**"
        },
        "vi": {
            "question": "Thu·∫≠t ng·ªØ 'Hexadecimal' b·∫Øt ngu·ªìn t·ª´ ƒë√¢u?",
            "options": [
                "A. Ti·∫øng Latin 'hexa' (s√°u) v√† 'decem' (m∆∞·ªùi).",
                "B. Ti·∫øng Hy L·∫°p 'hex' (s√°u) v√† ti·∫øng Latin 'decem' (m∆∞·ªùi).",
                "C. Ch·ªâ t·ª´ ti·∫øng Latin 'hexadecimalis'.",
                "D. T·ª´ t√™n c·ªßa nh√† to√°n h·ªçc Hy L·∫°p Alex Hecimal."
            ],
            "answer": "B. Ti·∫øng Hy L·∫°p 'hex' (s√°u) v√† ti·∫øng Latin 'decem' (m∆∞·ªùi).",
            "explanation": "T√†i li·ªáu (M·ª•c 2.3) ghi r√µ: 'Derived from Greek hex (six) + Latin decem (ten)'. **M·∫πo ghi nh·ªõ: Hex (Hy L·∫°p) + Decem (Latin).**"
        }
    },
    {
        "id": 92,
        "category": "Chapter 3: Data Storage (L∆∞u tr·ªØ d·ªØ li·ªáu)",
        "en": {
            "question": "A byte consists of ___ bits.",
            "options": [
                "A. 2",
                "B. 4",
                "C. 8",
                "D. 16"
            ],
            "answer": "C. 8",
            "explanation": "A byte is the standard unit of digital information in computing and consists of 8 bits. **Key takeaway: 1 Byte = 8 Bits.**"
        },
        "vi": {
            "question": "M·ªôt byte bao g·ªìm ___ bit.",
            "options": [
                "A. 2",
                "B. 4",
                "C. 8",
                "D. 16"
            ],
            "answer": "C. 8",
            "explanation": "M·ªôt byte l√† ƒë∆°n v·ªã th√¥ng tin k·ªπ thu·∫≠t s·ªë ti√™u chu·∫©n trong m√°y t√≠nh v√† bao g·ªìm 8 bit. **M·∫πo ghi nh·ªõ: 1 Byte = 8 Bit.**"
        }
    },
    {
        "id": 93,
        "category": "Chapter 3: Data Storage (L∆∞u tr·ªØ d·ªØ li·ªáu)",
        "en": {
            "question": "How many symbols can be represented by a bit pattern with ten bits?",
            "options": [
                "A. 128",
                "B. 256",
                "C. 512",
                "D. 1024"
            ],
            "answer": "D. 1024",
            "explanation": "With 'n' bits, you can represent 2^n unique symbols or values. With 10 bits, you can represent 2^10 = 1024 symbols. **Key takeaway: n bits = 2^n symbols.**"
        },
        "vi": {
            "question": "C√≥ bao nhi√™u k√Ω hi·ªáu c√≥ th·ªÉ ƒë∆∞·ª£c bi·ªÉu di·ªÖn b·∫±ng m·ªôt m·∫´u bit c√≥ m∆∞·ªùi bit?",
            "options": [
                "A. 128",
                "B. 256",
                "C. 512",
                "D. 1024"
            ],
            "answer": "D. 1024",
            "explanation": "V·ªõi 'n' bit, b·∫°n c√≥ th·ªÉ bi·ªÉu di·ªÖn 2^n k√Ω hi·ªáu ho·∫∑c gi√° tr·ªã duy nh·∫•t. V·ªõi 10 bit, b·∫°n c√≥ th·ªÉ bi·ªÉu di·ªÖn 2^10 = 1024 k√Ω hi·ªáu. **M·∫πo ghi nh·ªõ: n bit = 2^n k√Ω hi·ªáu.**"
        }
    },
    {
        "id": 94,
        "category": "Chapter 3: Data Storage (L∆∞u tr·ªØ d·ªØ li·ªáu)",
        "en": {
            "question": "A 32-bit code called _______ represents symbols in all languages.",
            "options": [
                "A. ANSI",
                "B. Unicode",
                "C. EBCDIC",
                "D. Extended ASCII"
            ],
            "answer": "B. Unicode",
            "explanation": "Unicode is the modern international standard for encoding characters from virtually all writing systems. It can use up to 32 bits per character (in encodings like UTF-32). **Key takeaway: All languages = Unicode.**"
        },
        "vi": {
            "question": "M·ªôt m√£ 32-bit ƒë∆∞·ª£c g·ªçi l√† _______ bi·ªÉu di·ªÖn c√°c k√Ω hi·ªáu trong t·∫•t c·∫£ c√°c ng√¥n ng·ªØ.",
            "options": [
                "A. ANSI",
                "B. Unicode",
                "C. EBCDIC",
                "D. ASCII m·ªü r·ªông"
            ],
            "answer": "B. Unicode",
            "explanation": "Unicode l√† ti√™u chu·∫©n qu·ªëc t·∫ø hi·ªán ƒë·∫°i ƒë·ªÉ m√£ h√≥a c√°c k√Ω t·ª± t·ª´ h·∫ßu h·∫øt t·∫•t c·∫£ c√°c h·ªá th·ªëng ch·ªØ vi·∫øt. N√≥ c√≥ th·ªÉ s·ª≠ d·ª•ng t·ªõi 32 bit cho m·ªói k√Ω t·ª± (trong c√°c m√£ h√≥a nh∆∞ UTF-32). **M·∫πo ghi nh·ªõ: T·∫•t c·∫£ ng√¥n ng·ªØ = Unicode.**"
        }
    },
    {
        "id": 95,
        "category": "Chapter 3: Data Storage (L∆∞u tr·ªØ d·ªØ li·ªáu)",
        "en": {
            "question": "If the ASCII code for E is 1000101, then the ASCII code for e is ___.",
            "options": [
                "A. 1000110",
                "B. 1000111",
                "C. 0000110",
                "D. 1100101"
            ],
            "answer": "D. 1100101",
            "explanation": "In ASCII, the codes for lowercase letters are exactly 32 greater than their uppercase counterparts. In binary, this means the 6th bit (from the right, starting at 1) is changed from 0 to 1. 1000101 ('E') becomes 1100101 ('e'). **Key takeaway: Lowercase = Uppercase + 32 (flip the 6th bit).**"
        },
        "vi": {
            "question": "N·∫øu m√£ ASCII cho E l√† 1000101, th√¨ m√£ ASCII cho e l√† ___.",
            "options": [
                "A. 1000110",
                "B. 1000111",
                "C. 0000110",
                "D. 1100101"
            ],
            "answer": "D. 1100101",
            "explanation": "Trong ASCII, m√£ cho c√°c ch·ªØ c√°i th∆∞·ªùng l·ªõn h∆°n ƒë√∫ng 32 so v·ªõi c√°c ch·ªØ c√°i hoa t∆∞∆°ng ·ª©ng. Trong h·ªá nh·ªã ph√¢n, ƒëi·ªÅu n√†y c√≥ nghƒ©a l√† bit th·ª© 6 (t·ª´ ph·∫£i sang, b·∫Øt ƒë·∫ßu t·ª´ 1) ƒë∆∞·ª£c ƒë·ªïi t·ª´ 0 th√†nh 1. 1000101 ('E') tr·ªü th√†nh 1100101 ('e'). **M·∫πo ghi nh·ªõ: Ch·ªØ th∆∞·ªùng = Ch·ªØ hoa + 32 (l·∫≠t bit th·ª© 6).**"
        }
    },
    {
        "id": 96,
        "category": "Chapter 3: Data Storage (L∆∞u tr·ªØ d·ªØ li·ªáu)",
        "en": {
            "question": "Which of the following is the expansion of EBCDIC?",
            "options": [
                "A. Extended bit comparable to digital interface for computer",
                "B. Extended bootable computerised digital infrared calculator",
                "C. Extended binary coded decimal interchange code",
                "D. Extended binary coded decimal information code"
            ],
            "answer": "C. Extended binary coded decimal interchange code",
            "explanation": "EBCDIC is an 8-bit character encoding used mainly on IBM mainframe and IBM midrange computer operating systems. **Key takeaway: EBCDIC = Extended Binary Coded Decimal Interchange Code.**"
        },
        "vi": {
            "question": "Vi·∫øt t·∫Øt n√†o sau ƒë√¢y l√† c·ªßa EBCDIC?",
            "options": [
                "A. Extended bit comparable to digital interface for computer",
                "B. Extended bootable computerised digital infrared calculator",
                "C. Extended binary coded decimal interchange code",
                "D. Extended binary coded decimal information code"
            ],
            "answer": "C. Extended binary coded decimal interchange code",
            "explanation": "EBCDIC l√† m·ªôt m√£ h√≥a k√Ω t·ª± 8-bit ƒë∆∞·ª£c s·ª≠ d·ª•ng ch·ªß y·∫øu tr√™n c√°c h·ªá ƒëi·ªÅu h√†nh m√°y t√≠nh l·ªõn c·ªßa IBM v√† m√°y t√≠nh t·∫ßm trung c·ªßa IBM. **M·∫πo ghi nh·ªõ: EBCDIC = Extended Binary Coded Decimal Interchange Code.**"
        }
    },
    {
        "id": 97,
        "category": "Chapter 3: Data Storage (L∆∞u tr·ªØ d·ªØ li·ªáu)",
        "en": {
            "question": "The _______ method of integer representation is the most common method for storing integers in computer memory.",
            "options": [
                "A. Sign-and-magnitude",
                "B. One's complement",
                "C. Two's complement",
                "D. Unsigned integers"
            ],
            "answer": "C. Two's complement",
            "explanation": "Two's complement is universally used in modern computers for representing signed integers. It simplifies arithmetic hardware because subtraction can be performed by adding the two's complement of the number. **Key takeaway: Signed Integers = Two's Complement.**"
        },
        "vi": {
            "question": "Ph∆∞∆°ng ph√°p bi·ªÉu di·ªÖn s·ªë nguy√™n _______ l√† ph∆∞∆°ng ph√°p ph·ªï bi·∫øn nh·∫•t ƒë·ªÉ l∆∞u tr·ªØ s·ªë nguy√™n trong b·ªô nh·ªõ m√°y t√≠nh.",
            "options": [
                "A. D·∫•u v√† ƒë·ªô l·ªõn",
                "B. B√π m·ªôt",
                "C. B√π hai",
                "D. S·ªë nguy√™n kh√¥ng d·∫•u"
            ],
            "answer": "C. B√π hai",
            "explanation": "B√π hai ƒë∆∞·ª£c s·ª≠ d·ª•ng ph·ªï bi·∫øn trong c√°c m√°y t√≠nh hi·ªán ƒë·∫°i ƒë·ªÉ bi·ªÉu di·ªÖn s·ªë nguy√™n c√≥ d·∫•u. N√≥ ƒë∆°n gi·∫£n h√≥a ph·∫ßn c·ª©ng s·ªë h·ªçc v√¨ ph√©p tr·ª´ c√≥ th·ªÉ ƒë∆∞·ª£c th·ª±c hi·ªán b·∫±ng c√°ch c·ªông v·ªõi s·ªë b√π hai c·ªßa s·ªë ƒë√≥. **M·∫πo ghi nh·ªõ: S·ªë nguy√™n c√≥ d·∫•u = B√π hai.**"
        }
    },
    {
        "id": 98,
        "category": "Chapter 3: Data Storage (L∆∞u tr·ªØ d·ªØ li·ªáu)",
        "en": {
            "question": "In two's complement addition, if there is a final carry after the left most column addition, ___.",
            "options": [
                "A. Add it to the right most column",
                "B. Add it to the left most column",
                "C. Discard it",
                "D. Increase the bit length"
            ],
            "answer": "C. Discard it",
            "explanation": "A key property of two's complement arithmetic is that any carry-out from the most significant bit (the sign bit) is simply discarded. The result within the given bit length is correct, assuming no overflow occurred. **Key takeaway: Two's complement carry-out is discarded.**"
        },
        "vi": {
            "question": "Trong ph√©p c·ªông b√π hai, n·∫øu c√≥ m·ªôt s·ªë nh·ªõ cu·ªëi c√πng sau khi c·ªông c·ªôt ngo√†i c√πng b√™n tr√°i, ___.",
            "options": [
                "A. C·ªông n√≥ v√†o c·ªôt ngo√†i c√πng b√™n ph·∫£i",
                "B. C·ªông n√≥ v√†o c·ªôt ngo√†i c√πng b√™n tr√°i",
                "C. B·ªè n√≥ ƒëi",
                "D. TƒÉng ƒë·ªô d√†i bit"
            ],
            "answer": "C. B·ªè n√≥ ƒëi",
            "explanation": "M·ªôt thu·ªôc t√≠nh ch√≠nh c·ªßa s·ªë h·ªçc b√π hai l√† b·∫•t k·ª≥ s·ªë nh·ªõ n√†o t·ª´ bit c√≥ tr·ªçng s·ªë cao nh·∫•t (bit d·∫•u) ƒë·ªÅu b·ªã b·ªè ƒëi. K·∫øt qu·∫£ trong ƒë·ªô d√†i bit ƒë√£ cho l√† ch√≠nh x√°c, gi·∫£ s·ª≠ kh√¥ng c√≥ tr√†n s·ªë. **M·∫πo ghi nh·ªõ: S·ªë nh·ªõ c·ªßa ph√©p c·ªông b√π hai b·ªã b·ªè ƒëi.**"
        }
    },
    {
        "id": 99,
        "category": "Chapter 3: Data Storage (L∆∞u tr·ªØ d·ªØ li·ªáu)",
        "en": {
            "question": "For an 8-bit allocation, the smallest decimal number that can be represented in two's complement form is ___.",
            "options": [
                "A. -8",
                "B. -127",
                "C. -128",
                "D. -256"
            ],
            "answer": "C. -128",
            "explanation": "The range for an n-bit two's complement number is from -2^(n-1) to 2^(n-1) - 1. For 8 bits, this is from -2^7 to 2^7 - 1, which is -128 to 127. **Key takeaway: 8-bit two's complement range is -128 to 127.**"
        },
        "vi": {
            "question": "V·ªõi ph√¢n b·ªï 8-bit, s·ªë th·∫≠p ph√¢n nh·ªè nh·∫•t c√≥ th·ªÉ ƒë∆∞·ª£c bi·ªÉu di·ªÖn ·ªü d·∫°ng b√π hai l√† ___.",
            "options": [
                "A. -8",
                "B. -127",
                "C. -128",
                "D. -256"
            ],
            "answer": "C. -128",
            "explanation": "Ph·∫°m vi cho m·ªôt s·ªë b√π hai n-bit l√† t·ª´ -2^(n-1) ƒë·∫øn 2^(n-1) - 1. ƒê·ªëi v·ªõi 8 bit, ph·∫°m vi n√†y l√† t·ª´ -2^7 ƒë·∫øn 2^7 - 1, t·ª©c l√† -128 ƒë·∫øn 127. **M·∫πo ghi nh·ªõ: Ph·∫°m vi b√π hai 8-bit l√† -128 ƒë·∫øn 127.**"
        }
    },
    {
        "id": 100,
        "category": "Chapter 3: Data Storage (L∆∞u tr·ªØ d·ªØ li·ªáu)",
        "en": {
            "question": "For an 8-bit allocation, the largest decimal number that can be represented in two's complement form is ___.",
            "options": [
                "A. 8",
                "B. 127",
                "C. 128",
                "D. 256"
            ],
            "answer": "B. 127",
            "explanation": "The range for an n-bit two's complement number is from -2^(n-1) to 2^(n-1) - 1. For 8 bits, this is from -128 to 2^7 - 1, which is -128 to 127. **Key takeaway: 8-bit two's complement range is -128 to 127.**"
        },
        "vi": {
            "question": "V·ªõi ph√¢n b·ªï 8-bit, s·ªë th·∫≠p ph√¢n l·ªõn nh·∫•t c√≥ th·ªÉ ƒë∆∞·ª£c bi·ªÉu di·ªÖn ·ªü d·∫°ng b√π hai l√† ___.",
            "options": [
                "A. 8",
                "B. 127",
                "C. 128",
                "D. 256"
            ],
            "answer": "B. 127",
            "explanation": "Ph·∫°m vi cho m·ªôt s·ªë b√π hai n-bit l√† t·ª´ -2^(n-1) ƒë·∫øn 2^(n-1) - 1. ƒê·ªëi v·ªõi 8 bit, ph·∫°m vi n√†y l√† t·ª´ -128 ƒë·∫øn 2^7 - 1, t·ª©c l√† -128 ƒë·∫øn 127. **M·∫πo ghi nh·ªõ: Ph·∫°m vi b√π hai 8-bit l√† -128 ƒë·∫øn 127.**"
        }
    },
    {
        "id": 101,
        "category": "Chapter 3: Data Storage (L∆∞u tr·ªØ d·ªØ li·ªáu)",
        "en": {
            "question": "In two's complement representation with a 4-bit allocation, we get ___ when we add 5 to 5.",
            "options": [
                "A. -5",
                "B. -6",
                "C. -7",
                "D. 10"
            ],
            "answer": "B. -6",
            "explanation": "In 4-bit two's complement: 5 is 0101. Adding them: 0101 + 0101 = 1010. The result has a sign bit of 1, so it's negative. To find its value, take the two's complement of 1010: invert (0101) and add 1 (0110), which is 6. So, 1010 represents -6. This is an overflow because adding two positive numbers resulted in a negative number. **Key takeaway: Watch for overflow when the sign bit changes unexpectedly.**"
        },
        "vi": {
            "question": "Trong bi·ªÉu di·ªÖn b√π hai v·ªõi ph√¢n b·ªï 4-bit, ch√∫ng ta nh·∫≠n ƒë∆∞·ª£c ___ khi c·ªông 5 v·ªõi 5.",
            "options": [
                "A. -5",
                "B. -6",
                "C. -7",
                "D. 10"
            ],
            "answer": "B. -6",
            "explanation": "Trong b√π hai 4-bit: 5 l√† 0101. C·ªông ch√∫ng l·∫°i: 0101 + 0101 = 1010. K·∫øt qu·∫£ c√≥ bit d·∫•u l√† 1, n√™n n√≥ l√† s·ªë √¢m. ƒê·ªÉ t√¨m gi√° tr·ªã, l·∫•y b√π hai c·ªßa 1010: ƒë·∫£o bit (0101) v√† c·ªông 1 (0110), t·ª©c l√† 6. V·∫≠y, 1010 bi·ªÉu di·ªÖn -6. ƒê√¢y l√† m·ªôt tr∆∞·ªùng h·ª£p tr√†n s·ªë v√¨ c·ªông hai s·ªë d∆∞∆°ng l·∫°i cho ra m·ªôt s·ªë √¢m. **M·∫πo ghi nh·ªõ: C·∫©n th·∫≠n v·ªõi tr√†n s·ªë khi bit d·∫•u thay ƒë·ªïi b·∫•t ng·ªù.**"
        }
    },
    {
        "id": 102,
        "category": "Chapter 3: Data Storage (L∆∞u tr·ªØ d·ªØ li·ªáu)",
        "en": {
            "question": "If the exponent in Excess_127 is binary 10000101, the exponent in decimal is ___.",
            "options": [
                "A. 6",
                "B. 7",
                "C. 8",
                "D. 9"
            ],
            "answer": "A. 6",
            "explanation": "First, convert the binary exponent to decimal: 10000101‚ÇÇ = 128 + 4 + 1 = 133. In Excess-127 representation, the actual exponent is the stored value minus the bias (127). So, Actual Exponent = 133 - 127 = 6. **Key takeaway: Actual Exponent = Stored Value - Bias.**"
        },
        "vi": {
            "question": "N·∫øu ph·∫ßn m≈© trong bi·ªÉu di·ªÖn Excess_127 l√† nh·ªã ph√¢n 10000101, th√¨ ph·∫ßn m≈© ·ªü d·∫°ng th·∫≠p ph√¢n l√† ___.",
            "options": [
                "A. 6",
                "B. 7",
                "C. 8",
                "D. 9"
            ],
            "answer": "A. 6",
            "explanation": "ƒê·∫ßu ti√™n, chuy·ªÉn ƒë·ªïi ph·∫ßn m≈© nh·ªã ph√¢n sang th·∫≠p ph√¢n: 10000101‚ÇÇ = 128 + 4 + 1 = 133. Trong bi·ªÉu di·ªÖn Excess-127, ph·∫ßn m≈© th·ª±c t·∫ø l√† gi√° tr·ªã ƒë∆∞·ª£c l∆∞u tr·ªØ tr·ª´ ƒëi ƒë·ªô l·ªách (127). V√¨ v·∫≠y, M≈© th·ª±c t·∫ø = 133 - 127 = 6. **M·∫πo ghi nh·ªõ: M≈© th·ª±c t·∫ø = Gi√° tr·ªã l∆∞u tr·ªØ - ƒê·ªô l·ªách.**"
        }
    },
    {
        "id": 103,
        "category": "Chapter 3: Data Storage (L∆∞u tr·ªØ d·ªØ li·ªáu)",
        "en": {
            "question": "Use a circular right shift operation on the bit pattern 1001 1000",
            "options": [
                "A. 0100 1100",
                "B. 0011 0001",
                "C. 1001 1001",
                "D. 0100 1100"
            ],
            "answer": "D. 0100 1100",
            "explanation": "In a circular right shift (rotate right), the rightmost bit is moved to the leftmost position, and all other bits shift one position to the right. So, the '0' at the end of 1001 1000 moves to the front, resulting in 0100 1100. **Key takeaway: Circular shift = bit wraps around.**"
        },
        "vi": {
            "question": "S·ª≠ d·ª•ng ph√©p d·ªãch ph·∫£i v√≤ng (circular right shift) tr√™n m·∫´u bit 1001 1000",
            "options": [
                "A. 0100 1100",
                "B. 0011 0001",
                "C. 1001 1001",
                "D. 0100 1100"
            ],
            "answer": "D. 0100 1100",
            "explanation": "Trong ph√©p d·ªãch ph·∫£i v√≤ng (xoay ph·∫£i), bit ngo√†i c√πng b√™n ph·∫£i ƒë∆∞·ª£c chuy·ªÉn ƒë·∫øn v·ªã tr√≠ ngo√†i c√πng b√™n tr√°i, v√† t·∫•t c·∫£ c√°c bit kh√°c d·ªãch sang ph·∫£i m·ªôt v·ªã tr√≠. V√¨ v·∫≠y, bit '0' ·ªü cu·ªëi 1001 1000 s·∫Ω chuy·ªÉn l√™n ƒë·∫ßu, t·∫°o th√†nh 0100 1100. **M·∫πo ghi nh·ªõ: D·ªãch v√≤ng = bit quay v√≤ng.**"
        }
    },
    {
        "id": 104,
        "category": "Chapter 3: Data Storage (L∆∞u tr·ªØ d·ªØ li·ªáu)",
        "en": {
            "question": "Use a circular left shift operation on the bit pattern 1001 1000",
            "options": [
                "A. 0001 1001",
                "B. 0011 0001",
                "C. 1001 1001",
                "D. 1001 1000"
            ],
            "answer": "B. 0011 0001",
            "explanation": "In a circular left shift (rotate left), the leftmost bit is moved to the rightmost position. The '1' from the front of 1001 1000 moves to the end. The remaining bits 001 1000 shift left, becoming 011 000. Appending the '1' gives 0110001. The options seem incorrect. The correct answer should be `00110001`. Let's assume option B is a typo and should be this. **Key takeaway: Circular left shift = leftmost bit wraps around to the right.**"
        },
        "vi": {
            "question": "S·ª≠ d·ª•ng ph√©p d·ªãch tr√°i v√≤ng (circular left shift) tr√™n m·∫´u bit 1001 1000",
            "options": [
                "A. 0001 1001",
                "B. 0011 0001",
                "C. 1001 1001",
                "D. 1001 1000"
            ],
            "answer": "B. 0011 0001",
            "explanation": "Trong ph√©p d·ªãch tr√°i v√≤ng (xoay tr√°i), bit ngo√†i c√πng b√™n tr√°i ƒë∆∞·ª£c chuy·ªÉn ƒë·∫øn v·ªã tr√≠ ngo√†i c√πng b√™n ph·∫£i. Bit '1' t·ª´ ƒë·∫ßu c·ªßa 1001 1000 s·∫Ω chuy·ªÉn xu·ªëng cu·ªëi. C√°c bit c√≤n l·∫°i 001 1000 d·ªãch sang tr√°i, tr·ªü th√†nh 011 000. N·ªëi bit '1' v√†o cu·ªëi ta ƒë∆∞·ª£c 0110001. C√°c l·ª±a ch·ªçn c√≥ v·∫ª kh√¥ng ch√≠nh x√°c. ƒê√°p √°n ƒë√∫ng ph·∫£i l√† `00110001`. Gi·∫£ s·ª≠ l·ª±a ch·ªçn B l√† ƒë√°p √°n ƒë√∫ng. **M·∫πo ghi nh·ªõ: D·ªãch tr√°i v√≤ng = bit ngo√†i c√πng b√™n tr√°i quay v√≤ng sang ph·∫£i.**"
        }
    },
    {
        "id": 105,
        "category": "Chapter 3: Data Storage (L∆∞u tr·ªØ d·ªØ li·ªáu)",
        "en": {
            "question": "Use a arithmetic right shift operation on the bit pattern 1001 1000",
            "options": [
                "A. 0100 1100",
                "B. 1100 1100",
                "C. 1101 1001",
                "D. 1001 1000"
            ],
            "answer": "B. 1100 1100",
            "explanation": "An arithmetic right shift is used for signed numbers. It shifts all bits to the right, but the leftmost bit (the sign bit) is copied into the new leftmost position to preserve the number's sign. Here, the sign bit is '1', so it's copied. 1001 1000 becomes 1100 1100. **Key takeaway: Arithmetic right shift preserves the sign bit.**"
        },
        "vi": {
            "question": "S·ª≠ d·ª•ng ph√©p d·ªãch ph·∫£i s·ªë h·ªçc (arithmetic right shift) tr√™n m·∫´u bit 1001 1000",
            "options": [
                "A. 0100 1100",
                "B. 1100 1100",
                "C. 1101 1001",
                "D. 1001 1000"
            ],
            "answer": "B. 1100 1100",
            "explanation": "D·ªãch ph·∫£i s·ªë h·ªçc ƒë∆∞·ª£c s·ª≠ d·ª•ng cho c√°c s·ªë c√≥ d·∫•u. N√≥ d·ªãch t·∫•t c·∫£ c√°c bit sang ph·∫£i, nh∆∞ng bit ngo√†i c√πng b√™n tr√°i (bit d·∫•u) ƒë∆∞·ª£c sao ch√©p v√†o v·ªã tr√≠ ngo√†i c√πng b√™n tr√°i m·ªõi ƒë·ªÉ b·∫£o to√†n d·∫•u c·ªßa s·ªë. ·ªû ƒë√¢y, bit d·∫•u l√† '1', v√¨ v·∫≠y n√≥ ƒë∆∞·ª£c sao ch√©p. 1001 1000 tr·ªü th√†nh 1100 1100. **M·∫πo ghi nh·ªõ: D·ªãch ph·∫£i s·ªë h·ªçc b·∫£o to√†n bit d·∫•u.**"
        }
    },
    {
        "id": 106,
        "category": "Chapter 3: Data Storage (L∆∞u tr·ªØ d·ªØ li·ªáu)",
        "en": {
            "question": "Use a simple left shift operation on the bit pattern 1001 1000",
            "options": [
                "A. 0001 1001",
                "B. 0001 1010",
                "C. 0011 0000",
                "D. 0011 0001"
            ],
            "answer": "C. 0011 0000",
            "explanation": "A simple (or logical) left shift moves all bits to the left, discards the leftmost bit, and fills the rightmost position with a '0'. So, 1001 1000 becomes 0011 0000. **Key takeaway: Logical left shift = discard left, add 0 to right.**"
        },
        "vi": {
            "question": "S·ª≠ d·ª•ng ph√©p d·ªãch tr√°i ƒë∆°n gi·∫£n (simple left shift) tr√™n m·∫´u bit 1001 1000",
            "options": [
                "A. 0001 1001",
                "B. 0001 1010",
                "C. 0011 0000",
                "D. 0011 0001"
            ],
            "answer": "C. 0011 0000",
            "explanation": "Ph√©p d·ªãch tr√°i ƒë∆°n gi·∫£n (ho·∫∑c logic) di chuy·ªÉn t·∫•t c·∫£ c√°c bit sang tr√°i, lo·∫°i b·ªè bit ngo√†i c√πng b√™n tr√°i, v√† ƒëi·ªÅn v√†o v·ªã tr√≠ ngo√†i c√πng b√™n ph·∫£i b·∫±ng m·ªôt bit '0'. V√¨ v·∫≠y, 1001 1000 tr·ªü th√†nh 0011 0000. **M·∫πo ghi nh·ªõ: D·ªãch tr√°i logic = b·ªè tr√°i, th√™m 0 v√†o ph·∫£i.**"
        }
    },
    {
        "id": 107,
        "category": "Chapter 3: Data Storage (L∆∞u tr·ªØ d·ªØ li·ªáu)",
        "en": {
            "question": "Use a simple right shift operation on the bit pattern 1001 1000.",
            "options": [
                "A. 1001 1001",
                "B. 1001 1000",
                "C. 0100 1101",
                "D. 0100 1100"
            ],
            "answer": "D. 0100 1100",
            "explanation": "A simple (or logical) right shift moves all bits to the right, discards the rightmost bit, and fills the leftmost position with a '0'. So, 1001 1000 becomes 0100 1100. **Key takeaway: Logical right shift = discard right, add 0 to left.**"
        },
        "vi": {
            "question": "S·ª≠ d·ª•ng ph√©p d·ªãch ph·∫£i ƒë∆°n gi·∫£n (simple right shift) tr√™n m·∫´u bit 1001 1000.",
            "options": [
                "A. 1001 1001",
                "B. 1001 1000",
                "C. 0100 1101",
                "D. 0100 1100"
            ],
            "answer": "D. 0100 1100",
            "explanation": "Ph√©p d·ªãch ph·∫£i ƒë∆°n gi·∫£n (ho·∫∑c logic) di chuy·ªÉn t·∫•t c·∫£ c√°c bit sang ph·∫£i, lo·∫°i b·ªè bit ngo√†i c√πng b√™n ph·∫£i, v√† ƒëi·ªÅn v√†o v·ªã tr√≠ ngo√†i c√πng b√™n tr√°i b·∫±ng m·ªôt bit '0'. V√¨ v·∫≠y, 1001 1000 tr·ªü th√†nh 0100 1100. **M·∫πo ghi nh·ªõ: D·ªãch ph·∫£i logic = b·ªè ph·∫£i, th√™m 0 v√†o tr√°i.**"
        }
    },
    {
        "id": 108,
        "category": "Chapter 3: Data Storage (L∆∞u tr·ªØ d·ªØ li·ªáu)",
        "en": {
            "question": "Assume memory location that can only hold four bits. What is the result, if we have stored the integer 11 in a memory location and then try to add 9 to the unsigned integer?",
            "options": [
                "A. 4",
                "B. 9",
                "C. 11",
                "D. 20"
            ],
            "answer": "A. 4",
            "explanation": "In 4-bit unsigned binary: 11 is 1011, and 9 is 1001. Adding them: 1011 + 1001 = 10100. Since the memory location can only hold 4 bits, the leftmost '1' (the carry-out bit) is discarded due to overflow. The remaining 4 bits are 0100, which is 4 in decimal. **Key takeaway: In fixed-bit arithmetic, overflow bits are discarded.**"
        },
        "vi": {
            "question": "Gi·∫£ s·ª≠ m·ªôt v·ªã tr√≠ b·ªô nh·ªõ ch·ªâ c√≥ th·ªÉ ch·ª©a b·ªën bit. K·∫øt qu·∫£ s·∫Ω l√† g√¨, n·∫øu ch√∫ng ta ƒë√£ l∆∞u s·ªë nguy√™n 11 trong m·ªôt v·ªã tr√≠ b·ªô nh·ªõ v√† sau ƒë√≥ c·ªë g·∫Øng c·ªông 9 v√†o s·ªë nguy√™n kh√¥ng d·∫•u ƒë√≥?",
            "options": [
                "A. 4",
                "B. 9",
                "C. 11",
                "D. 20"
            ],
            "answer": "A. 4",
            "explanation": "Trong h·ªá nh·ªã ph√¢n kh√¥ng d·∫•u 4-bit: 11 l√† 1011, v√† 9 l√† 1001. C·ªông ch√∫ng l·∫°i: 1011 + 1001 = 10100. V√¨ v·ªã tr√≠ b·ªô nh·ªõ ch·ªâ c√≥ th·ªÉ ch·ª©a 4 bit, bit '1' ngo√†i c√πng b√™n tr√°i (bit nh·ªõ ra) b·ªã lo·∫°i b·ªè do tr√†n s·ªë. 4 bit c√≤n l·∫°i l√† 0100, t·ª©c l√† 4 trong h·ªá th·∫≠p ph√¢n. **M·∫πo ghi nh·ªõ: Trong s·ªë h·ªçc bit c·ªë ƒë·ªãnh, c√°c bit tr√†n s·∫Ω b·ªã lo·∫°i b·ªè.**"
        }
    },
    {
        "id": 109,
        "category": "Chapter 3: Data Storage (L∆∞u tr·ªØ d·ªØ li·ªáu)",
        "en": {
            "question": "What is the number of bit patterns provided by a 7-bit code?",
            "options": [
                "A. 256",
                "B. 128",
                "C. 64",
                "D. 512"
            ],
            "answer": "B. 128",
            "explanation": "With 'n' bits, you can create 2^n unique bit patterns. For a 7-bit code, the number of patterns is 2^7 = 128. **Key takeaway: n bits = 2^n patterns.**"
        },
        "vi": {
            "question": "S·ªë l∆∞·ª£ng m·∫´u bit ƒë∆∞·ª£c cung c·∫•p b·ªüi m·ªôt m√£ 7-bit l√† bao nhi√™u?",
            "options": [
                "A. 256",
                "B. 128",
                "C. 64",
                "D. 512"
            ],
            "answer": "B. 128",
            "explanation": "V·ªõi 'n' bit, b·∫°n c√≥ th·ªÉ t·∫°o ra 2^n m·∫´u bit duy nh·∫•t. ƒê·ªëi v·ªõi m·ªôt m√£ 7-bit, s·ªë l∆∞·ª£ng m·∫´u l√† 2^7 = 128. **M·∫πo ghi nh·ªõ: n bit = 2^n m·∫´u.**"
        }
    },
    {
        "id": 110,
        "category": "Chapter 3: Data Storage (L∆∞u tr·ªØ d·ªØ li·ªáu)",
        "en": {
            "question": "EBCDIC can code up to how many different characters?",
            "options": [
                "A. 8",
                "B. 16",
                "C. 32",
                "D. 64",
                "E. 256"
            ],
            "answer": "E. 256",
            "explanation": "EBCDIC (Extended Binary Coded Decimal Interchange Code) is an 8-bit character encoding. With 8 bits, it can represent 2^8 = 256 different characters. **Key takeaway: EBCDIC = 8-bit = 256 characters.**"
        },
        "vi": {
            "question": "EBCDIC c√≥ th·ªÉ m√£ h√≥a t·ªëi ƒëa bao nhi√™u k√Ω t·ª± kh√°c nhau?",
            "options": [
                "A. 8",
                "B. 16",
                "C. 32",
                "D. 64",
                "E. 256"
            ],
            "answer": "E. 256",
            "explanation": "EBCDIC (Extended Binary Coded Decimal Interchange Code) l√† m·ªôt m√£ h√≥a k√Ω t·ª± 8-bit. V·ªõi 8 bit, n√≥ c√≥ th·ªÉ bi·ªÉu di·ªÖn 2^8 = 256 k√Ω t·ª± kh√°c nhau. **M·∫πo ghi nh·ªõ: EBCDIC = 8-bit = 256 k√Ω t·ª±.**"
        }
    },
    {
        "id": 111,
        "category": "Chapter 3: Data Storage (L∆∞u tr·ªØ d·ªØ li·ªáu)",
        "en": {
            "question": "What is the main advantage of using Unicode over Extended ASCII?",
            "options": [
                "A. Unicode uses fewer bits per character.",
                "B. Unicode supports a vast range of languages and special symbols.",
                "C. Unicode is used only for European languages.",
                "D. Unicode is a subset of ASCII."
            ],
            "answer": "B. Unicode supports a vast range of languages and special symbols.",
            "explanation": "Extended ASCII is limited to 256 characters (8 bits), which is insufficient for all the world's languages. Unicode can use up to 32 bits, allowing it to represent characters from virtually every writing system. **Key takeaway: Unicode = Multi-language, multi-symbol support.**"
        },
        "vi": {
            "question": "L·ª£i th·∫ø ch√≠nh c·ªßa vi·ªác s·ª≠ d·ª•ng m√£ Unicode so v·ªõi ASCII m·ªü r·ªông (Extended ASCII) l√† g√¨?",
            "options": [
                "A. Unicode s·ª≠ d·ª•ng √≠t bit h∆°n cho m·ªói k√Ω t·ª±.",
                "B. Unicode h·ªó tr·ª£ nhi·ªÅu ng√¥n ng·ªØ v√† c√°c k√Ω hi·ªáu ƒë·∫∑c bi·ªát.",
                "C. Unicode ch·ªâ ƒë∆∞·ª£c d√πng cho c√°c ng√¥n ng·ªØ ch√¢u √Çu.",
                "D. Unicode l√† m·ªôt t·∫≠p con c·ªßa ASCII."
            ],
            "answer": "B. Unicode h·ªó tr·ª£ nhi·ªÅu ng√¥n ng·ªØ v√† c√°c k√Ω hi·ªáu ƒë·∫∑c bi·ªát.",
            "explanation": "T√†i li·ªáu (M·ª•c 3.1) m√¥ t·∫£ Unicode 'uses up to 32 bits, supporting multiple languages and special symbols', trong khi ASCII ch·ªâ c√≥ 7 ho·∫∑c 8 bit, h·∫°n ch·∫ø s·ªë l∆∞·ª£ng k√Ω t·ª±. **M·∫πo ghi nh·ªõ: Unicode = ƒêa ng√¥n ng·ªØ, ƒëa k√Ω hi·ªáu.**"
        }
    },
    {
        "id": 112,
        "category": "Chapter 3: Data Storage (L∆∞u tr·ªØ d·ªØ li·ªáu)",
        "en": {
            "question": "In the process of digitizing audio, which step is responsible for rounding the value of each sample to the nearest integer?",
            "options": [
                "A. Sampling.",
                "B. Encoding.",
                "C. Quantization.",
                "D. Compression."
            ],
            "answer": "C. Quantization.",
            "explanation": "After sampling the analog wave at discrete intervals, quantization assigns a numerical (integer) value to each sample's amplitude. This process involves rounding the measured amplitude to the nearest available level. **Key takeaway: Quantization = rounding the sample value.**"
        },
        "vi": {
            "question": "Trong qu√° tr√¨nh s·ªë h√≥a √¢m thanh, b∆∞·ªõc n√†o ch·ªãu tr√°ch nhi·ªám l√†m tr√≤n gi√° tr·ªã c·ªßa m·ªói m·∫´u ƒëo ƒë∆∞·ª£c ƒë·∫øn s·ªë nguy√™n g·∫ßn nh·∫•t?",
            "options": [
                "A. Sampling (L·∫•y m·∫´u).",
                "B. Encoding (M√£ h√≥a).",
                "C. Quantization (L∆∞·ª£ng t·ª≠ h√≥a).",
                "D. Compression (N√©n)."
            ],
            "answer": "C. Quantization (L∆∞·ª£ng t·ª≠ h√≥a).",
            "explanation": "T√†i li·ªáu (M·ª•c 3.2) ƒë·ªãnh nghƒ©a Quantization l√† 'round each measured sample to the nearest integer value' (l√†m tr√≤n m·ªói m·∫´u ƒëo ƒë∆∞·ª£c ƒë·∫øn gi√° tr·ªã s·ªë nguy√™n g·∫ßn nh·∫•t). **M·∫πo ghi nh·ªõ: Quantization = l√†m tr√≤n gi√° tr·ªã m·∫´u.**"
        }
    },
    {
        "id": 113,
        "category": "Chapter 3: Data Storage (L∆∞u tr·ªØ d·ªØ li·ªáu)",
        "en": {
            "question": "What is the primary advantage of Vector Graphics compared to Raster Graphics?",
            "options": [
                "A. More realistic color reproduction for photographs.",
                "B. Smaller file sizes and scalability without loss of quality.",
                "C. Ease of editing individual pixels.",
                "D. Supported by more software."
            ],
            "answer": "B. Smaller file sizes and scalability without loss of quality.",
            "explanation": "Vector graphics are defined by mathematical equations (lines, curves), not pixels. This means they can be scaled to any size without becoming pixelated or blurry, and they typically have smaller file sizes than high-resolution raster images. **Key takeaway: Vector = Scales perfectly, no quality loss.**"
        },
        "vi": {
            "question": "∆Øu ƒëi·ªÉm ch√≠nh c·ªßa ƒë·ªì h·ªça vector (Vector Graphics) so v·ªõi ƒë·ªì h·ªça raster (Raster Graphics) l√† g√¨?",
            "options": [
                "A. T√°i t·∫°o m√†u s·∫Øc trung th·ª±c h∆°n cho ·∫£nh ch·ª•p.",
                "B. K√≠ch th∆∞·ªõc t·ªáp nh·ªè h∆°n v√† c√≥ th·ªÉ thay ƒë·ªïi k√≠ch th∆∞·ªõc m√† kh√¥ng l√†m gi·∫£m ch·∫•t l∆∞·ª£ng.",
                "C. D·ªÖ d√†ng ch·ªânh s·ª≠a t·ª´ng pixel ri√™ng l·∫ª.",
                "D. ƒê∆∞·ª£c h·ªó tr·ª£ b·ªüi nhi·ªÅu ph·∫ßn m·ªÅm h∆°n."
            ],
            "answer": "B. K√≠ch th∆∞·ªõc t·ªáp nh·ªè h∆°n v√† c√≥ th·ªÉ thay ƒë·ªïi k√≠ch th∆∞·ªõc m√† kh√¥ng l√†m gi·∫£m ch·∫•t l∆∞·ª£ng.",
            "explanation": "T√†i li·ªáu (M·ª•c 3.3.2) n√™u r√µ: 'File sizes are smaller and images can be resized without losing quality' (K√≠ch th∆∞·ªõc t·ªáp nh·ªè h∆°n v√† ·∫£nh c√≥ th·ªÉ thay ƒë·ªïi k√≠ch th∆∞·ªõc m√† kh√¥ng b·ªã m·ªù). **M·∫πo ghi nh·ªõ: Vector = co gi√£n v√¥ t∆∞, kh√¥ng v·ª° ·∫£nh.**"
        }
    },
    {
        "id": 114,
        "category": "Chapter 3: Data Storage (L∆∞u tr·ªØ d·ªØ li·ªáu)",
        "en": {
            "question": "Which logical operation results in 0 if both input bits are identical (both 0 or both 1)?",
            "options": [
                "A. AND.",
                "B. OR.",
                "C. NOT.",
                "D. XOR (Exclusive OR)."
            ],
            "answer": "D. XOR (Exclusive OR).",
            "explanation": "The XOR operation outputs 1 only if the inputs are different. If the inputs are the same (0 and 0, or 1 and 1), the output is 0. **Key takeaway: XOR = 1 if different, 0 if same.**"
        },
        "vi": {
            "question": "Ph√©p to√°n logic n√†o s·∫Ω cho k·∫øt qu·∫£ l√† 0 n·∫øu c·∫£ hai bit ƒë·∫ßu v√†o gi·ªëng h·ªát nhau (c√πng l√† 0 ho·∫∑c c√πng l√† 1)?",
            "options": [
                "A. AND.",
                "B. OR.",
                "C. NOT.",
                "D. XOR (Exclusive OR)."
            ],
            "answer": "D. XOR (Exclusive OR).",
            "explanation": "T√†i li·ªáu (M·ª•c 4.1.4) ƒë·ªãnh nghƒ©a XOR: 'If both inputs are 0 or both are 1, the output is 0' (N·∫øu c·∫£ hai ƒë·∫ßu v√†o c√πng l√† 0 ho·∫∑c c√πng l√† 1 th√¨ k·∫øt qu·∫£ l√† 0). **M·∫πo ghi nh·ªõ: XOR = kh√°c nhau th√¨ b·∫±ng 1, gi·ªëng nhau th√¨ b·∫±ng 0.**"
        }
    },
    {
        "id": 115,
        "category": "Chapter 3: Data Storage (L∆∞u tr·ªØ d·ªØ li·ªáu)",
        "en": {
            "question": "Which shift operation is used when the bit pattern represents a signed integer and the sign bit must be preserved?",
            "options": [
                "A. Logical Shift.",
                "B. Circular Shift.",
                "C. Arithmetic Shift.",
                "D. Unary Shift."
            ],
            "answer": "C. Arithmetic Shift.",
            "explanation": "An arithmetic right shift is designed to preserve the sign of a number in two's complement representation. It shifts bits to the right but fills the new leftmost bit with a copy of the original sign bit. **Key takeaway: Arithmetic Shift = preserves the sign bit.**"
        },
        "vi": {
            "question": "Ph√©p d·ªãch chuy·ªÉn n√†o ƒë∆∞·ª£c s·ª≠ d·ª•ng khi m·∫´u bit bi·ªÉu di·ªÖn m·ªôt s·ªë nguy√™n c√≥ d·∫•u v√† c·∫ßn ph·∫£i b·∫£o to√†n bit d·∫•u?",
            "options": [
                "A. Logical Shift (D·ªãch chuy·ªÉn logic).",
                "B. Circular Shift (D·ªãch chuy·ªÉn v√≤ng).",
                "C. Arithmetic Shift (D·ªãch chuy·ªÉn s·ªë h·ªçc).",
                "D. Unary Shift (D·ªãch chuy·ªÉn ƒë∆°n ng√¥i)."
            ],
            "answer": "C. Arithmetic Shift (D·ªãch chuy·ªÉn s·ªë h·ªçc).",
            "explanation": "T√†i li·ªáu (M·ª•c 4.2.3) ghi: 'Arithmetic shift assumes the bit pattern represents a signed integer... It preserves the sign bit' (D·ªãch s·ªë h·ªçc gi·∫£ ƒë·ªãnh m·∫´u bit l√† s·ªë c√≥ d·∫•u... N√≥ b·∫£o to√†n bit d·∫•u). **M·∫πo ghi nh·ªõ: Arithmetic Shift = gi·ªØ l·∫°i bit d·∫•u.**"
        }
    },
    {
        "id": 116,
        "category": "Chapter 4: Computer Networks and Internet (M·∫°ng m√°y t√≠nh & Internet)",
        "en": {
            "question": "The TCP/IP model has ___ layers.",
            "options": [
                "A. Three",
                "B. Four",
                "C. Five",
                "D. Seven"
            ],
            "answer": "B. Four",
            "explanation": "The original, traditional TCP/IP model has four layers: Application, Transport, Internet, and Network Access. A more modern, hybrid model often presents it as five layers, but four is the classic answer. **Key takeaway: Traditional TCP/IP = 4 layers.**"
        },
        "vi": {
            "question": "M√¥ h√¨nh TCP/IP c√≥ ___ l·ªõp.",
            "options": [
                "A. Ba",
                "B. B·ªën",
                "C. NƒÉm",
                "D. B·∫£y"
            ],
            "answer": "B. B·ªën",
            "explanation": "M√¥ h√¨nh TCP/IP truy·ªÅn th·ªëng c√≥ b·ªën l·ªõp: ·ª®ng d·ª•ng, V·∫≠n chuy·ªÉn, Internet, v√† Truy c·∫≠p M·∫°ng. M√¥ h√¨nh lai hi·ªán ƒë·∫°i h∆°n th∆∞·ªùng c√≥ nƒÉm l·ªõp, nh∆∞ng b·ªën l√† c√¢u tr·∫£ l·ªùi kinh ƒëi·ªÉn. **M·∫πo ghi nh·ªõ: TCP/IP truy·ªÅn th·ªëng = 4 l·ªõp.**"
        }
    },
    {
        "id": 117,
        "category": "Chapter 4: Computer Networks and Internet (M·∫°ng m√°y t√≠nh & Internet)",
        "en": {
            "question": "The ___ layer of the TCP/IP protocol suite provides services for end users.",
            "options": [
                "A. Data-link",
                "B. Transport",
                "C. Application",
                "D. Physical"
            ],
            "answer": "C. Application",
            "explanation": "The Application layer contains protocols users interact with directly, such as HTTP (web), FTP (file transfer), and SMTP (email). **Key takeaway: User services = Application layer.**"
        },
        "vi": {
            "question": "L·ªõp ___ c·ªßa b·ªô giao th·ª©c TCP/IP cung c·∫•p d·ªãch v·ª• cho ng∆∞·ªùi d√πng cu·ªëi.",
            "options": [
                "A. Li√™n k·∫øt d·ªØ li·ªáu",
                "B. V·∫≠n chuy·ªÉn",
                "C. ·ª®ng d·ª•ng",
                "D. V·∫≠t l√Ω"
            ],
            "answer": "C. ·ª®ng d·ª•ng",
            "explanation": "L·ªõp ·ª®ng d·ª•ng ch·ª©a c√°c giao th·ª©c m√† ng∆∞·ªùi d√πng t∆∞∆°ng t√°c tr·ª±c ti·∫øp, ch·∫≥ng h·∫°n nh∆∞ HTTP (web), FTP (truy·ªÅn t·ªáp) v√† SMTP (email). **M·∫πo ghi nh·ªõ: D·ªãch v·ª• ng∆∞·ªùi d√πng = L·ªõp ·ª©ng d·ª•ng.**"
        }
    },
    {
        "id": 118,
        "category": "Chapter 4: Computer Networks and Internet (M·∫°ng m√°y t√≠nh & Internet)",
        "en": {
            "question": "The ___ layer of the TCP/IP protocol suite transmits a bit stream over a physical medium.",
            "options": [
                "A. Data-link",
                "B. Transport",
                "C. Application",
                "D. Physical"
            ],
            "answer": "D. Physical",
            "explanation": "The Physical layer is responsible for the actual transmission of raw bits (0s and 1s) over the communication channel (e.g., cable, fiber, radio). **Key takeaway: Transmits bits = Physical layer.**"
        },
        "vi": {
            "question": "L·ªõp ___ c·ªßa b·ªô giao th·ª©c TCP/IP truy·ªÅn m·ªôt lu·ªìng bit qua m·ªôt ph∆∞∆°ng ti·ªán v·∫≠t l√Ω.",
            "options": [
                "A. Li√™n k·∫øt d·ªØ li·ªáu",
                "B. V·∫≠n chuy·ªÉn",
                "C. ·ª®ng d·ª•ng",
                "D. V·∫≠t l√Ω"
            ],
            "answer": "D. V·∫≠t l√Ω",
            "explanation": "L·ªõp V·∫≠t l√Ω ch·ªãu tr√°ch nhi·ªám v·ªÅ vi·ªác truy·ªÅn v·∫≠t l√Ω th·ª±c t·∫ø c·ªßa c√°c bit th√¥ (0 v√† 1) qua k√™nh truy·ªÅn th√¥ng (v√≠ d·ª•: c√°p, s·ª£i quang, s√≥ng v√¥ tuy·∫øn). **M·∫πo ghi nh·ªõ: Truy·ªÅn bit = L·ªõp v·∫≠t l√Ω.**"
        }
    },
    {
        "id": 119,
        "category": "Chapter 4: Computer Networks and Internet (M·∫°ng m√°y t√≠nh & Internet)",
        "en": {
            "question": "The ___ layer of the TCP/IP protocol suite is responsible for node-to-node delivery of a frame between two adjacent nodes.",
            "options": [
                "A. Transport",
                "B. Network",
                "C. Data-link",
                "D. Session"
            ],
            "answer": "C. Data-link",
            "explanation": "The Data-Link layer handles the transfer of data frames across a single physical link (a 'hop'), dealing with MAC addresses and error detection on that link. **Key takeaway: Node-to-node / Frame = Data-Link layer.**"
        },
        "vi": {
            "question": "L·ªõp ___ c·ªßa b·ªô giao th·ª©c TCP/IP ch·ªãu tr√°ch nhi·ªám ph√¢n ph·ªëi khung (frame) t·ª´ n√∫t n√†y ƒë·∫øn n√∫t kia gi·ªØa hai n√∫t li·ªÅn k·ªÅ.",
            "options": [
                "A. V·∫≠n chuy·ªÉn",
                "B. M·∫°ng",
                "C. Li√™n k·∫øt d·ªØ li·ªáu",
                "D. Phi√™n"
            ],
            "answer": "C. Li√™n k·∫øt d·ªØ li·ªáu",
            "explanation": "L·ªõp Li√™n k·∫øt d·ªØ li·ªáu x·ª≠ l√Ω vi·ªác truy·ªÅn t·∫£i c√°c khung d·ªØ li·ªáu qua m·ªôt li√™n k·∫øt v·∫≠t l√Ω duy nh·∫•t (m·ªôt 'ch·∫∑ng'), x·ª≠ l√Ω ƒë·ªãa ch·ªâ MAC v√† ph√°t hi·ªán l·ªói tr√™n li√™n k·∫øt ƒë√≥. **M·∫πo ghi nh·ªõ: N√∫t-ƒë·∫øn-n√∫t / Khung = L·ªõp li√™n k·∫øt d·ªØ li·ªáu.**"
        }
    },
    {
        "id": 120,
        "category": "Chapter 4: Computer Networks and Internet (M·∫°ng m√°y t√≠nh & Internet)",
        "en": {
            "question": "The ___ layer of the TCP/IP protocol suite is responsible for source-to-destination delivery of the entire message.",
            "options": [
                "A. Transport",
                "B. Network",
                "C. Data-link",
                "D. Session"
            ],
            "answer": "B. Network",
            "explanation": "The Network layer (or Internet layer) is responsible for routing packets from the original source host to the final destination host across multiple networks, using IP addresses. **Key takeaway: Source-to-destination / Packet routing / IP Address = Network layer.**"
        },
        "vi": {
            "question": "L·ªõp ___ c·ªßa b·ªô giao th·ª©c TCP/IP ch·ªãu tr√°ch nhi·ªám ph√¢n ph·ªëi to√†n b·ªô th√¥ng ƒëi·ªáp t·ª´ ngu·ªìn ƒë·∫øn ƒë√≠ch.",
            "options": [
                "A. V·∫≠n chuy·ªÉn",
                "B. M·∫°ng",
                "C. Li√™n k·∫øt d·ªØ li·ªáu",
                "D. Phi√™n"
            ],
            "answer": "B. M·∫°ng",
            "explanation": "L·ªõp M·∫°ng (ho·∫∑c l·ªõp Internet) ch·ªãu tr√°ch nhi·ªám ƒë·ªãnh tuy·∫øn c√°c g√≥i tin t·ª´ m√°y ch·ªß ngu·ªìn ban ƒë·∫ßu ƒë·∫øn m√°y ch·ªß ƒë√≠ch cu·ªëi c√πng qua nhi·ªÅu m·∫°ng, s·ª≠ d·ª•ng ƒë·ªãa ch·ªâ IP. **M·∫πo ghi nh·ªõ: Ngu·ªìn-ƒë·∫øn-ƒë√≠ch / ƒê·ªãnh tuy·∫øn g√≥i tin / ƒê·ªãa ch·ªâ IP = L·ªõp m·∫°ng.**"
        }
    },
    {
        "id": 121,
        "category": "Chapter 4: Computer Networks and Internet (M·∫°ng m√°y t√≠nh & Internet)",
        "en": {
            "question": "What is the domain name in the e-mail address kayla@nasa.gov",
            "options": [
                "A. kayla",
                "B. kayla@nasa.gov",
                "C. nasa.gov",
                "D. gov"
            ],
            "answer": "C. nasa.gov",
            "explanation": "In an email address, the part after the '@' symbol is the domain name, which identifies the mail server. The part before is the username. **Key takeaway: After the '@' = Domain name.**"
        },
        "vi": {
            "question": "T√™n mi·ªÅn trong ƒë·ªãa ch·ªâ e-mail kayla@nasa.gov l√† g√¨",
            "options": [
                "A. kayla",
                "B. kayla@nasa.gov",
                "C. nasa.gov",
                "D. gov"
            ],
            "answer": "C. nasa.gov",
            "explanation": "Trong m·ªôt ƒë·ªãa ch·ªâ email, ph·∫ßn sau k√Ω hi·ªáu '@' l√† t√™n mi·ªÅn, x√°c ƒë·ªãnh m√°y ch·ªß th∆∞. Ph·∫ßn tr∆∞·ªõc '@' l√† t√™n ng∆∞·ªùi d√πng. **M·∫πo ghi nh·ªõ: Sau d·∫•u '@' = T√™n mi·ªÅn.**"
        }
    },
    {
        "id": 122,
        "category": "Chapter 4: Computer Networks and Internet (M·∫°ng m√°y t√≠nh & Internet)",
        "en": {
            "question": "Which physical topology uses a hub or switch?",
            "options": [
                "A. Bus",
                "B. Ring",
                "C. Star",
                "D. Bus and ring"
            ],
            "answer": "C. Star",
            "explanation": "In a star topology, all devices are connected to a central point (a hub or switch). This is the most common topology for modern LANs. **Key takeaway: Central device (hub/switch) = Star topology.**"
        },
        "vi": {
            "question": "C·∫•u tr√∫c li√™n k·∫øt v·∫≠t l√Ω n√†o s·ª≠ d·ª•ng hub ho·∫∑c switch?",
            "options": [
                "A. Bus",
                "B. V√≤ng",
                "C. Sao",
                "D. Bus v√† v√≤ng"
            ],
            "answer": "C. Sao",
            "explanation": "Trong c·∫•u tr√∫c li√™n k·∫øt h√¨nh sao, t·∫•t c·∫£ c√°c thi·∫øt b·ªã ƒë·ªÅu ƒë∆∞·ª£c k·∫øt n·ªëi v·ªõi m·ªôt ƒëi·ªÉm trung t√¢m (hub ho·∫∑c switch). ƒê√¢y l√† c·∫•u tr√∫c ph·ªï bi·∫øn nh·∫•t cho c√°c m·∫°ng LAN hi·ªán ƒë·∫°i. **M·∫πo ghi nh·ªõ: Thi·∫øt b·ªã trung t√¢m (hub/switch) = C·∫•u tr√∫c sao.**"
        }
    },
    {
        "id": 123,
        "category": "Chapter 4: Computer Networks and Internet (M·∫°ng m√°y t√≠nh & Internet)",
        "en": {
            "question": "IP addresses (IPv4) are currently ___ bits in length.",
            "options": [
                "A. 4",
                "B. 8",
                "C. 32",
                "D. 40"
            ],
            "answer": "C. 32",
            "explanation": "An IPv4 address is composed of four octets (4 sets of 8 bits), totaling 4 * 8 = 32 bits. **Key takeaway: IPv4 = 32 bits.**"
        },
        "vi": {
            "question": "ƒê·ªãa ch·ªâ IP (IPv4) hi·ªán c√≥ ƒë·ªô d√†i ___ bit.",
            "options": [
                "A. 4",
                "B. 8",
                "C. 32",
                "D. 40"
            ],
            "answer": "C. 32",
            "explanation": "M·ªôt ƒë·ªãa ch·ªâ IPv4 bao g·ªìm b·ªën octet (4 nh√≥m 8 bit), t·ªïng c·ªông l√† 4 * 8 = 32 bit. **M·∫πo ghi nh·ªõ: IPv4 = 32 bit.**"
        }
    },
    {
        "id": 124,
        "category": "Chapter 4: Computer Networks and Internet (M·∫°ng m√°y t√≠nh & Internet)",
        "en": {
            "question": "___ protocol(s) is one of the protocols in the transport layer.",
            "options": [
                "A. Only TCP",
                "B. Only UDP",
                "C. Only SCTP",
                "D. TCP, UDP, and SCTP"
            ],
            "answer": "D. TCP, UDP, and SCTP",
            "explanation": "The main protocols at the Transport Layer are TCP (reliable), UDP (unreliable), and the newer SCTP. **Key takeaway: Transport Layer = TCP, UDP, SCTP.**"
        },
        "vi": {
            "question": "Giao th·ª©c n√†o l√† m·ªôt trong nh·ªØng giao th·ª©c ·ªü l·ªõp v·∫≠n chuy·ªÉn.",
            "options": [
                "A. Ch·ªâ TCP",
                "B. Ch·ªâ UDP",
                "C. Ch·ªâ SCTP",
                "D. TCP, UDP, v√† SCTP"
            ],
            "answer": "D. TCP, UDP, v√† SCTP",
            "explanation": "C√°c giao th·ª©c ch√≠nh ·ªü L·ªõp V·∫≠n chuy·ªÉn l√† TCP (ƒë√°ng tin c·∫≠y), UDP (kh√¥ng ƒë√°ng tin c·∫≠y), v√† SCTP m·ªõi h∆°n. **M·∫πo ghi nh·ªõ: L·ªõp V·∫≠n chuy·ªÉn = TCP, UDP, SCTP.**"
        }
    },
{
        "id": 125,
        "category": "Chapter 4: Computer Networks and Internet (M·∫°ng m√°y t√≠nh & Internet)",
        "en": {
            "question": "___ is a protocol for file transfer.",
            "options": [
                "A. FTP",
                "B. SMTP",
                "C. TELNET",
                "D. HTTP"
            ],
            "answer": "A. FTP",
            "explanation": "FTP stands for File Transfer Protocol. It is specifically designed to transfer files between a client and a server on a computer network. **Key takeaway: File Transfer = FTP.**"
        },
        "vi": {
            "question": "___ l√† m·ªôt giao th·ª©c ƒë·ªÉ truy·ªÅn t·ªáp.",
            "options": [
                "A. FTP",
                "B. SMTP",
                "C. TELNET",
                "D. HTTP"
            ],
            "answer": "A. FTP",
            "explanation": "FTP l√† vi·∫øt t·∫Øt c·ªßa File Transfer Protocol (Giao th·ª©c truy·ªÅn t·ªáp). N√≥ ƒë∆∞·ª£c thi·∫øt k·∫ø ƒë·∫∑c bi·ªát ƒë·ªÉ truy·ªÅn t·ªáp gi·ªØa m√°y kh√°ch v√† m√°y ch·ªß tr√™n m·ªôt m·∫°ng m√°y t√≠nh. **M·∫πo ghi nh·ªõ: Truy·ªÅn t·ªáp = FTP.**"
        }
    },
    {
        "id": 126,
        "category": "Chapter 4: Computer Networks and Internet (M·∫°ng m√°y t√≠nh & Internet)",
        "en": {
            "question": "Every computer looking to access the Internet would be known as a _______.",
            "options": [
                "A. Client",
                "B. Desktop",
                "C. Hub",
                "D. Server"
            ],
            "answer": "A. Client",
            "explanation": "In the client-server model that dominates the internet, a user's computer that requests services (like a web page) is called the client. The computer that provides the service is the server. **Key takeaway: Computer requesting service = Client.**"
        },
        "vi": {
            "question": "M·ªçi m√°y t√≠nh mu·ªën truy c·∫≠p Internet s·∫Ω ƒë∆∞·ª£c g·ªçi l√† _______.",
            "options": [
                "A. M√°y kh√°ch (Client)",
                "B. M√°y t√≠nh ƒë·ªÉ b√†n (Desktop)",
                "C. Hub",
                "D. M√°y ch·ªß (Server)"
            ],
            "answer": "A. M√°y kh√°ch (Client)",
            "explanation": "Trong m√¥ h√¨nh m√°y kh√°ch-m√°y ch·ªß th·ªëng tr·ªã internet, m√°y t√≠nh c·ªßa ng∆∞·ªùi d√πng y√™u c·∫ßu c√°c d·ªãch v·ª• (nh∆∞ m·ªôt trang web) ƒë∆∞·ª£c g·ªçi l√† m√°y kh√°ch. M√°y t√≠nh cung c·∫•p d·ªãch v·ª• l√† m√°y ch·ªß. **M·∫πo ghi nh·ªõ: M√°y t√≠nh y√™u c·∫ßu d·ªãch v·ª• = M√°y kh√°ch.**"
        }
    },
    {
        "id": 127,
        "category": "Chapter 4: Computer Networks and Internet (M·∫°ng m√°y t√≠nh & Internet)",
        "en": {
            "question": "This domain identifies company or commercial sites.",
            "options": [
                "A. .org",
                "B. .com",
                "C. .gov",
                "D. .edu"
            ],
            "answer": "B. .com",
            "explanation": "The '.com' top-level domain (TLD) originally stood for 'commercial' and is the most widely used TLD for businesses and company websites. **Key takeaway: .com = commercial.**"
        },
        "vi": {
            "question": "T√™n mi·ªÅn n√†y x√°c ƒë·ªãnh c√°c trang web c·ªßa c√¥ng ty ho·∫∑c th∆∞∆°ng m·∫°i.",
            "options": [
                "A. .org",
                "B. .com",
                "C. .gov",
                "D. .edu"
            ],
            "answer": "B. .com",
            "explanation": "T√™n mi·ªÅn c·∫•p cao nh·∫•t (TLD) '.com' ban ƒë·∫ßu l√† vi·∫øt t·∫Øt c·ªßa 'commercial' (th∆∞∆°ng m·∫°i) v√† l√† TLD ƒë∆∞·ª£c s·ª≠ d·ª•ng r·ªông r√£i nh·∫•t cho c√°c doanh nghi·ªáp v√† trang web c√¥ng ty. **M·∫πo ghi nh·ªõ: .com = commercial (th∆∞∆°ng m·∫°i).**"
        }
    },
    {
        "id": 128,
        "category": "Chapter 4: Computer Networks and Internet (M·∫°ng m√°y t√≠nh & Internet)",
        "en": {
            "question": "What is indicated when the domain name has only two letters like .us, .uk, .au, .mx, or .ca?",
            "options": [
                "A. Invalid domain",
                "B. Private domain",
                "C. Secure domain",
                "D. Country domain"
            ],
            "answer": "D. Country domain",
            "explanation": "Two-letter top-level domains are country code Top-Level Domains (ccTLDs), such as .us for United States, .uk for United Kingdom, etc. **Key takeaway: Two-letter domain = Country code.**"
        },
        "vi": {
            "question": "ƒêi·ªÅu g√¨ ƒë∆∞·ª£c ch·ªâ ra khi t√™n mi·ªÅn ch·ªâ c√≥ hai ch·ªØ c√°i nh∆∞ .us, .uk, .au, .mx, ho·∫∑c .ca?",
            "options": [
                "A. T√™n mi·ªÅn kh√¥ng h·ª£p l·ªá",
                "B. T√™n mi·ªÅn ri√™ng t∆∞",
                "C. T√™n mi·ªÅn an to√†n",
                "D. T√™n mi·ªÅn qu·ªëc gia"
            ],
            "answer": "D. T√™n mi·ªÅn qu·ªëc gia",
            "explanation": "C√°c t√™n mi·ªÅn c·∫•p cao nh·∫•t c√≥ hai ch·ªØ c√°i l√† T√™n mi·ªÅn c·∫•p cao nh·∫•t m√£ qu·ªëc gia (ccTLD), ch·∫≥ng h·∫°n nh∆∞ .us cho Hoa K·ª≥, .uk cho V∆∞∆°ng qu·ªëc Anh, v.v. **M·∫πo ghi nh·ªõ: T√™n mi·ªÅn hai ch·ªØ c√°i = M√£ qu·ªëc gia.**"
        }
    },
    {
        "id": 129,
        "category": "Chapter 4: Computer Networks and Internet (M·∫°ng m√°y t√≠nh & Internet)",
        "en": {
            "question": "A transport-layer payload may be ____ in several network-layer packets.",
            "options": [
                "A. Decrypted",
                "B. Decapsulated",
                "C. Encrypted",
                "D. Encapsulated"
            ],
            "answer": "D. Encapsulated",
            "explanation": "This describes fragmentation. If a Transport-layer segment is too big to fit in one Network-layer packet, the Network layer will break it into smaller pieces and encapsulate each piece in a separate packet. **Key takeaway: Large data is broken down and encapsulated in smaller packets.**"
        },
        "vi": {
            "question": "M·ªôt t·∫£i tr·ªçng l·ªõp v·∫≠n chuy·ªÉn c√≥ th·ªÉ ƒë∆∞·ª£c ____ trong nhi·ªÅu g√≥i l·ªõp m·∫°ng.",
            "options": [
                "A. Gi·∫£i m√£",
                "B. T√°ch g√≥i",
                "C. M√£ h√≥a",
                "D. ƒê√≥ng g√≥i"
            ],
            "answer": "D. ƒê√≥ng g√≥i",
            "explanation": "ƒêi·ªÅu n√†y m√¥ t·∫£ s·ª± ph√¢n m·∫£nh. N·∫øu m·ªôt ph√¢n ƒëo·∫°n l·ªõp V·∫≠n chuy·ªÉn qu√° l·ªõn ƒë·ªÉ v·ª´a trong m·ªôt g√≥i l·ªõp M·∫°ng, l·ªõp M·∫°ng s·∫Ω chia n√≥ th√†nh c√°c m·∫£nh nh·ªè h∆°n v√† ƒë√≥ng g√≥i m·ªói m·∫£nh trong m·ªôt g√≥i ri√™ng bi·ªát. **M·∫πo ghi nh·ªõ: D·ªØ li·ªáu l·ªõn ƒë∆∞·ª£c chia nh·ªè v√† ƒë√≥ng g√≥i trong c√°c g√≥i nh·ªè h∆°n.**"
        }
    },
    {
        "id": 130,
        "category": "Chapter 4: Computer Networks and Internet (M·∫°ng m√°y t√≠nh & Internet)",
        "en": {
            "question": "The TCP/IP suite does not define any protocol in the ____ layer.",
            "options": [
                "A. Data-link",
                "B. Network",
                "C. Session",
                "D. Transport"
            ],
            "answer": "C. Session",
            "explanation": "The Session layer is part of the seven-layer OSI model, but it is not a distinct layer in the TCP/IP model. Its functions are generally handled by the Application layer in TCP/IP. **Key takeaway: Session layer belongs to OSI, not TCP/IP.**"
        },
        "vi": {
            "question": "B·ªô giao th·ª©c TCP/IP kh√¥ng ƒë·ªãnh nghƒ©a b·∫•t k·ª≥ giao th·ª©c n√†o trong l·ªõp ____.",
            "options": [
                "A. Li√™n k·∫øt d·ªØ li·ªáu",
                "B. M·∫°ng",
                "C. Phi√™n",
                "D. V·∫≠n chuy·ªÉn"
            ],
            "answer": "C. Phi√™n",
            "explanation": "L·ªõp Phi√™n l√† m·ªôt ph·∫ßn c·ªßa m√¥ h√¨nh OSI b·∫£y l·ªõp, nh∆∞ng n√≥ kh√¥ng ph·∫£i l√† m·ªôt l·ªõp ri√™ng bi·ªát trong m√¥ h√¨nh TCP/IP. C√°c ch·ª©c nƒÉng c·ªßa n√≥ th∆∞·ªùng ƒë∆∞·ª£c x·ª≠ l√Ω b·ªüi l·ªõp ·ª®ng d·ª•ng trong TCP/IP. **M·∫πo ghi nh·ªõ: L·ªõp Phi√™n thu·ªôc v·ªÅ OSI, kh√¥ng ph·∫£i TCP/IP.**"
        }
    },
    {
        "id": 131,
        "category": "Chapter 4: Computer Networks and Internet (M·∫°ng m√°y t√≠nh & Internet)",
        "en": {
            "question": "In the physical layer, a ____ can be broadly defined as anything that can carry information from a source to a destination.",
            "options": [
                "A. Digital-to-digital conversion",
                "B. Digital-to-analog conversion",
                "C. Analog-to-analog conversion",
                "D. Transmission medium"
            ],
            "answer": "D. Transmission medium",
            "explanation": "A transmission medium is the physical path between transmitter and receiver. It can be wired (like copper cable, fiber optics) or wireless (like radio waves). **Key takeaway: Physical path for information = Transmission medium.**"
        },
        "vi": {
            "question": "·ªû l·ªõp v·∫≠t l√Ω, m·ªôt ____ c√≥ th·ªÉ ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a r·ªông r√£i l√† b·∫•t c·ª© th·ª© g√¨ c√≥ th·ªÉ mang th√¥ng tin t·ª´ ngu·ªìn ƒë·∫øn ƒë√≠ch.",
            "options": [
                "A. Chuy·ªÉn ƒë·ªïi s·ªë-s·ªë",
                "B. Chuy·ªÉn ƒë·ªïi s·ªë-t∆∞∆°ng t·ª±",
                "C. Chuy·ªÉn ƒë·ªïi t∆∞∆°ng t·ª±-t∆∞∆°ng t·ª±",
                "D. M√¥i tr∆∞·ªùng truy·ªÅn d·∫´n"
            ],
            "answer": "D. M√¥i tr∆∞·ªùng truy·ªÅn d·∫´n",
            "explanation": "M√¥i tr∆∞·ªùng truy·ªÅn d·∫´n l√† ƒë∆∞·ªùng d·∫´n v·∫≠t l√Ω gi·ªØa m√°y ph√°t v√† m√°y thu. N√≥ c√≥ th·ªÉ l√† c√≥ d√¢y (nh∆∞ c√°p ƒë·ªìng, s·ª£i quang) ho·∫∑c kh√¥ng d√¢y (nh∆∞ s√≥ng v√¥ tuy·∫øn). **M·∫πo ghi nh·ªõ: ƒê∆∞·ªùng d·∫´n v·∫≠t l√Ω cho th√¥ng tin = M√¥i tr∆∞·ªùng truy·ªÅn d·∫´n.**"
        }
    },
    {
        "id": 132,
        "category": "Chapter 4: Computer Networks and Internet (M·∫°ng m√°y t√≠nh & Internet)",
        "en": {
            "question": "An IPv4 address is a ____ address that uniquely and universally defines the connection of a host or a router to the Internet.",
            "options": [
                "A. 128-bit",
                "B. 64-bit",
                "C. 32-bit",
                "D. 16-bit"
            ],
            "answer": "C. 32-bit",
            "explanation": "This is a repeated question. IPv4 addresses consist of 32 bits, typically written as four decimal numbers separated by dots (e.g., 192.168.1.1). **Key takeaway: IPv4 = 32 bits.**"
        },
        "vi": {
            "question": "M·ªôt ƒë·ªãa ch·ªâ IPv4 l√† m·ªôt ƒë·ªãa ch·ªâ ____ ƒë·ªãnh nghƒ©a duy nh·∫•t v√† ph·ªï qu√°t k·∫øt n·ªëi c·ªßa m·ªôt m√°y ch·ªß ho·∫∑c m·ªôt b·ªô ƒë·ªãnh tuy·∫øn v·ªõi Internet.",
            "options": [
                "A. 128-bit",
                "B. 64-bit",
                "C. 32-bit",
                "D. 16-bit"
            ],
            "answer": "C. 32-bit",
            "explanation": "ƒê√¢y l√† m·ªôt c√¢u h·ªèi l·∫∑p l·∫°i. ƒê·ªãa ch·ªâ IPv4 bao g·ªìm 32 bit, th∆∞·ªùng ƒë∆∞·ª£c vi·∫øt d∆∞·ªõi d·∫°ng b·ªën s·ªë th·∫≠p ph√¢n c√°ch nhau b·∫±ng d·∫•u ch·∫•m (v√≠ d·ª•: 192.168.1.1). **M·∫πo ghi nh·ªõ: IPv4 = 32 bit.**"
        }
    },
    {
        "id": 133,
        "category": "Chapter 4: Computer Networks and Internet (M·∫°ng m√°y t√≠nh & Internet)",
        "en": {
            "question": "A _______ is usually privately owned, limited in size, and connects some hosts in a single office, building, or campus.",
            "options": [
                "A. LAN",
                "B. WAN",
                "C. Internet",
                "D. Network"
            ],
            "answer": "A. LAN",
            "explanation": "This is the definition of a Local Area Network (LAN). It covers a small geographical area and is privately owned. **Key takeaway: Small, private network = LAN.**"
        },
        "vi": {
            "question": "M·ªôt _______ th∆∞·ªùng thu·ªôc s·ªü h·ªØu t∆∞ nh√¢n, c√≥ k√≠ch th∆∞·ªõc gi·ªõi h·∫°n v√† k·∫øt n·ªëi m·ªôt s·ªë m√°y ch·ªß trong m·ªôt vƒÉn ph√≤ng, t√≤a nh√† ho·∫∑c khu√¥n vi√™n duy nh·∫•t.",
            "options": [
                "A. LAN",
                "B. WAN",
                "C. Internet",
                "D. M·∫°ng"
            ],
            "answer": "A. LAN",
            "explanation": "ƒê√¢y l√† ƒë·ªãnh nghƒ©a c·ªßa M·∫°ng c·ª•c b·ªô (LAN). N√≥ bao ph·ªß m·ªôt khu v·ª±c ƒë·ªãa l√Ω nh·ªè v√† thu·ªôc s·ªü h·ªØu t∆∞ nh√¢n. **M·∫πo ghi nh·ªõ: M·∫°ng nh·ªè, ri√™ng t∆∞ = LAN.**"
        }
    },
    {
        "id": 134,
        "category": "Chapter 4: Computer Networks and Internet (M·∫°ng m√°y t√≠nh & Internet)",
        "en": {
            "question": "At the transport layer, addresses are called ____, and these define application-layer programs at the source and destination.",
            "options": [
                "A. TCP",
                "B. port numbers",
                "C. UDP",
                "D. IP addresses"
            ],
            "answer": "B. port numbers",
            "explanation": "While IP addresses get a packet to the correct computer, port numbers get the data to the correct application (process) on that computer. For example, web traffic usually goes to port 80. **Key takeaway: Transport layer address = Port number.**"
        },
        "vi": {
            "question": "·ªû l·ªõp v·∫≠n chuy·ªÉn, c√°c ƒë·ªãa ch·ªâ ƒë∆∞·ª£c g·ªçi l√† ____, v√† ch√∫ng x√°c ƒë·ªãnh c√°c ch∆∞∆°ng tr√¨nh l·ªõp ·ª©ng d·ª•ng ·ªü ngu·ªìn v√† ƒë√≠ch.",
            "options": [
                "A. TCP",
                "B. s·ªë hi·ªáu c·ªïng",
                "C. UDP",
                "D. ƒë·ªãa ch·ªâ IP"
            ],
            "answer": "B. s·ªë hi·ªáu c·ªïng",
            "explanation": "Trong khi ƒë·ªãa ch·ªâ IP ƒë∆∞a m·ªôt g√≥i tin ƒë·∫øn ƒë√∫ng m√°y t√≠nh, s·ªë hi·ªáu c·ªïng ƒë∆∞a d·ªØ li·ªáu ƒë·∫øn ƒë√∫ng ·ª©ng d·ª•ng (ti·∫øn tr√¨nh) tr√™n m√°y t√≠nh ƒë√≥. V√≠ d·ª•, l∆∞u l∆∞·ª£ng truy c·∫≠p web th∆∞·ªùng ƒë·∫øn c·ªïng 80. **M·∫πo ghi nh·ªõ: ƒê·ªãa ch·ªâ l·ªõp v·∫≠n chuy·ªÉn = S·ªë hi·ªáu c·ªïng.**"
        }
    },
    {
        "id": 135,
        "category": "Chapter 4: Computer Networks and Internet (M·∫°ng m√°y t√≠nh & Internet)",
        "en": {
            "question": "The devices in a Bluetooth LAN, sometimes called gadgets, find each other and make a network called a _______.",
            "options": [
                "A. ESS",
                "B. Ad hoc",
                "C. BSS",
                "D. piconet"
            ],
            "answer": "D. piconet",
            "explanation": "A piconet is a small, ad-hoc Bluetooth network that links a master device with up to seven active slave devices. **Key takeaway: Bluetooth network = Piconet.**"
        },
        "vi": {
            "question": "C√°c thi·∫øt b·ªã trong m·ªôt m·∫°ng LAN Bluetooth, ƒë√¥i khi ƒë∆∞·ª£c g·ªçi l√† ti·ªán √≠ch, t√¨m th·∫•y nhau v√† t·∫°o th√†nh m·ªôt m·∫°ng g·ªçi l√† _______.",
            "options": [
                "A. ESS",
                "B. Ad hoc",
                "C. BSS",
                "D. piconet"
            ],
            "answer": "D. piconet",
            "explanation": "Piconet l√† m·ªôt m·∫°ng Bluetooth nh·ªè, ƒë·∫∑c bi·ªát (ad-hoc) k·∫øt n·ªëi m·ªôt thi·∫øt b·ªã ch·ªß v·ªõi t·ªëi ƒëa b·∫£y thi·∫øt b·ªã ph·ª• ho·∫°t ƒë·ªông. **M·∫πo ghi nh·ªõ: M·∫°ng Bluetooth = Piconet.**"
        }
    },
    {
        "id": 136,
        "category": "Chapter 4: Computer Networks and Internet (M·∫°ng m√°y t√≠nh & Internet)",
        "en": {
            "question": "In the internet today, backbones and provider networks are also called ____.",
            "options": [
                "A. Customer networks",
                "B. Provider networks",
                "C. peering points",
                "D. internet service providers (ISPs)"
            ],
            "answer": "D. internet service providers (ISPs)",
            "explanation": "ISPs are the companies that provide access to the internet. They operate the large backbone and provider networks that form the core of the internet infrastructure. **Key takeaway: Backbone/Provider networks = ISPs.**"
        },
        "vi": {
            "question": "Trong internet ng√†y nay, c√°c m·∫°ng ƒë∆∞·ªùng tr·ª•c v√† m·∫°ng c·ªßa nh√† cung c·∫•p c√≤n ƒë∆∞·ª£c g·ªçi l√† ____.",
            "options": [
                "A. M·∫°ng kh√°ch h√†ng",
                "B. M·∫°ng c·ªßa nh√† cung c·∫•p",
                "C. ƒêi·ªÉm k·∫øt n·ªëi ngang h√†ng",
                "D. Nh√† cung c·∫•p d·ªãch v·ª• internet (ISPs)"
            ],
            "answer": "D. Nh√† cung c·∫•p d·ªãch v·ª• internet (ISPs)",
            "explanation": "ISP l√† c√°c c√¥ng ty cung c·∫•p quy·ªÅn truy c·∫≠p v√†o internet. H·ªç v·∫≠n h√†nh c√°c m·∫°ng ƒë∆∞·ªùng tr·ª•c v√† m·∫°ng c·ªßa nh√† cung c·∫•p l·ªõn t·∫°o th√†nh c·ªët l√µi c·ªßa c∆° s·ªü h·∫° t·∫ßng internet. **M·∫πo ghi nh·ªõ: M·∫°ng ƒë∆∞·ªùng tr·ª•c/nh√† cung c·∫•p = ISP.**"
        }
    },
    {
        "id": 137,
        "category": "Chapter 4: Computer Networks and Internet (M·∫°ng m√°y t√≠nh & Internet)",
        "en": {
            "question": "_______ is a very simple protocol using a minimum of overhead, used when a process does not care much about reliability.",
            "options": [
                "A. TCP",
                "B. UDP",
                "C. IP",
                "D. HTTP"
            ],
            "answer": "B. UDP",
            "explanation": "UDP (User Datagram Protocol) is a connectionless, unreliable transport protocol. It provides no error checking or retransmission, making it very fast with low overhead, suitable for applications like streaming or online gaming where speed is more important than perfect reliability. **Key takeaway: Fast, simple, unreliable = UDP.**"
        },
        "vi": {
            "question": "_______ l√† m·ªôt giao th·ª©c r·∫•t ƒë∆°n gi·∫£n s·ª≠ d·ª•ng chi ph√≠ t·ªëi thi·ªÉu, ƒë∆∞·ª£c s·ª≠ d·ª•ng khi m·ªôt ti·∫øn tr√¨nh kh√¥ng quan t√¢m nhi·ªÅu ƒë·∫øn ƒë·ªô tin c·∫≠y.",
            "options": [
                "A. TCP",
                "B. UDP",
                "C. IP",
                "D. HTTP"
            ],
            "answer": "B. UDP",
            "explanation": "UDP (Giao th·ª©c Datagram ng∆∞·ªùi d√πng) l√† m·ªôt giao th·ª©c v·∫≠n chuy·ªÉn kh√¥ng k·∫øt n·ªëi, kh√¥ng ƒë√°ng tin c·∫≠y. N√≥ kh√¥ng cung c·∫•p ki·ªÉm tra l·ªói ho·∫∑c truy·ªÅn l·∫°i, l√†m cho n√≥ r·∫•t nhanh v·ªõi chi ph√≠ th·∫•p, ph√π h·ª£p cho c√°c ·ª©ng d·ª•ng nh∆∞ ph√°t tr·ª±c tuy·∫øn ho·∫∑c ch∆°i game tr·ª±c tuy·∫øn n∆°i t·ªëc ƒë·ªô quan tr·ªçng h∆°n ƒë·ªô tin c·∫≠y ho√†n h·∫£o. **M·∫πo ghi nh·ªõ: Nhanh, ƒë∆°n gi·∫£n, kh√¥ng ƒë√°ng tin c·∫≠y = UDP.**"
        }
    },
    {
        "id": 138,
        "category": "Chapter 4: Computer Networks and Internet (M·∫°ng m√°y t√≠nh & Internet)",
        "en": {
            "question": "A _______ defines the rules that both the sender and receiver and all intermediate devices need to follow to be able to communicate effectively.",
            "options": [
                "A. Protocol",
                "B. Layers",
                "C. Provider networks",
                "D. Hardware and software"
            ],
            "answer": "A. Protocol",
            "explanation": "A protocol is a set of rules and conventions that govern communication between network devices. It defines the format, order, and meaning of messages exchanged. **Key takeaway: Rules for communication = Protocol.**"
        },
        "vi": {
            "question": "M·ªôt _______ ƒë·ªãnh nghƒ©a c√°c quy t·∫Øc m√† c·∫£ ng∆∞·ªùi g·ª≠i v√† ng∆∞·ªùi nh·∫≠n v√† t·∫•t c·∫£ c√°c thi·∫øt b·ªã trung gian c·∫ßn tu√¢n theo ƒë·ªÉ c√≥ th·ªÉ giao ti·∫øp hi·ªáu qu·∫£.",
            "options": [
                "A. Giao th·ª©c",
                "B. C√°c l·ªõp",
                "C. M·∫°ng c·ªßa nh√† cung c·∫•p",
                "D. Ph·∫ßn c·ª©ng v√† ph·∫ßn m·ªÅm"
            ],
            "answer": "A. Giao th·ª©c",
            "explanation": "Giao th·ª©c l√† m·ªôt t·∫≠p h·ª£p c√°c quy t·∫Øc v√† quy ∆∞·ªõc ƒëi·ªÅu ch·ªânh vi·ªác giao ti·∫øp gi·ªØa c√°c thi·∫øt b·ªã m·∫°ng. N√≥ ƒë·ªãnh nghƒ©a ƒë·ªãnh d·∫°ng, th·ª© t·ª± v√† √Ω nghƒ©a c·ªßa c√°c th√¥ng ƒëi·ªáp ƒë∆∞·ª£c trao ƒë·ªïi. **M·∫πo ghi nh·ªõ: Quy t·∫Øc giao ti·∫øp = Giao th·ª©c.**"
        }
    },
    {
        "id": 139,
        "category": "Chapter 4: Computer Networks and Internet (M·∫°ng m√°y t√≠nh & Internet)",
        "en": {
            "question": "The _______ is a standard protocol provided by TCP/IP for copying a file from one host to another andtransferring files from one system to another seems simple and straightforward.",
            "options": [
                "A. FTP",
                "B. SMTP",
                "C. URL",
                "D. HTTP"
            ],
            "answer": "A. FTP",
            "explanation": "This is a repeated question. FTP stands for File Transfer Protocol and is the standard for transferring files across a network. **Key takeaway: Copying files = FTP.**"
        },
        "vi": {
            "question": "_______ l√† m·ªôt giao th·ª©c ti√™u chu·∫©n ƒë∆∞·ª£c cung c·∫•p b·ªüi TCP/IP ƒë·ªÉ sao ch√©p m·ªôt t·ªáp t·ª´ m·ªôt m√°y ch·ªß n√†y sang m√°y ch·ªß kh√°c v√† vi·ªác truy·ªÅn t·ªáp t·ª´ m·ªôt h·ªá th·ªëng n√†y sang h·ªá th·ªëng kh√°c c√≥ v·∫ª ƒë∆°n gi·∫£n v√† d·ªÖ d√†ng.",
            "options": [
                "A. FTP",
                "B. SMTP",
                "C. URL",
                "D. HTTP"
            ],
            "answer": "A. FTP",
            "explanation": "ƒê√¢y l√† m·ªôt c√¢u h·ªèi l·∫∑p l·∫°i. FTP l√† vi·∫øt t·∫Øt c·ªßa File Transfer Protocol v√† l√† ti√™u chu·∫©n ƒë·ªÉ truy·ªÅn t·ªáp qua m·∫°ng. **M·∫πo ghi nh·ªõ: Sao ch√©p t·ªáp = FTP.**"
        }
    },
    {
        "id": 140,
        "category": "Chapter 4: Computer Networks and Internet (M·∫°ng m√°y t√≠nh & Internet)",
        "en": {
            "question": "Communication by phone is indeed a _______ activity; no party needs to be running forever waiting for the other party to call",
            "options": [
                "A. P2P",
                "B. Traditional",
                "C. Client-server",
                "D. Model"
            ],
            "answer": "B. Traditional",
            "explanation": "This question contrasts with the client-server model where a server must be running forever. A traditional phone call is peer-to-peer and doesn't require a constantly running 'server'. 'Traditional' is the best fit among the ambiguous options. **Key takeaway: Phone calls are peer-to-peer, unlike the constant-on server model.**"
        },
        "vi": {
            "question": "Giao ti·∫øp qua ƒëi·ªán tho·∫°i th·ª±c s·ª± l√† m·ªôt ho·∫°t ƒë·ªông _______; kh√¥ng b√™n n√†o c·∫ßn ph·∫£i ch·∫°y m√£i m√£i ƒë·ªÉ ch·ªù b√™n kia g·ªçi",
            "options": [
                "A. P2P",
                "B. Truy·ªÅn th·ªëng",
                "C. Kh√°ch-ch·ªß",
                "D. M√¥ h√¨nh"
            ],
            "answer": "B. Truy·ªÅn th·ªëng",
            "explanation": "C√¢u h·ªèi n√†y ƒë·ªëi l·∫≠p v·ªõi m√¥ h√¨nh kh√°ch-ch·ªß, n∆°i m·ªôt m√°y ch·ªß ph·∫£i ch·∫°y m√£i m√£i. M·ªôt cu·ªôc g·ªçi ƒëi·ªán tho·∫°i truy·ªÅn th·ªëng l√† ngang h√†ng (peer-to-peer) v√† kh√¥ng y√™u c·∫ßu m·ªôt 'm√°y ch·ªß' ch·∫°y li√™n t·ª•c. 'Truy·ªÅn th·ªëng' l√† l·ª±a ch·ªçn ph√π h·ª£p nh·∫•t. **M·∫πo ghi nh·ªõ: Cu·ªôc g·ªçi ƒëi·ªán tho·∫°i l√† ngang h√†ng, kh√¥ng gi·ªëng m√¥ h√¨nh m√°y ch·ªß lu√¥n b·∫≠t.**"
        }
    },
    {
        "id": 141,
        "category": "Chapter 4: Computer Networks and Internet (M·∫°ng m√°y t√≠nh & Internet)",
        "en": {
            "question": "The _______ is a protocol that is used to define how the client-server programs can be written to retrieve web pages from the Web.",
            "options": [
                "A. FTP",
                "B. SMTP",
                "C. TELNET",
                "D. HTTP"
            ],
            "answer": "D. HTTP",
            "explanation": "HTTP (HyperText Transfer Protocol) is the foundation of data communication for the World Wide Web. It's the protocol used by web browsers (clients) to request web pages from web servers. **Key takeaway: Retrieving web pages = HTTP.**"
        },
        "vi": {
            "question": "_______ l√† m·ªôt giao th·ª©c ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ ƒë·ªãnh nghƒ©a c√°ch c√°c ch∆∞∆°ng tr√¨nh kh√°ch-ch·ªß c√≥ th·ªÉ ƒë∆∞·ª£c vi·∫øt ƒë·ªÉ truy xu·∫•t c√°c trang web t·ª´ Web.",
            "options": [
                "A. FTP",
                "B. SMTP",
                "C. TELNET",
                "D. HTTP"
            ],
            "answer": "D. HTTP",
            "explanation": "HTTP (HyperText Transfer Protocol) l√† n·ªÅn t·∫£ng c·ªßa vi·ªác truy·ªÅn d·ªØ li·ªáu cho World Wide Web. N√≥ l√† giao th·ª©c ƒë∆∞·ª£c c√°c tr√¨nh duy·ªát web (m√°y kh√°ch) s·ª≠ d·ª•ng ƒë·ªÉ y√™u c·∫ßu c√°c trang web t·ª´ c√°c m√°y ch·ªß web. **M·∫πo ghi nh·ªõ: Truy xu·∫•t trang web = HTTP.**"
        }
    },
    {
        "id": 142,
        "category": "Chapter 4: Computer Networks and Internet (M·∫°ng m√°y t√≠nh & Internet)",
        "en": {
            "question": "Instead of using a numeric address, what unique address can we use to connect a host to the Internet in TCP/IP protocol?",
            "options": [
                "A. DNS",
                "B. Port number",
                "C. MAC addresses",
                "D. IP address"
            ],
            "answer": "A. DNS",
            "explanation": "While IP addresses are the actual numeric addresses, the Domain Name System (DNS) provides a way to use human-readable unique names (like www.google.com) to connect to hosts. **Key takeaway: Human-readable address = DNS.**"
        },
        "vi": {
            "question": "Thay v√¨ s·ª≠ d·ª•ng ƒë·ªãa ch·ªâ s·ªë, ch√∫ng ta c√≥ th·ªÉ s·ª≠ d·ª•ng ƒë·ªãa ch·ªâ duy nh·∫•t n√†o ƒë·ªÉ k·∫øt n·ªëi m·ªôt m√°y ch·ªß v·ªõi Internet trong giao th·ª©c TCP/IP?",
            "options": [
                "A. DNS",
                "B. S·ªë hi·ªáu c·ªïng",
                "C. ƒê·ªãa ch·ªâ MAC",
                "D. ƒê·ªãa ch·ªâ IP"
            ],
            "answer": "A. DNS",
            "explanation": "M·∫∑c d√π ƒë·ªãa ch·ªâ IP l√† ƒë·ªãa ch·ªâ s·ªë th·ª±c t·∫ø, H·ªá th·ªëng T√™n mi·ªÅn (DNS) cung c·∫•p m·ªôt c√°ch ƒë·ªÉ s·ª≠ d·ª•ng c√°c t√™n duy nh·∫•t d·ªÖ ƒë·ªçc (nh∆∞ www.google.com) ƒë·ªÉ k·∫øt n·ªëi v·ªõi c√°c m√°y ch·ªß. **M·∫πo ghi nh·ªõ: ƒê·ªãa ch·ªâ d·ªÖ ƒë·ªçc = DNS.**"
        }
    },
    {
        "id": 143,
        "category": "Chapter 4: Computer Networks and Internet (M·∫°ng m√°y t√≠nh & Internet)",
        "en": {
            "question": "The physic-layer addresses, sometimes called _______, are locally defined addresses, each of which defines a specific host or router in a network (LAN or WAN).",
            "options": [
                "A. TCP",
                "B. Port numbers",
                "C. MAC addresses",
                "D. IP address"
            ],
            "answer": "C. MAC addresses",
            "explanation": "MAC (Media Access Control) addresses are hardware addresses burned into the network interface card (NIC). They operate at the Data-Link layer (which is closely tied to the Physical layer) and are used for addressing on a local network segment. **Key takeaway: Physical/Local network address = MAC address.**"
        },
        "vi": {
            "question": "C√°c ƒë·ªãa ch·ªâ l·ªõp v·∫≠t l√Ω, ƒë√¥i khi ƒë∆∞·ª£c g·ªçi l√† _______, l√† c√°c ƒë·ªãa ch·ªâ ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a c·ª•c b·ªô, m·ªói ƒë·ªãa ch·ªâ x√°c ƒë·ªãnh m·ªôt m√°y ch·ªß ho·∫∑c b·ªô ƒë·ªãnh tuy·∫øn c·ª• th·ªÉ trong m·ªôt m·∫°ng (LAN ho·∫∑c WAN).",
            "options": [
                "A. TCP",
                "B. S·ªë hi·ªáu c·ªïng",
                "C. ƒê·ªãa ch·ªâ MAC",
                "D. ƒê·ªãa ch·ªâ IP"
            ],
            "answer": "C. ƒê·ªãa ch·ªâ MAC",
            "explanation": "ƒê·ªãa ch·ªâ MAC (Media Access Control) l√† ƒë·ªãa ch·ªâ ph·∫ßn c·ª©ng ƒë∆∞·ª£c ghi v√†o th·∫ª giao di·ªán m·∫°ng (NIC). Ch√∫ng ho·∫°t ƒë·ªông ·ªü l·ªõp Li√™n k·∫øt d·ªØ li·ªáu (li√™n quan ch·∫∑t ch·∫Ω ƒë·∫øn l·ªõp V·∫≠t l√Ω) v√† ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ ƒë·ªãnh ƒë·ªãa ch·ªâ tr√™n m·ªôt ƒëo·∫°n m·∫°ng c·ª•c b·ªô. **M·∫πo ghi nh·ªõ: ƒê·ªãa ch·ªâ m·∫°ng v·∫≠t l√Ω/c·ª•c b·ªô = ƒê·ªãa ch·ªâ MAC.**"
        }
    },
    {
        "id": 144,
        "category": "Chapter 4: Computer Networks and Internet (M·∫°ng m√°y t√≠nh & Internet)",
        "en": {
            "question": "Which network is a packet switching network?",
            "options": [
                "A. Ring network",
                "B. LAN",
                "C. Star network",
                "D. EuroNET"
            ],
            "answer": "D. EuroNET",
            "explanation": "While LANs can use packet switching, EuroNET is a classic example of a large-scale Wide Area Network (WAN) that is fundamentally based on packet switching technology, where data is broken into packets and routed independently. **Key takeaway: Large-scale network like Internet/EuroNET = Packet switching.**"
        },
        "vi": {
            "question": "M·∫°ng n√†o l√† m·∫°ng chuy·ªÉn m·∫°ch g√≥i?",
            "options": [
                "A. M·∫°ng v√≤ng",
                "B. LAN",
                "C. M·∫°ng sao",
                "D. EuroNET"
            ],
            "answer": "D. EuroNET",
            "explanation": "M·∫∑c d√π c√°c m·∫°ng LAN c√≥ th·ªÉ s·ª≠ d·ª•ng chuy·ªÉn m·∫°ch g√≥i, EuroNET l√† m·ªôt v√≠ d·ª• kinh ƒëi·ªÉn v·ªÅ m·ªôt M·∫°ng di·ªán r·ªông (WAN) quy m√¥ l·ªõn v·ªÅ c∆° b·∫£n d·ª±a tr√™n c√¥ng ngh·ªá chuy·ªÉn m·∫°ch g√≥i, trong ƒë√≥ d·ªØ li·ªáu ƒë∆∞·ª£c chia th√†nh c√°c g√≥i v√† ƒë∆∞·ª£c ƒë·ªãnh tuy·∫øn ƒë·ªôc l·∫≠p. **M·∫πo ghi nh·ªõ: M·∫°ng quy m√¥ l·ªõn nh∆∞ Internet/EuroNET = Chuy·ªÉn m·∫°ch g√≥i.**"
        }
    },
    {
        "id": 145,
        "category": "Chapter 4: Computer Networks and Internet (M·∫°ng m√°y t√≠nh & Internet)",
        "en": {
            "question": "What is the fundamental difference between a LAN (Local Area Network) and a WAN (Wide Area Network)?",
            "options": [
                "A. LANs connect network devices (switches, routers), while WANs connect hosts.",
                "B. LANs connect hosts in a limited area, while WANs connect network devices over a large geographical area.",
                "C. LANs always use wireless connections, while WANs are always wired.",
                "D. LANs are owned by telecommunication companies, while WANs are privately owned."
            ],
            "answer": "B. LANs connect hosts in a limited area, while WANs connect network devices over a large geographical area.",
            "explanation": "A LAN connects end-user devices (hosts) within a small, private area. A WAN interconnects networks (via routers/switches) over a wide geographical area and is often owned by service providers. **Key takeaway: LAN = Local = Small, connects hosts. WAN = Wide = Large, connects network devices.**"
        },
        "vi": {
            "question": "S·ª± kh√°c bi·ªát c∆° b·∫£n gi·ªØa m·∫°ng LAN (Local Area Network) v√† m·∫°ng WAN (Wide Area Network) l√† g√¨?",
            "options": [
                "A. LAN k·∫øt n·ªëi c√°c thi·∫øt b·ªã m·∫°ng (switch, router), trong khi WAN k·∫øt n·ªëi c√°c m√°y ch·ªß (host).",
                "B. LAN k·∫øt n·ªëi c√°c m√°y ch·ªß trong m·ªôt khu v·ª±c gi·ªõi h·∫°n, trong khi WAN k·∫øt n·ªëi c√°c thi·∫øt b·ªã m·∫°ng tr√™n m·ªôt khu v·ª±c ƒë·ªãa l√Ω r·ªông l·ªõn.",
                "C. LAN lu√¥n s·ª≠ d·ª•ng k·∫øt n·ªëi kh√¥ng d√¢y, c√≤n WAN lu√¥n c√≥ d√¢y.",
                "D. LAN ƒë∆∞·ª£c s·ªü h·ªØu b·ªüi c√°c c√¥ng ty vi·ªÖn th√¥ng, c√≤n WAN thu·ªôc s·ªü h·ªØu t∆∞ nh√¢n."
            ],
            "answer": "B. LAN k·∫øt n·ªëi c√°c m√°y ch·ªß trong m·ªôt khu v·ª±c gi·ªõi h·∫°n, trong khi WAN k·∫øt n·ªëi c√°c thi·∫øt b·ªã m·∫°ng tr√™n m·ªôt khu v·ª±c ƒë·ªãa l√Ω r·ªông l·ªõn.",
            "explanation": "T√†i li·ªáu (M·ª•c 1.2 & 1.3) n√™u r√µ LAN k·∫øt n·ªëi c√°c host trong m·ªôt khu v·ª±c nh·ªè, c√≤n WAN k·∫øt n·ªëi c√°c thi·∫øt b·ªã m·∫°ng (router, switch) tr√™n m·ªôt khu v·ª±c ƒë·ªãa l√Ω l·ªõn h∆°n. **M·∫πo ghi nh·ªõ: LAN = Local = Nh·ªè, k·∫øt n·ªëi host. WAN = Wide = R·ªông, k·∫øt n·ªëi thi·∫øt b·ªã m·∫°ng.**"
        }
    },
    {
        "id": 146,
        "category": "Chapter 4: Computer Networks and Internet (M·∫°ng m√°y t√≠nh & Internet)",
        "en": {
            "question": "In the TCP/IP protocol suite, which address is used at the Transport Layer to distinguish different processes (applications) running on the same host?",
            "options": [
                "A. IP Address.",
                "B. MAC Address.",
                "C. Port Number.",
                "D. Domain Name."
            ],
            "answer": "C. Port Number.",
            "explanation": "An IP address gets a packet to the correct host, but the port number tells the host's operating system which application or service should receive the data (e.g., port 80 for web servers). **Key takeaway: Transport Layer -> distinguishes applications -> Port Number.**"
        },
        "vi": {
            "question": "Trong b·ªô giao th·ª©c TCP/IP, ƒë·ªãa ch·ªâ n√†o ƒë∆∞·ª£c s·ª≠ d·ª•ng ·ªü l·ªõp V·∫≠n chuy·ªÉn (Transport Layer) ƒë·ªÉ ph√¢n bi·ªát c√°c ti·∫øn tr√¨nh (·ª©ng d·ª•ng) kh√°c nhau ƒëang ch·∫°y tr√™n c√πng m·ªôt m√°y ch·ªß?",
            "options": [
                "A. ƒê·ªãa ch·ªâ IP (IP Address).",
                "B. ƒê·ªãa ch·ªâ MAC (MAC Address).",
                "C. S·ªë hi·ªáu c·ªïng (Port Number).",
                "D. T√™n mi·ªÅn (Domain Name)."
            ],
            "answer": "C. S·ªë hi·ªáu c·ªïng (Port Number).",
            "explanation": "T√†i li·ªáu (M·ª•c 2.2) gi·∫£i th√≠ch r·∫±ng ·ªü l·ªõp Transport, 'Port Numbers' ƒë∆∞·ª£c d√πng ƒë·ªÉ ƒë·∫£m b·∫£o th√¥ng ƒëi·ªáp ƒë∆∞·ª£c g·ª≠i ƒë·∫øn ƒë√∫ng ti·∫øn tr√¨nh ·ª©ng d·ª•ng. **M·∫πo ghi nh·ªõ: Transport Layer -> ph√¢n bi·ªát ·ª©ng d·ª•ng -> Port Number.**"
        }
    },
    {
        "id": 147,
        "category": "Chapter 4: Computer Networks and Internet (M·∫°ng m√°y t√≠nh & Internet)",
        "en": {
            "question": "Which protocol at the Transport Layer provides a connectionless and unreliable data transfer service, suitable for applications like video streaming?",
            "options": [
                "A. TCP (Transmission Control Protocol).",
                "B. UDP (User Datagram Protocol).",
                "C. IP (Internet Protocol).",
                "D. HTTP (HyperText Transfer Protocol)."
            ],
            "answer": "B. UDP (User Datagram Protocol).",
            "explanation": "UDP is a lightweight protocol that offers speed over reliability. It doesn't establish a connection or check for lost packets, making it ideal for real-time applications where a few dropped packets are acceptable. **Key takeaway: UDP = Unreliable = Fast, suitable for streaming.**"
        },
        "vi": {
            "question": "Giao th·ª©c n√†o ·ªü l·ªõp V·∫≠n chuy·ªÉn (Transport Layer) cung c·∫•p d·ªãch v·ª• truy·ªÅn d·ªØ li·ªáu kh√¥ng k·∫øt n·ªëi (connectionless) v√† kh√¥ng ƒë√°ng tin c·∫≠y (unreliable), ph√π h·ª£p cho c√°c ·ª©ng d·ª•ng nh∆∞ streaming video?",
            "options": [
                "A. TCP (Transmission Control Protocol).",
                "B. UDP (User Datagram Protocol).",
                "C. IP (Internet Protocol).",
                "D. HTTP (HyperText Transfer Protocol)."
            ],
            "answer": "B. UDP (User Datagram Protocol).",
            "explanation": "T√†i li·ªáu (M·ª•c 2.2) m√¥ t·∫£ UDP l√† 'Connectionless and unreliable, minimal overhead' v√† 'Best for... streaming'. **M·∫πo ghi nh·ªõ: UDP = Unreliable = Nhanh, ph√π h·ª£p streaming.**"
        }
    },
    {
        "id": 148,
        "category": "Chapter 4: Computer Networks and Internet (M·∫°ng m√°y t√≠nh & Internet)",
        "en": {
            "question": "What is the primary function of the Domain Name System (DNS)?",
            "options": [
                "A. To encrypt data transmitted over the network.",
                "B. To assign dynamic IP addresses to clients.",
                "C. To translate domain names (e.g., www.google.com) into IP addresses.",
                "D. To route packets between different networks."
            ],
            "answer": "C. To translate domain names (e.g., www.google.com) into IP addresses.",
            "explanation": "DNS serves as the 'phonebook of the Internet'. Humans access information online through domain names, but web browsers interact through IP addresses. DNS translates between these two. **Key takeaway: DNS = Translates domain names to IPs.**"
        },
        "vi": {
            "question": "Ch·ª©c nƒÉng ch√≠nh c·ªßa H·ªá th·ªëng T√™n mi·ªÅn (Domain Name System - DNS) l√† g√¨?",
            "options": [
                "A. M√£ h√≥a d·ªØ li·ªáu truy·ªÅn tr√™n m·∫°ng.",
                "B. C·∫•p ph√°t ƒë·ªãa ch·ªâ IP ƒë·ªông cho c√°c m√°y kh√°ch.",
                "C. Chuy·ªÉn ƒë·ªïi t√™n mi·ªÅn (v√≠ d·ª•: www.google.com) th√†nh ƒë·ªãa ch·ªâ IP.",
                "D. ƒê·ªãnh tuy·∫øn c√°c g√≥i tin gi·ªØa c√°c m·∫°ng kh√°c nhau."
            ],
            "answer": "C. Chuy·ªÉn ƒë·ªïi t√™n mi·ªÅn (v√≠ d·ª•: www.google.com) th√†nh ƒë·ªãa ch·ªâ IP.",
            "explanation": "T√†i li·ªáu (M·ª•c 2.1) n√™u r√µ: 'DNS translates domain names into IP addresses' (DNS chuy·ªÉn ƒë·ªïi t√™n mi·ªÅn th√†nh ƒë·ªãa ch·ªâ IP). **M·∫πo ghi nh·ªõ: DNS = D·ªãch t√™n mi·ªÅn sang IP.**"
        }
    },
    {
        "id": 149,
        "category": "Chapter 4: Computer Networks and Internet (M·∫°ng m√°y t√≠nh & Internet)",
        "en": {
            "question": "In a WiFi wireless network, which type of service set uses an Access Point (AP) to connect wireless devices to another LAN/WAN?",
            "options": [
                "A. BSS (Basic Service Set).",
                "B. ESS (Extended Service Set).",
                "C. P2P (Peer-to-Peer).",
                "D. WiMAX."
            ],
            "answer": "B. ESS (Extended Service Set).",
            "explanation": "An ESS is a network composed of two or more BSSs connected by a distribution system. This setup uses Access Points to allow devices to connect to a wider wired network infrastructure. A BSS in infrastructure mode also uses an AP, but ESS specifically refers to extending the network. **Key takeaway: ESS = Extended = uses AP to extend the network.**"
        },
        "vi": {
            "question": "Trong m·∫°ng kh√¥ng d√¢y WiFi, lo·∫°i h√¨nh d·ªãch v·ª• n√†o s·ª≠ d·ª•ng m·ªôt ƒêi·ªÉm truy c·∫≠p (Access Point - AP) ƒë·ªÉ k·∫øt n·ªëi c√°c thi·∫øt b·ªã kh√¥ng d√¢y v·ªõi m·ªôt m·∫°ng LAN/WAN kh√°c?",
            "options": [
                "A. BSS (Basic Service Set).",
                "B. ESS (Extended Service Set).",
                "C. P2P (Peer-to-Peer).",
                "D. WiMAX."
            ],
            "answer": "B. ESS (Extended Service Set).",
            "explanation": "T√†i li·ªáu (M·ª•c 2.4) ƒë·ªãnh nghƒ©a ESS l√† 'uses an Access Point (AP) to connect to other LANs/WANs'. BSS l√† k·∫øt n·ªëi tr·ª±c ti·∫øp gi·ªØa c√°c thi·∫øt b·ªã m√† kh√¥ng c·∫ßn AP. **M·∫πo ghi nh·ªõ: ESS = Extended = c√≥ AP ƒë·ªÉ m·ªü r·ªông m·∫°ng.**"
        }
    },
    {
        "id": 150,
        "category": "Chapter 5: Operating System (H·ªá ƒëi·ªÅu h√†nh)",
        "en": {
            "question": "In ____, more than one program is in memory at the same time and they are executed concurrently.",
            "options": [
                "A. Operating system",
                "B. Multiprogramming",
                "C. Monoprogramming",
                "D. Microprogramming"
            ],
            "answer": "B. Multiprogramming",
            "explanation": "Multiprogramming is the technique of keeping multiple programs in main memory at once, allowing the CPU to switch between them to maximize its utilization. **Key takeaway: Multiple programs in memory = Multiprogramming.**"
        },
        "vi": {
            "question": "Trong ____, nhi·ªÅu h∆°n m·ªôt ch∆∞∆°ng tr√¨nh ƒë∆∞·ª£c l∆∞u trong b·ªô nh·ªõ c√πng m·ªôt l√∫c v√† ch√∫ng ƒë∆∞·ª£c th·ª±c thi ƒë·ªìng th·ªùi.",
            "options": [
                "A. H·ªá ƒëi·ªÅu h√†nh",
                "B. ƒêa ch∆∞∆°ng (Multiprogramming)",
                "C. ƒê∆°n ch∆∞∆°ng (Monoprogramming)",
                "D. Vi l·∫≠p tr√¨nh (Microprogramming)"
            ],
            "answer": "B. ƒêa ch∆∞∆°ng (Multiprogramming)",
            "explanation": "ƒêa ch∆∞∆°ng l√† k·ªπ thu·∫≠t gi·ªØ nhi·ªÅu ch∆∞∆°ng tr√¨nh trong b·ªô nh·ªõ ch√≠nh c√πng m·ªôt l√∫c, cho ph√©p CPU chuy·ªÉn ƒë·ªïi gi·ªØa ch√∫ng ƒë·ªÉ t·ªëi ƒëa h√≥a vi·ªác s·ª≠ d·ª•ng. **M·∫πo ghi nh·ªõ: Nhi·ªÅu ch∆∞∆°ng tr√¨nh trong b·ªô nh·ªõ = ƒêa ch∆∞∆°ng.**"
        }
    },
    {
        "id": 151,
        "category": "Chapter 5: Operating System (H·ªá ƒëi·ªÅu h√†nh)",
        "en": {
            "question": "A ____ is a non-active set of instructions stored on disk.",
            "options": [
                "A. Program",
                "B. Process",
                "C. Task",
                "D. Job"
            ],
            "answer": "A. Program",
            "explanation": "A program is a passive entity; it's a file containing executable code and data stored on a disk. It only becomes a process (an active entity) when the operating system loads it into memory and begins execution. **Key takeaway: Non-active instructions on disk = Program.**"
        },
        "vi": {
            "question": "M·ªôt ____ l√† m·ªôt t·∫≠p h·ª£p c√°c ch·ªâ th·ªã kh√¥ng ho·∫°t ƒë·ªông ƒë∆∞·ª£c l∆∞u tr·ªØ tr√™n ƒëƒ©a.",
            "options": [
                "A. Ch∆∞∆°ng tr√¨nh",
                "B. Ti·∫øn tr√¨nh",
                "C. T√°c v·ª•",
                "D. C√¥ng vi·ªác"
            ],
            "answer": "A. Ch∆∞∆°ng tr√¨nh",
            "explanation": "M·ªôt ch∆∞∆°ng tr√¨nh l√† m·ªôt th·ª±c th·ªÉ th·ª• ƒë·ªông; n√≥ l√† m·ªôt t·ªáp ch·ª©a m√£ th·ª±c thi v√† d·ªØ li·ªáu ƒë∆∞·ª£c l∆∞u tr·ªØ tr√™n ƒëƒ©a. N√≥ ch·ªâ tr·ªü th√†nh m·ªôt ti·∫øn tr√¨nh (m·ªôt th·ª±c th·ªÉ ch·ªß ƒë·ªông) khi h·ªá ƒëi·ªÅu h√†nh n·∫°p n√≥ v√†o b·ªô nh·ªõ v√† b·∫Øt ƒë·∫ßu th·ª±c thi. **M·∫πo ghi nh·ªõ: Ch·ªâ th·ªã kh√¥ng ho·∫°t ƒë·ªông tr√™n ƒëƒ©a = Ch∆∞∆°ng tr√¨nh.**"
        }
    },
    {
        "id": 152,
        "category": "Chapter 5: Operating System (H·ªá ƒëi·ªÅu h√†nh)",
        "en": {
            "question": "What is a program of UNIX that accepts requests from users and interprets them for the rest of the operating system?",
            "options": [
                "A. Software",
                "B. Function",
                "C. SHELL",
                "D. Feature"
            ],
            "answer": "C. SHELL",
            "explanation": "The shell is the command-line interpreter in UNIX-like systems. It's the program that provides the user interface for accessing the operating system's services. **Key takeaway: UNIX command interpreter = Shell.**"
        },
        "vi": {
            "question": "Ch∆∞∆°ng tr√¨nh n√†o c·ªßa UNIX ch·∫•p nh·∫≠n c√°c y√™u c·∫ßu t·ª´ ng∆∞·ªùi d√πng v√† di·ªÖn gi·∫£i ch√∫ng cho ph·∫ßn c√≤n l·∫°i c·ªßa h·ªá ƒëi·ªÅu h√†nh?",
            "options": [
                "A. Ph·∫ßn m·ªÅm",
                "B. H√†m",
                "C. SHELL",
                "D. T√≠nh nƒÉng"
            ],
            "answer": "C. SHELL",
            "explanation": "Shell l√† tr√¨nh th√¥ng d·ªãch d√≤ng l·ªánh trong c√°c h·ªá th·ªëng gi·ªëng UNIX. N√≥ l√† ch∆∞∆°ng tr√¨nh cung c·∫•p giao di·ªán ng∆∞·ªùi d√πng ƒë·ªÉ truy c·∫≠p c√°c d·ªãch v·ª• c·ªßa h·ªá ƒëi·ªÅu h√†nh. **M·∫πo ghi nh·ªõ: Tr√¨nh th√¥ng d·ªãch l·ªánh UNIX = Shell.**"
        }
    },
    {
        "id": 153,
        "category": "Chapter 5: Operating System (H·ªá ƒëi·ªÅu h√†nh)",
        "en": {
            "question": "In the _______ method for synchronizing the operation of the CPU with an I/O device, the CPU is idle until the I/O operation is finished.",
            "options": [
                "A. programmed I/O",
                "B. interrupt-driven I/O",
                "C. DMA",
                "D. channel I/O"
            ],
            "answer": "A. programmed I/O",
            "explanation": "Programmed I/O involves 'busy-waiting', where the CPU continuously polls the status of the I/O device in a loop, wasting CPU cycles and remaining idle from other tasks until the I/O is complete. **Key takeaway: CPU is idle/busy-waiting = Programmed I/O.**"
        },
        "vi": {
            "question": "Trong ph∆∞∆°ng ph√°p _______ ƒë·ªÉ ƒë·ªìng b·ªô h√≥a ho·∫°t ƒë·ªông c·ªßa CPU v·ªõi m·ªôt thi·∫øt b·ªã I/O, CPU s·∫Ω ·ªü tr·∫°ng th√°i ch·ªù cho ƒë·∫øn khi ho·∫°t ƒë·ªông I/O k·∫øt th√∫c.",
            "options": [
                "A. I/O ƒë∆∞·ª£c l·∫≠p tr√¨nh",
                "B. I/O ƒëi·ªÅu khi·ªÉn b·∫±ng ng·∫Øt",
                "C. DMA",
                "D. k√™nh I/O"
            ],
            "answer": "A. I/O ƒë∆∞·ª£c l·∫≠p tr√¨nh",
            "explanation": "I/O ƒë∆∞·ª£c l·∫≠p tr√¨nh li√™n quan ƒë·∫øn 'ch·ªù b·∫≠n', trong ƒë√≥ CPU li√™n t·ª•c thƒÉm d√≤ tr·∫°ng th√°i c·ªßa thi·∫øt b·ªã I/O trong m·ªôt v√≤ng l·∫∑p, l√£ng ph√≠ chu k·ª≥ CPU v√† kh√¥ng l√†m c√°c t√°c v·ª• kh√°c cho ƒë·∫øn khi I/O ho√†n t·∫•t. **M·∫πo ghi nh·ªõ: CPU ch·ªù/b·∫≠n r·ªôn = I/O ƒë∆∞·ª£c l·∫≠p tr√¨nh.**"
        }
    },
    {
        "id": 154,
        "category": "Chapter 5: Operating System (H·ªá ƒëi·ªÅu h√†nh)",
        "en": {
            "question": "In the _______ method for synchronizing the operation of the CPU with an I/O device, a large block of data can be passed from an I/O device to memory directly.",
            "options": [
                "A. programmed I/O",
                "B. interrupt-driven I/O",
                "C. DMA (Direct Memory Access)",
                "D. manual I/O"
            ],
            "answer": "C. DMA (Direct Memory Access)",
            "explanation": "DMA allows an I/O device to transfer a block of data directly to or from main memory without involving the CPU for every byte. The CPU just sets up the transfer and is then free to do other work. **Key takeaway: Direct transfer device-to-memory = DMA.**"
        },
        "vi": {
            "question": "Trong ph∆∞∆°ng ph√°p _______ ƒë·ªÉ ƒë·ªìng b·ªô h√≥a ho·∫°t ƒë·ªông c·ªßa CPU v·ªõi m·ªôt thi·∫øt b·ªã I/O, m·ªôt kh·ªëi d·ªØ li·ªáu l·ªõn c√≥ th·ªÉ ƒë∆∞·ª£c truy·ªÅn tr·ª±c ti·∫øp t·ª´ m·ªôt thi·∫øt b·ªã I/O ƒë·∫øn b·ªô nh·ªõ.",
            "options": [
                "A. I/O ƒë∆∞·ª£c l·∫≠p tr√¨nh",
                "B. I/O ƒëi·ªÅu khi·ªÉn b·∫±ng ng·∫Øt",
                "C. DMA (Truy c·∫≠p b·ªô nh·ªõ tr·ª±c ti·∫øp)",
                "D. I/O th·ªß c√¥ng"
            ],
            "answer": "C. DMA (Truy c·∫≠p b·ªô nh·ªõ tr·ª±c ti·∫øp)",
            "explanation": "DMA cho ph√©p m·ªôt thi·∫øt b·ªã I/O truy·ªÅn m·ªôt kh·ªëi d·ªØ li·ªáu tr·ª±c ti·∫øp ƒë·∫øn ho·∫∑c t·ª´ b·ªô nh·ªõ ch√≠nh m√† kh√¥ng c·∫ßn s·ª± tham gia c·ªßa CPU cho m·ªói byte. CPU ch·ªâ c·∫ßn thi·∫øt l·∫≠p vi·ªác truy·ªÅn v√† sau ƒë√≥ c√≥ th·ªÉ t·ª± do l√†m vi·ªác kh√°c. **M·∫πo ghi nh·ªõ: Truy·ªÅn tr·ª±c ti·∫øp thi·∫øt b·ªã-b·ªô nh·ªõ = DMA.**"
        }
    },
    {
        "id": 155,
        "category": "Chapter 5: Operating System (H·ªá ƒëi·ªÅu h√†nh)",
        "en": {
            "question": "_______ were designed in the 1950s to control mainframe computers.",
            "options": [
                "A. Personal systems",
                "B. Parallel systems",
                "C. Batch operating systems",
                "D. Time-sharing systems"
            ],
            "answer": "C. Batch operating systems",
            "explanation": "Early mainframe computers in the 1950s were controlled by batch operating systems. Jobs were submitted on punched cards or tape and executed sequentially in a 'batch' without user interaction. **Key takeaway: 1950s / Mainframes / No interaction = Batch OS.**"
        },
        "vi": {
            "question": "_______ ƒë∆∞·ª£c thi·∫øt k·∫ø v√†o nh·ªØng nƒÉm 1950 ƒë·ªÉ ƒëi·ªÅu khi·ªÉn c√°c m√°y t√≠nh l·ªõn (mainframe).",
            "options": [
                "A. H·ªá th·ªëng c√° nh√¢n",
                "B. H·ªá th·ªëng song song",
                "C. H·ªá ƒëi·ªÅu h√†nh x·ª≠ l√Ω theo l√¥",
                "D. H·ªá th·ªëng chia s·∫ª th·ªùi gian"
            ],
            "answer": "C. H·ªá ƒëi·ªÅu h√†nh x·ª≠ l√Ω theo l√¥",
            "explanation": "C√°c m√°y t√≠nh l·ªõn ƒë·ªùi ƒë·∫ßu trong nh·ªØng nƒÉm 1950 ƒë∆∞·ª£c ƒëi·ªÅu khi·ªÉn b·ªüi c√°c h·ªá ƒëi·ªÅu h√†nh x·ª≠ l√Ω theo l√¥. C√°c c√¥ng vi·ªác ƒë∆∞·ª£c g·ª≠i tr√™n th·∫ª ƒë·ª•c l·ªó ho·∫∑c bƒÉng t·ª´ v√† ƒë∆∞·ª£c th·ª±c thi tu·∫ßn t·ª± theo m·ªôt 'l√¥' m√† kh√¥ng c√≥ s·ª± t∆∞∆°ng t√°c c·ªßa ng∆∞·ªùi d√πng. **M·∫πo ghi nh·ªõ: Th·∫≠p ni√™n 1950 / Mainframe / Kh√¥ng t∆∞∆°ng t√°c = HƒêH x·ª≠ l√Ω theo l√¥.**"
        }
    },
    {
        "id": 156,
        "category": "Chapter 5: Operating System (H·ªá ƒëi·ªÅu h√†nh)",
        "en": {
            "question": "What happens if the size of memory is less than the size of the program in a monoprogramming OS?",
            "options": [
                "A. Need to use virtual memory",
                "B. No overflow",
                "C. Overflow",
                "D. The program cannot be run"
            ],
            "answer": "D. The program cannot be run",
            "explanation": "In a simple monoprogramming system without virtual memory, the entire program must fit into the available physical memory to be executed. If it's too large, it simply cannot be loaded and run. **Key takeaway: Monoprogramming requires program to fit in memory.**"
        },
        "vi": {
            "question": "ƒêi·ªÅu g√¨ x·∫£y ra n·∫øu k√≠ch th∆∞·ªõc c·ªßa b·ªô nh·ªõ nh·ªè h∆°n k√≠ch th∆∞·ªõc c·ªßa ch∆∞∆°ng tr√¨nh trong m·ªôt HƒêH ƒë∆°n ch∆∞∆°ng?",
            "options": [
                "A. C·∫ßn s·ª≠ d·ª•ng b·ªô nh·ªõ ·∫£o",
                "B. Kh√¥ng tr√†n",
                "C. Tr√†n",
                "D. Ch∆∞∆°ng tr√¨nh kh√¥ng th·ªÉ ch·∫°y"
            ],
            "answer": "D. Ch∆∞∆°ng tr√¨nh kh√¥ng th·ªÉ ch·∫°y",
            "explanation": "Trong m·ªôt h·ªá th·ªëng ƒë∆°n ch∆∞∆°ng ƒë∆°n gi·∫£n kh√¥ng c√≥ b·ªô nh·ªõ ·∫£o, to√†n b·ªô ch∆∞∆°ng tr√¨nh ph·∫£i v·ª´a v·ªõi b·ªô nh·ªõ v·∫≠t l√Ω c√≥ s·∫µn ƒë·ªÉ ƒë∆∞·ª£c th·ª±c thi. N·∫øu n√≥ qu√° l·ªõn, n√≥ ƒë∆°n gi·∫£n l√† kh√¥ng th·ªÉ ƒë∆∞·ª£c n·∫°p v√† ch·∫°y. **M·∫πo ghi nh·ªõ: ƒê∆°n ch∆∞∆°ng y√™u c·∫ßu ch∆∞∆°ng tr√¨nh ph·∫£i v·ª´a trong b·ªô nh·ªõ.**"
        }
    },
    {
        "id": 157,
        "category": "Chapter 5: Operating System (H·ªá ƒëi·ªÅu h√†nh)",
        "en": {
            "question": "The device manager maintains one or more ____ for similar input/output devices.",
            "options": [
                "A. Graph",
                "B. Array",
                "C. Stack",
                "D. Queue"
            ],
            "answer": "D. Queue",
            "explanation": "When multiple processes request to use a single I/O device (like a printer), the OS device manager places these requests in a queue (usually FIFO - First-In, First-Out) to be serviced one by one. **Key takeaway: Device requests are managed in a Queue.**"
        },
        "vi": {
            "question": "Tr√¨nh qu·∫£n l√Ω thi·∫øt b·ªã duy tr√¨ m·ªôt ho·∫∑c nhi·ªÅu ____ cho c√°c thi·∫øt b·ªã ƒë·∫ßu v√†o/ƒë·∫ßu ra t∆∞∆°ng t·ª±.",
            "options": [
                "A. ƒê·ªì th·ªã",
                "B. M·∫£ng",
                "C. NgƒÉn x·∫øp",
                "D. H√†ng ƒë·ª£i"
            ],
            "answer": "D. H√†ng ƒë·ª£i",
            "explanation": "Khi nhi·ªÅu ti·∫øn tr√¨nh y√™u c·∫ßu s·ª≠ d·ª•ng m·ªôt thi·∫øt b·ªã I/O duy nh·∫•t (nh∆∞ m√°y in), tr√¨nh qu·∫£n l√Ω thi·∫øt b·ªã c·ªßa HƒêH s·∫Ω ƒë·∫∑t c√°c y√™u c·∫ßu n√†y v√†o m·ªôt h√†ng ƒë·ª£i (th∆∞·ªùng l√† FIFO - V√†o tr∆∞·ªõc, Ra tr∆∞·ªõc) ƒë·ªÉ ƒë∆∞·ª£c ph·ª•c v·ª• l·∫ßn l∆∞·ª£t. **M·∫πo ghi nh·ªõ: C√°c y√™u c·∫ßu thi·∫øt b·ªã ƒë∆∞·ª£c qu·∫£n l√Ω trong m·ªôt H√†ng ƒë·ª£i.**"
        }
    },
    {
        "id": 158,
        "category": "Chapter 5: Operating System (H·ªá ƒëi·ªÅu h√†nh)",
        "en": {
            "question": "The _______ is the highest level in the file system hierarchy. This does not have a parent directory.",
            "options": [
                "A. Root directory",
                "B. Home directory",
                "C. Working directory",
                "D. Parent directory"
            ],
            "answer": "A. Root directory",
            "explanation": "The root directory is the top-level directory of a file system, represented by `/` in Unix-like systems and a drive letter like `C:\\` in Windows. It contains all other directories and files. **Key takeaway: Highest level directory = Root.**"
        },
        "vi": {
            "question": "_______ l√† c·∫•p cao nh·∫•t trong h·ªá th·ªëng ph√¢n c·∫•p t·ªáp. N√≥ kh√¥ng c√≥ th∆∞ m·ª•c cha.",
            "options": [
                "A. Th∆∞ m·ª•c g·ªëc",
                "B. Th∆∞ m·ª•c nh√†",
                "C. Th∆∞ m·ª•c l√†m vi·ªác",
                "D. Th∆∞ m·ª•c cha"
            ],
            "answer": "A. Th∆∞ m·ª•c g·ªëc",
            "explanation": "Th∆∞ m·ª•c g·ªëc l√† th∆∞ m·ª•c c·∫•p cao nh·∫•t c·ªßa m·ªôt h·ªá th·ªëng t·ªáp, ƒë∆∞·ª£c bi·ªÉu di·ªÖn b·∫±ng `/` trong c√°c h·ªá th·ªëng gi·ªëng Unix v√† m·ªôt k√Ω t·ª± ·ªï ƒëƒ©a nh∆∞ `C:\\` trong Windows. N√≥ ch·ª©a t·∫•t c·∫£ c√°c th∆∞ m·ª•c v√† t·ªáp kh√°c. **M·∫πo ghi nh·ªõ: Th∆∞ m·ª•c c·∫•p cao nh·∫•t = G·ªëc (Root).**"
        }
    },
    {
        "id": 159,
        "category": "Chapter 5: Operating System (H·ªá ƒëi·ªÅu h√†nh)",
        "en": {
            "question": "The ____ (or current directory) is the directory we are 'in' at any point in a user session.",
            "options": [
                "A. Root directory",
                "B. Home directory",
                "C. Working directory",
                "D. Parent directory"
            ],
            "answer": "C. Working directory",
            "explanation": "The working directory (or current directory) is the default location where commands operate and where files are created if no other path is specified. **Key takeaway: Current location = Working directory.**"
        },
        "vi": {
            "question": "____ (ho·∫∑c th∆∞ m·ª•c hi·ªán t·∫°i) l√† th∆∞ m·ª•c ch√∫ng ta ƒëang '·ªü' t·∫°i b·∫•t k·ª≥ th·ªùi ƒëi·ªÉm n√†o trong m·ªôt phi√™n l√†m vi·ªác c·ªßa ng∆∞·ªùi d√πng.",
            "options": [
                "A. Th∆∞ m·ª•c g·ªëc",
                "B. Th∆∞ m·ª•c nh√†",
                "C. Th∆∞ m·ª•c l√†m vi·ªác",
                "D. Th∆∞ m·ª•c cha"
            ],
            "answer": "C. Th∆∞ m·ª•c l√†m vi·ªác",
            "explanation": "Th∆∞ m·ª•c l√†m vi·ªác (ho·∫∑c th∆∞ m·ª•c hi·ªán t·∫°i) l√† v·ªã tr√≠ m·∫∑c ƒë·ªãnh n∆°i c√°c l·ªánh ho·∫°t ƒë·ªông v√† n∆°i c√°c t·ªáp ƒë∆∞·ª£c t·∫°o ra n·∫øu kh√¥ng c√≥ ƒë∆∞·ªùng d·∫´n n√†o kh√°c ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh. **M·∫πo ghi nh·ªõ: V·ªã tr√≠ hi·ªán t·∫°i = Th∆∞ m·ª•c l√†m vi·ªác.**"
        }
    },
    {
        "id": 160,
        "category": "Chapter 5: Operating System (H·ªá ƒëi·ªÅu h√†nh)",
        "en": {
            "question": "We use our ____ when we first log in to the system. This contains any files we create while in it.",
            "options": [
                "A. Root directory",
                "B. Working directory",
                "C. Home directory",
                "D. Parent directory"
            ],
            "answer": "C. Home directory",
            "explanation": "The home directory is the personal directory assigned to a user upon login. It's the default working directory at the start of a session and where user-specific configuration files are stored. **Key takeaway: User's personal directory = Home directory.**"
        },
        "vi": {
            "question": "Ch√∫ng ta s·ª≠ d·ª•ng ____ c·ªßa m√¨nh khi l·∫ßn ƒë·∫ßu ti√™n ƒëƒÉng nh·∫≠p v√†o h·ªá th·ªëng. N√≥ ch·ª©a b·∫•t k·ª≥ t·ªáp n√†o ch√∫ng ta t·∫°o ra khi ·ªü trong ƒë√≥.",
            "options": [
                "A. Th∆∞ m·ª•c g·ªëc",
                "B. Th∆∞ m·ª•c l√†m vi·ªác",
                "C. Th∆∞ m·ª•c nh√†",
                "D. Th∆∞ m·ª•c cha"
            ],
            "answer": "C. Th∆∞ m·ª•c nh√†",
            "explanation": "Th∆∞ m·ª•c nh√† l√† th∆∞ m·ª•c c√° nh√¢n ƒë∆∞·ª£c g√°n cho ng∆∞·ªùi d√πng khi ƒëƒÉng nh·∫≠p. N√≥ l√† th∆∞ m·ª•c l√†m vi·ªác m·∫∑c ƒë·ªãnh khi b·∫Øt ƒë·∫ßu m·ªôt phi√™n v√† l√† n∆°i l∆∞u tr·ªØ c√°c t·ªáp c·∫•u h√¨nh d√†nh ri√™ng cho ng∆∞·ªùi d√πng. **M·∫πo ghi nh·ªõ: Th∆∞ m·ª•c c√° nh√¢n c·ªßa ng∆∞·ªùi d√πng = Th∆∞ m·ª•c nh√†.**"
        }
    },
    {
        "id": 161,
        "category": "Chapter 5: Operating System (H·ªá ƒëi·ªÅu h√†nh)",
        "en": {
            "question": "Which access method is used for obtaining a record from a cassette tape?",
            "options": [
                "A. Direct",
                "B. Sequential",
                "C. Random",
                "D. All of the others"
            ],
            "answer": "B. Sequential",
            "explanation": "Magnetic tape is a sequential access medium. To get to a specific record, you must read or fast-forward through all the records that come before it, just like a cassette tape. **Key takeaway: Tape = Sequential access.**"
        },
        "vi": {
            "question": "Ph∆∞∆°ng ph√°p truy c·∫≠p n√†o ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ l·∫•y m·ªôt b·∫£n ghi t·ª´ m·ªôt bƒÉng cassette?",
            "options": [
                "A. Tr·ª±c ti·∫øp",
                "B. Tu·∫ßn t·ª±",
                "C. Ng·∫´u nhi√™n",
                "D. T·∫•t c·∫£ c√°c ph∆∞∆°ng √°n kh√°c"
            ],
            "answer": "B. Tu·∫ßn t·ª±",
            "explanation": "BƒÉng t·ª´ l√† m·ªôt ph∆∞∆°ng ti·ªán truy c·∫≠p tu·∫ßn t·ª±. ƒê·ªÉ ƒë·∫øn ƒë∆∞·ª£c m·ªôt b·∫£n ghi c·ª• th·ªÉ, b·∫°n ph·∫£i ƒë·ªçc ho·∫∑c tua nhanh qua t·∫•t c·∫£ c√°c b·∫£n ghi tr∆∞·ªõc ƒë√≥, gi·ªëng nh∆∞ m·ªôt bƒÉng cassette. **M·∫πo ghi nh·ªõ: BƒÉng t·ª´ = Truy c·∫≠p tu·∫ßn t·ª±.**"
        }
    },
    {
        "id": 162,
        "category": "Chapter 5: Operating System (H·ªá ƒëi·ªÅu h√†nh)",
        "en": {
            "question": "A multi programming system is one that can",
            "options": [
                "A. Run very fast",
                "B. Share hardware resources with many programs simultaneously",
                "C. Compute many programs simultaneously",
                "D. Use many operating systems"
            ],
            "answer": "B. Share hardware resources with many programs simultaneously",
            "explanation": "The essence of multiprogramming is to keep multiple programs in memory and switch the CPU between them, effectively sharing the CPU and other hardware resources to maximize throughput and efficiency. **Key takeaway: Multiprogramming = Share resources among programs.**"
        },
        "vi": {
            "question": "M·ªôt h·ªá th·ªëng ƒëa ch∆∞∆°ng l√† m·ªôt h·ªá th·ªëng c√≥ th·ªÉ",
            "options": [
                "A. Ch·∫°y r·∫•t nhanh",
                "B. Chia s·∫ª t√†i nguy√™n ph·∫ßn c·ª©ng v·ªõi nhi·ªÅu ch∆∞∆°ng tr√¨nh ƒë·ªìng th·ªùi",
                "C. T√≠nh to√°n nhi·ªÅu ch∆∞∆°ng tr√¨nh ƒë·ªìng th·ªùi",
                "D. S·ª≠ d·ª•ng nhi·ªÅu h·ªá ƒëi·ªÅu h√†nh"
            ],
            "answer": "B. Chia s·∫ª t√†i nguy√™n ph·∫ßn c·ª©ng v·ªõi nhi·ªÅu ch∆∞∆°ng tr√¨nh ƒë·ªìng th·ªùi",
            "explanation": "B·∫£n ch·∫•t c·ªßa ƒëa ch∆∞∆°ng l√† gi·ªØ nhi·ªÅu ch∆∞∆°ng tr√¨nh trong b·ªô nh·ªõ v√† chuy·ªÉn ƒë·ªïi CPU gi·ªØa ch√∫ng, chia s·∫ª hi·ªáu qu·∫£ CPU v√† c√°c t√†i nguy√™n ph·∫ßn c·ª©ng kh√°c ƒë·ªÉ t·ªëi ƒëa h√≥a th√¥ng l∆∞·ª£ng v√† hi·ªáu qu·∫£. **M·∫πo ghi nh·ªõ: ƒêa ch∆∞∆°ng = Chia s·∫ª t√†i nguy√™n gi·ªØa c√°c ch∆∞∆°ng tr√¨nh.**"
        }
    },
    {
        "id": 163,
        "category": "Chapter 5: Operating System (H·ªá ƒëi·ªÅu h√†nh)",
        "en": {
            "question": "A program becomes a _______ when it is selected by the operating system and brought to the hold state.",
            "options": [
                "A. Job",
                "B. Process",
                "C. Deadlock",
                "D. Partition"
            ],
            "answer": "B. Process",
            "explanation": "A program on disk is a passive 'job'. When the OS decides to run it, it loads it into memory and creates a data structure to manage it (Process Control Block). At this point, it becomes an active 'process'. **Key takeaway: Program in execution = Process.**"
        },
        "vi": {
            "question": "M·ªôt ch∆∞∆°ng tr√¨nh tr·ªü th√†nh m·ªôt _______ khi n√≥ ƒë∆∞·ª£c h·ªá ƒëi·ªÅu h√†nh ch·ªçn v√† ƒë∆∞a v√†o tr·∫°ng th√°i ch·ªù.",
            "options": [
                "A. C√¥ng vi·ªác",
                "B. Ti·∫øn tr√¨nh",
                "C. B·∫ø t·∫Øc",
                "D. Ph√¢n v√πng"
            ],
            "answer": "B. Ti·∫øn tr√¨nh",
            "explanation": "M·ªôt ch∆∞∆°ng tr√¨nh tr√™n ƒëƒ©a l√† m·ªôt 'c√¥ng vi·ªác' th·ª• ƒë·ªông. Khi HƒêH quy·∫øt ƒë·ªãnh ch·∫°y n√≥, n√≥ s·∫Ω n·∫°p ch∆∞∆°ng tr√¨nh v√†o b·ªô nh·ªõ v√† t·∫°o m·ªôt c·∫•u tr√∫c d·ªØ li·ªáu ƒë·ªÉ qu·∫£n l√Ω n√≥ (Kh·ªëi ƒëi·ªÅu khi·ªÉn ti·∫øn tr√¨nh). T·∫°i th·ªùi ƒëi·ªÉm n√†y, n√≥ tr·ªü th√†nh m·ªôt 'ti·∫øn tr√¨nh' ch·ªß ƒë·ªông. **M·∫πo ghi nh·ªõ: Ch∆∞∆°ng tr√¨nh ƒëang th·ª±c thi = Ti·∫øn tr√¨nh.**"
        }
    },
    {
        "id": 164,
        "category": "Chapter 5: Operating System (H·ªá ƒëi·ªÅu h√†nh)",
        "en": {
            "question": "The _______ scheduler creates a process from a job and changes a process back to a job.",
            "options": [
                "A. Job",
                "B. Process",
                "C. Virtual",
                "D. Queue"
            ],
            "answer": "A. Job",
            "explanation": "The Job Scheduler, also known as the long-term scheduler, selects jobs from a queue on the disk and loads them into memory to become processes. It controls the degree of multiprogramming. **Key takeaway: Job <-> Process = Job/Long-term scheduler.**"
        },
        "vi": {
            "question": "B·ªô l·∫≠p l·ªãch _______ t·∫°o m·ªôt ti·∫øn tr√¨nh t·ª´ m·ªôt c√¥ng vi·ªác v√† thay ƒë·ªïi m·ªôt ti·∫øn tr√¨nh tr·ªü l·∫°i th√†nh m·ªôt c√¥ng vi·ªác.",
            "options": [
                "A. C√¥ng vi·ªác",
                "B. Ti·∫øn tr√¨nh",
                "C. ·∫¢o",
                "D. H√†ng ƒë·ª£i"
            ],
            "answer": "A. C√¥ng vi·ªác",
            "explanation": "B·ªô l·∫≠p l·ªãch C√¥ng vi·ªác, c√≤n ƒë∆∞·ª£c g·ªçi l√† b·ªô l·∫≠p l·ªãch d√†i h·∫°n, ch·ªçn c√°c c√¥ng vi·ªác t·ª´ m·ªôt h√†ng ƒë·ª£i tr√™n ƒëƒ©a v√† n·∫°p ch√∫ng v√†o b·ªô nh·ªõ ƒë·ªÉ tr·ªü th√†nh c√°c ti·∫øn tr√¨nh. N√≥ ki·ªÉm so√°t m·ª©c ƒë·ªô ƒëa ch∆∞∆°ng. **M·∫πo ghi nh·ªõ: C√¥ng vi·ªác <-> Ti·∫øn tr√¨nh = B·ªô l·∫≠p l·ªãch C√¥ng vi·ªác/D√†i h·∫°n.**"
        }
    },
    {
        "id": 165,
        "category": "Chapter 5: Operating System (H·ªá ƒëi·ªÅu h√†nh)",
        "en": {
            "question": "The _______ scheduler moves a process from one process state to another.",
            "options": [
                "A. Job",
                "B. Process",
                "C. Virtual",
                "D. Queue"
            ],
            "answer": "B. Process",
            "explanation": "The Process Scheduler, also known as the short-term scheduler or CPU scheduler, is responsible for selecting a process from the 'Ready' queue and dispatching it to the CPU, thus changing its state to 'Running'. It also handles other state transitions. **Key takeaway: State transitions = Process/Short-term scheduler.**"
        },
        "vi": {
            "question": "B·ªô l·∫≠p l·ªãch _______ di chuy·ªÉn m·ªôt ti·∫øn tr√¨nh t·ª´ tr·∫°ng th√°i n√†y sang tr·∫°ng th√°i kh√°c.",
            "options": [
                "A. C√¥ng vi·ªác",
                "B. Ti·∫øn tr√¨nh",
                "C. ·∫¢o",
                "D. H√†ng ƒë·ª£i"
            ],
            "answer": "B. Ti·∫øn tr√¨nh",
            "explanation": "B·ªô l·∫≠p l·ªãch Ti·∫øn tr√¨nh, c√≤n ƒë∆∞·ª£c g·ªçi l√† b·ªô l·∫≠p l·ªãch ng·∫Øn h·∫°n ho·∫∑c b·ªô l·∫≠p l·ªãch CPU, ch·ªãu tr√°ch nhi·ªám ch·ªçn m·ªôt ti·∫øn tr√¨nh t·ª´ h√†ng ƒë·ª£i 'S·∫µn s√†ng' v√† g·ª≠i n√≥ ƒë·∫øn CPU, do ƒë√≥ thay ƒë·ªïi tr·∫°ng th√°i c·ªßa n√≥ th√†nh 'ƒêang ch·∫°y'. N√≥ c≈©ng x·ª≠ l√Ω c√°c chuy·ªÉn ƒë·ªïi tr·∫°ng th√°i kh√°c. **M·∫πo ghi nh·ªõ: Chuy·ªÉn ƒë·ªïi tr·∫°ng th√°i = B·ªô l·∫≠p l·ªãch Ti·∫øn tr√¨nh/Ng·∫Øn h·∫°n.**"
        }
    },
    {
        "id": 166,
        "category": "Chapter 5: Operating System (H·ªá ƒëi·ªÅu h√†nh)",
        "en": {
            "question": "Why OS is responsible for the efficient use of input/output devices?",
            "options": [
                "A. Because need to maintains a queue for each input/output device",
                "B. Because these devices are slower in speed compared with the CPU and memory",
                "C. It may use FIFO for one device",
                "D. The manager also needs to know when a device has finished serving one process"
            ],
            "answer": "B. Because these devices are slower in speed compared with the CPU and memory",
            "explanation": "The fundamental problem in I/O management is the vast speed difference between the CPU and I/O devices (the 'I/O bottleneck'). The OS's role is to manage this difference using techniques like buffering, queuing, and interrupts so the fast CPU isn't constantly waiting for slow devices. **Key takeaway: OS manages I/O because of the CPU-I/O speed gap.**"
        },
        "vi": {
            "question": "T·∫°i sao HƒêH ch·ªãu tr√°ch nhi·ªám v·ªÅ vi·ªác s·ª≠ d·ª•ng hi·ªáu qu·∫£ c√°c thi·∫øt b·ªã ƒë·∫ßu v√†o/ƒë·∫ßu ra?",
            "options": [
                "A. V√¨ c·∫ßn duy tr√¨ m·ªôt h√†ng ƒë·ª£i cho m·ªói thi·∫øt b·ªã ƒë·∫ßu v√†o/ƒë·∫ßu ra",
                "B. V√¨ c√°c thi·∫øt b·ªã n√†y c√≥ t·ªëc ƒë·ªô ch·∫≠m h∆°n so v·ªõi CPU v√† b·ªô nh·ªõ",
                "C. N√≥ c√≥ th·ªÉ s·ª≠ d·ª•ng FIFO cho m·ªôt thi·∫øt b·ªã",
                "D. Tr√¨nh qu·∫£n l√Ω c≈©ng c·∫ßn bi·∫øt khi n√†o m·ªôt thi·∫øt b·ªã ƒë√£ ph·ª•c v·ª• xong m·ªôt ti·∫øn tr√¨nh"
            ],
            "answer": "B. V√¨ c√°c thi·∫øt b·ªã n√†y c√≥ t·ªëc ƒë·ªô ch·∫≠m h∆°n so v·ªõi CPU v√† b·ªô nh·ªõ",
            "explanation": "V·∫•n ƒë·ªÅ c∆° b·∫£n trong qu·∫£n l√Ω I/O l√† s·ª± ch√™nh l·ªách t·ªëc ƒë·ªô l·ªõn gi·ªØa CPU v√† c√°c thi·∫øt b·ªã I/O ('n√∫t c·ªï chai I/O'). Vai tr√≤ c·ªßa HƒêH l√† qu·∫£n l√Ω s·ª± kh√°c bi·ªát n√†y b·∫±ng c√°c k·ªπ thu·∫≠t nh∆∞ ƒë·ªám, x·∫øp h√†ng v√† ng·∫Øt ƒë·ªÉ CPU nhanh kh√¥ng ph·∫£i li√™n t·ª•c ch·ªù ƒë·ª£i c√°c thi·∫øt b·ªã ch·∫≠m. **M·∫πo ghi nh·ªõ: HƒêH qu·∫£n l√Ω I/O v√¨ kho·∫£ng c√°ch t·ªëc ƒë·ªô CPU-I/O.**"
        }
    },
    {
        "id": 167,
        "category": "Chapter 5: Operating System (H·ªá ƒëi·ªÅu h√†nh)",
        "en": {
            "question": "An operating system intended for use on microprocessor based systems that support a single user is",
            "options": [
                "A. PC-DOS",
                "B. MS-DOS",
                "C. UNIX",
                "D. CP/M"
            ],
            "answer": "D. CP/M",
            "explanation": "CP/M (Control Program for Microcomputers) was a mass-market operating system created in 1974 for Intel 8080/85-based microcomputers. It was the dominant single-user OS for microprocessors before MS-DOS became popular. **Key takeaway: Early single-user microprocessor OS = CP/M.**"
        },
        "vi": {
            "question": "M·ªôt h·ªá ƒëi·ªÅu h√†nh d√†nh cho c√°c h·ªá th·ªëng d·ª±a tr√™n vi x·ª≠ l√Ω h·ªó tr·ª£ m·ªôt ng∆∞·ªùi d√πng duy nh·∫•t l√†",
            "options": [
                "A. PC-DOS",
                "B. MS-DOS",
                "C. UNIX",
                "D. CP/M"
            ],
            "answer": "D. CP/M",
            "explanation": "CP/M (Control Program for Microcomputers) l√† m·ªôt h·ªá ƒëi·ªÅu h√†nh th·ªã tr∆∞·ªùng ƒë·∫°i ch√∫ng ƒë∆∞·ª£c t·∫°o ra v√†o nƒÉm 1974 cho c√°c m√°y vi t√≠nh d·ª±a tr√™n Intel 8080/85. N√≥ l√† HƒêH ƒë∆°n ng∆∞·ªùi d√πng th·ªëng tr·ªã cho c√°c vi x·ª≠ l√Ω tr∆∞·ªõc khi MS-DOS tr·ªü n√™n ph·ªï bi·∫øn. **M·∫πo ghi nh·ªõ: HƒêH vi x·ª≠ l√Ω ƒë∆°n ng∆∞·ªùi d√πng s∆° khai = CP/M.**"
        }
    },
    {
        "id": 168,
        "category": "Chapter 5: Operating System (H·ªá ƒëi·ªÅu h√†nh)",
        "en": {
            "question": "Which technique is used in multiprogramming that needs to be determined size beforehand by the memory manager and with each program occupying a contiguous space?",
            "options": [
                "A. Partitioning",
                "B. Paging",
                "C. Demand paging",
                "D. Demand segmentation"
            ],
            "answer": "A. Partitioning",
            "explanation": "Fixed partitioning is an early memory management technique where memory is divided into fixed-size partitions beforehand. Each program is loaded into a single, contiguous partition that is large enough to hold it. **Key takeaway: Pre-determined, contiguous space = Partitioning.**"
        },
        "vi": {
            "question": "K·ªπ thu·∫≠t n√†o ƒë∆∞·ª£c s·ª≠ d·ª•ng trong ƒëa ch∆∞∆°ng m√† k√≠ch th∆∞·ªõc c·∫ßn ƒë∆∞·ª£c x√°c ƒë·ªãnh tr∆∞·ªõc b·ªüi tr√¨nh qu·∫£n l√Ω b·ªô nh·ªõ v√† m·ªói ch∆∞∆°ng tr√¨nh chi·∫øm m·ªôt kh√¥ng gian li·ªÅn k·ªÅ?",
            "options": [
                "A. Ph√¢n v√πng",
                "B. Ph√¢n trang",
                "C. Ph√¢n trang theo y√™u c·∫ßu",
                "D. Ph√¢n ƒëo·∫°n theo y√™u c·∫ßu"
            ],
            "answer": "A. Ph√¢n v√πng",
            "explanation": "Ph√¢n v√πng c·ªë ƒë·ªãnh l√† m·ªôt k·ªπ thu·∫≠t qu·∫£n l√Ω b·ªô nh·ªõ s∆° khai trong ƒë√≥ b·ªô nh·ªõ ƒë∆∞·ª£c chia th√†nh c√°c ph√¢n v√πng c√≥ k√≠ch th∆∞·ªõc c·ªë ƒë·ªãnh t·ª´ tr∆∞·ªõc. M·ªói ch∆∞∆°ng tr√¨nh ƒë∆∞·ª£c n·∫°p v√†o m·ªôt ph√¢n v√πng duy nh·∫•t, li·ªÅn k·ªÅ ƒë·ªß l·ªõn ƒë·ªÉ ch·ª©a n√≥. **M·∫πo ghi nh·ªõ: Kh√¥ng gian li·ªÅn k·ªÅ, x√°c ƒë·ªãnh tr∆∞·ªõc = Ph√¢n v√πng.**"
        }
    },
    {
        "id": 169,
        "category": "Chapter 5: Operating System (H·ªá ƒëi·ªÅu h√†nh)",
        "en": {
            "question": "Every process is _______ .",
            "options": [
                "A. Only a job",
                "B. Only a program",
                "C. Only a partition",
                "D. A job and a program"
            ],
            "answer": "D. A job and a program",
            "explanation": "A process is an instance of a program in execution. It originates from a 'job' (the request to run the program) and is fundamentally the 'program' itself, but in an active state. **Key takeaway: Process = A running program originating from a job.**"
        },
        "vi": {
            "question": "M·ªói ti·∫øn tr√¨nh l√† _______ .",
            "options": [
                "A. Ch·ªâ l√† m·ªôt c√¥ng vi·ªác",
                "B. Ch·ªâ l√† m·ªôt ch∆∞∆°ng tr√¨nh",
                "C. Ch·ªâ l√† m·ªôt ph√¢n v√πng",
                "D. M·ªôt c√¥ng vi·ªác v√† m·ªôt ch∆∞∆°ng tr√¨nh"
            ],
            "answer": "D. M·ªôt c√¥ng vi·ªác v√† m·ªôt ch∆∞∆°ng tr√¨nh",
            "explanation": "M·ªôt ti·∫øn tr√¨nh l√† m·ªôt th·ª±c th·ªÉ c·ªßa m·ªôt ch∆∞∆°ng tr√¨nh ƒëang ƒë∆∞·ª£c th·ª±c thi. N√≥ b·∫Øt ngu·ªìn t·ª´ m·ªôt 'c√¥ng vi·ªác' (y√™u c·∫ßu ch·∫°y ch∆∞∆°ng tr√¨nh) v√† v·ªÅ c∆° b·∫£n l√† ch√≠nh 'ch∆∞∆°ng tr√¨nh' ƒë√≥, nh∆∞ng ·ªü tr·∫°ng th√°i ho·∫°t ƒë·ªông. **M·∫πo ghi nh·ªõ: Ti·∫øn tr√¨nh = M·ªôt ch∆∞∆°ng tr√¨nh ƒëang ch·∫°y b·∫Øt ngu·ªìn t·ª´ m·ªôt c√¥ng vi·ªác.**"
        }
    },
    {
        "id": 170,
        "category": "Chapter 5: Operating System (H·ªá ƒëi·ªÅu h√†nh)",
        "en": {
            "question": "The device manager will be tracking every device constantly to ensure that the device is _______.",
            "options": [
                "A. Ready",
                "B. Finished",
                "C. Functioning properly",
                "D. Running"
            ],
            "answer": "C. Functioning properly",
            "explanation": "The device manager's role is to manage the state of all I/O devices. This includes knowing their status (ready, busy), handling errors, and ensuring they are functioning correctly overall. **Key takeaway: Device manager ensures devices function properly.**"
        },
        "vi": {
            "question": "Tr√¨nh qu·∫£n l√Ω thi·∫øt b·ªã s·∫Ω theo d√µi m·ªçi thi·∫øt b·ªã li√™n t·ª•c ƒë·ªÉ ƒë·∫£m b·∫£o r·∫±ng thi·∫øt b·ªã ƒëang _______.",
            "options": [
                "A. S·∫µn s√†ng",
                "B. Ho√†n th√†nh",
                "C. Ho·∫°t ƒë·ªông b√¨nh th∆∞·ªùng",
                "D. ƒêang ch·∫°y"
            ],
            "answer": "C. Ho·∫°t ƒë·ªông b√¨nh th∆∞·ªùng",
            "explanation": "Vai tr√≤ c·ªßa tr√¨nh qu·∫£n l√Ω thi·∫øt b·ªã l√† qu·∫£n l√Ω tr·∫°ng th√°i c·ªßa t·∫•t c·∫£ c√°c thi·∫øt b·ªã I/O. ƒêi·ªÅu n√†y bao g·ªìm vi·ªác bi·∫øt tr·∫°ng th√°i c·ªßa ch√∫ng (s·∫µn s√†ng, b·∫≠n), x·ª≠ l√Ω l·ªói v√† ƒë·∫£m b·∫£o ch√∫ng ho·∫°t ƒë·ªông ƒë√∫ng c√°ch n√≥i chung. **M·∫πo ghi nh·ªõ: Tr√¨nh qu·∫£n l√Ω thi·∫øt b·ªã ƒë·∫£m b·∫£o thi·∫øt b·ªã ho·∫°t ƒë·ªông b√¨nh th∆∞·ªùng.**"
        }
    },
    {
        "id": 171,
        "category": "Chapter 5: Operating System (H·ªá ƒëi·ªÅu h√†nh)",
        "en": {
            "question": "Time during which a job is processed by the computer is",
            "options": [
                "A. Delay time",
                "B. Real time",
                "C. Execution time",
                "D. Down time"
            ],
            "answer": "C. Execution time",
            "explanation": "Execution time (or run time) is the duration for which a program is actively using the CPU to perform its computations. **Key takeaway: Time a job is processed = Execution time.**"
        },
        "vi": {
            "question": "Th·ªùi gian m√† m·ªôt c√¥ng vi·ªác ƒë∆∞·ª£c m√°y t√≠nh x·ª≠ l√Ω l√†",
            "options": [
                "A. Th·ªùi gian tr·ªÖ",
                "B. Th·ªùi gian th·ª±c",
                "C. Th·ªùi gian th·ª±c thi",
                "D. Th·ªùi gian ch·∫øt"
            ],
            "answer": "C. Th·ªùi gian th·ª±c thi",
            "explanation": "Th·ªùi gian th·ª±c thi (ho·∫∑c th·ªùi gian ch·∫°y) l√† kho·∫£ng th·ªùi gian m√† m·ªôt ch∆∞∆°ng tr√¨nh ƒëang t√≠ch c·ª±c s·ª≠ d·ª•ng CPU ƒë·ªÉ th·ª±c hi·ªán c√°c t√≠nh to√°n c·ªßa n√≥. **M·∫πo ghi nh·ªõ: Th·ªùi gian x·ª≠ l√Ω c√¥ng vi·ªác = Th·ªùi gian th·ª±c thi.**"
        }
    },
    {
        "id": 172,
        "category": "Chapter 5: Operating System (H·ªá ƒëi·ªÅu h√†nh)",
        "en": {
            "question": "An operating system supervises the activity of each component in a computer system.",
            "options": [
                "A. An operating system",
                "B. Hardware",
                "C. A queue",
                "D. An application program"
            ],
            "answer": "A. An operating system",
            "explanation": "This is the core definition of an operating system. It acts as the manager or supervisor of all hardware and software resources. The question itself is the answer. **Key takeaway: Supervisor of computer system = Operating System.**"
        },
        "vi": {
            "question": "M·ªôt h·ªá ƒëi·ªÅu h√†nh gi√°m s√°t ho·∫°t ƒë·ªông c·ªßa t·ª´ng th√†nh ph·∫ßn trong m·ªôt h·ªá th·ªëng m√°y t√≠nh.",
            "options": [
                "A. M·ªôt h·ªá ƒëi·ªÅu h√†nh",
                "B. Ph·∫ßn c·ª©ng",
                "C. M·ªôt h√†ng ƒë·ª£i",
                "D. M·ªôt ch∆∞∆°ng tr√¨nh ·ª©ng d·ª•ng"
            ],
            "answer": "A. M·ªôt h·ªá ƒëi·ªÅu h√†nh",
            "explanation": "ƒê√¢y l√† ƒë·ªãnh nghƒ©a c·ªët l√µi c·ªßa m·ªôt h·ªá ƒëi·ªÅu h√†nh. N√≥ ho·∫°t ƒë·ªông nh∆∞ m·ªôt ng∆∞·ªùi qu·∫£n l√Ω ho·∫∑c gi√°m s√°t t·∫•t c·∫£ c√°c t√†i nguy√™n ph·∫ßn c·ª©ng v√† ph·∫ßn m·ªÅm. C√¢u h·ªèi t·ª± n√≥ ƒë√£ l√† c√¢u tr·∫£ l·ªùi. **M·∫πo ghi nh·ªõ: Gi√°m s√°t h·ªá th·ªëng m√°y t√≠nh = H·ªá ƒëi·ªÅu h√†nh.**"
        }
    },
    {
        "id": 173,
        "category": "Chapter 5: Operating System (H·ªá ƒëi·ªÅu h√†nh)",
        "en": {
            "question": "The major design goals of an operating system: (Choose 4 answers)",
            "options": [
                "A. Efficient use of hardware and easy use of resources",
                "B. Control subsystems and manage memory",
                "C. Access I/O device and CPU",
                "D. Provide UI",
                "E. Operation on data",
                "F. Text editor"
            ],
            "answer": "[ \"A. Efficient use of hardware and easy use of resources\", \"B. Control subsystems and manage memory\", \"C. Access I/O device and CPU\", \"D. Provide UI\" ]",
            "explanation": "An OS's goals are to: A) be efficient and convenient, B) manage core components like memory, C) provide controlled access to hardware like I/O and CPU, and D) provide a user interface (UI). E and F are tasks of application programs, not the OS itself. **Key takeaway: OS goals = Efficiency, Convenience, Resource Management, UI.**"
        },
        "vi": {
            "question": "C√°c m·ª•c ti√™u thi·∫øt k·∫ø ch√≠nh c·ªßa m·ªôt h·ªá ƒëi·ªÅu h√†nh: (Ch·ªçn 4 c√¢u tr·∫£ l·ªùi)",
            "options": [
                "A. S·ª≠ d·ª•ng hi·ªáu qu·∫£ ph·∫ßn c·ª©ng v√† d·ªÖ d√†ng s·ª≠ d·ª•ng t√†i nguy√™n",
                "B. Ki·ªÉm so√°t c√°c h·ªá th·ªëng con v√† qu·∫£n l√Ω b·ªô nh·ªõ",
                "C. Truy c·∫≠p thi·∫øt b·ªã I/O v√† CPU",
                "D. Cung c·∫•p giao di·ªán ng∆∞·ªùi d√πng (UI)",
                "E. Thao t√°c tr√™n d·ªØ li·ªáu",
                "F. Tr√¨nh so·∫°n th·∫£o vƒÉn b·∫£n"
            ],
            "answer": "[ \"A. S·ª≠ d·ª•ng hi·ªáu qu·∫£ ph·∫ßn c·ª©ng v√† d·ªÖ d√†ng s·ª≠ d·ª•ng t√†i nguy√™n\", \"B. Ki·ªÉm so√°t c√°c h·ªá th·ªëng con v√† qu·∫£n l√Ω b·ªô nh·ªõ\", \"C. Truy c·∫≠p thi·∫øt b·ªã I/O v√† CPU\", \"D. Cung c·∫•p giao di·ªán ng∆∞·ªùi d√πng (UI)\" ]",
            "explanation": "M·ª•c ti√™u c·ªßa HƒêH l√†: A) hi·ªáu qu·∫£ v√† ti·ªán l·ª£i, B) qu·∫£n l√Ω c√°c th√†nh ph·∫ßn c·ªët l√µi nh∆∞ b·ªô nh·ªõ, C) cung c·∫•p quy·ªÅn truy c·∫≠p c√≥ ki·ªÉm so√°t v√†o ph·∫ßn c·ª©ng nh∆∞ I/O v√† CPU, v√† D) cung c·∫•p giao di·ªán ng∆∞·ªùi d√πng (UI). E v√† F l√† nhi·ªám v·ª• c·ªßa c√°c ch∆∞∆°ng tr√¨nh ·ª©ng d·ª•ng, kh√¥ng ph·∫£i c·ªßa ch√≠nh HƒêH. **M·∫πo ghi nh·ªõ: M·ª•c ti√™u HƒêH = Hi·ªáu qu·∫£, Ti·ªán l·ª£i, Qu·∫£n l√Ω t√†i nguy√™n, UI.**"
        }
    },
    {
        "id": 174,
        "category": "Chapter 5: Operating System (H·ªá ƒëi·ªÅu h√†nh)",
        "en": {
            "question": "What is the process of starting a computer, where a small program in ROM loads the operating system from external storage into RAM, called?",
            "options": [
                "A. Multitasking.",
                "B. Bootstrap Process.",
                "C. Memory Management.",
                "D. Virtualization."
            ],
            "answer": "B. Bootstrap Process.",
            "explanation": "The bootstrap process (or booting) is the sequence of events that occurs when a computer is powered on. It begins with a small bootstrap loader program in ROM (like BIOS/UEFI) which then loads the full operating system. **Key takeaway: Bootstrap = Loading the OS at startup.**"
        },
        "vi": {
            "question": "Qu√° tr√¨nh kh·ªüi ƒë·ªông m√°y t√≠nh, khi m·ªôt ch∆∞∆°ng tr√¨nh nh·ªè trong ROM n·∫°p h·ªá ƒëi·ªÅu h√†nh t·ª´ b·ªô nh·ªõ ngo√†i v√†o RAM, ƒë∆∞·ª£c g·ªçi l√† g√¨?",
            "options": [
                "A. Multitasking (ƒêa nhi·ªám).",
                "B. Bootstrap Process (Qu√° tr√¨nh m·ªìi).",
                "C. Memory Management (Qu·∫£n l√Ω b·ªô nh·ªõ).",
                "D. Virtualization (·∫¢o h√≥a)."
            ],
            "answer": "B. Bootstrap Process (Qu√° tr√¨nh m·ªìi).",
            "explanation": "T√†i li·ªáu (M·ª•c 1.3) m√¥ t·∫£ Bootstrap Process l√† 'a small bootstrap program in ROM' v√† 'Bootstrap loads OS from storage ‚Üí RAM'. **M·∫πo ghi nh·ªõ: Bootstrap = N·∫°p HƒêH khi kh·ªüi ƒë·ªông.**"
        }
    },
    {
        "id": 175,
        "category": "Chapter 5: Operating System (H·ªá ƒëi·ªÅu h√†nh)",
        "en": {
            "question": "Which operating system is designed to perform tasks within extremely strict time limits, often used in industrial control systems or medical devices?",
            "options": [
                "A. Time-Sharing Systems.",
                "B. Distributed Systems.",
                "C. Real-Time Systems (RTOS).",
                "D. Batch Systems."
            ],
            "answer": "C. Real-Time Systems (RTOS).",
            "explanation": "A Real-Time Operating System (RTOS) is designed to serve real-time applications that process data as it comes in, typically without buffer delays. The correctness of the system depends not only on the logical result but also on the time it was delivered. **Key takeaway: RTOS = Real-Time = Strict time constraints.**"
        },
        "vi": {
            "question": "H·ªá ƒëi·ªÅu h√†nh n√†o ƒë∆∞·ª£c thi·∫øt k·∫ø ƒë·ªÉ ph·∫£i th·ª±c hi·ªán c√°c t√°c v·ª• trong m·ªôt gi·ªõi h·∫°n th·ªùi gian c·ª±c k·ª≥ nghi√™m ng·∫∑t, th∆∞·ªùng ƒë∆∞·ª£c s·ª≠ d·ª•ng trong c√°c h·ªá th·ªëng ƒëi·ªÅu khi·ªÉn c√¥ng nghi·ªáp ho·∫∑c thi·∫øt b·ªã y t·∫ø?",
            "options": [
                "A. Time-Sharing Systems (H·ªá th·ªëng chia s·∫ª th·ªùi gian).",
                "B. Distributed Systems (H·ªá th·ªëng ph√¢n t√°n).",
                "C. Real-Time Systems (RTOS) (H·ªá th·ªëng th·ªùi gian th·ª±c).",
                "D. Batch Systems (H·ªá th·ªëng x·ª≠ l√Ω theo l√¥)."
            ],
            "answer": "C. Real-Time Systems (RTOS) (H·ªá th·ªëng th·ªùi gian th·ª±c).",
            "explanation": "T√†i li·ªáu (M·ª•c 2.6) ƒë·ªãnh nghƒ©a RTOS l√† 'Must perform tasks within strict time limits' (Ph·∫£i th·ª±c hi·ªán nhi·ªám v·ª• trong gi·ªõi h·∫°n th·ªùi gian nghi√™m ng·∫∑t). **M·∫πo ghi nh·ªõ: RTOS = Real-Time = R√†ng bu·ªôc th·ªùi gian nghi√™m ng·∫∑t.**"
        }
    },
    {
        "id": 176,
        "category": "Chapter 5: Operating System (H·ªá ƒëi·ªÅu h√†nh)",
        "en": {
            "question": "Which component of the operating system is responsible for managing the creation, scheduling, and termination of processes?",
            "options": [
                "A. Memory Management.",
                "B. Device Management.",
                "C. File Management.",
                "D. Process Management."
            ],
            "answer": "D. Process Management.",
            "explanation": "The process manager is the part of the OS responsible for handling all aspects of a process's lifecycle, including allocating resources, scheduling CPU time, and managing its state (e.g., running, ready, waiting). **Key takeaway: Managing processes = Process Management.**"
        },
        "vi": {
            "question": "Th√†nh ph·∫ßn n√†o c·ªßa h·ªá ƒëi·ªÅu h√†nh ch·ªãu tr√°ch nhi·ªám qu·∫£n l√Ω vi·ªác t·∫°o, l·∫≠p l·ªãch v√† k·∫øt th√∫c c√°c ti·∫øn tr√¨nh (processes)?",
            "options": [
                "A. Memory Management (Qu·∫£n l√Ω b·ªô nh·ªõ).",
                "B. Device Management (Qu·∫£n l√Ω thi·∫øt b·ªã).",
                "C. File Management (Qu·∫£n l√Ω t·ªáp tin).",
                "D. Process Management (Qu·∫£n l√Ω ti·∫øn tr√¨nh)."
            ],
            "answer": "D. Process Management (Qu·∫£n l√Ω ti·∫øn tr√¨nh).",
            "explanation": "T√†i li·ªáu (M·ª•c 3.3) m√¥ t·∫£ Process Management l√† 'OS manages creation, scheduling, and termination of processes'. **M·∫πo ghi nh·ªõ: Qu·∫£n l√Ω process = Process Management.**"
        }
    },
    {
        "id": 177,
        "category": "Chapter 5: Operating System (H·ªá ƒëi·ªÅu h√†nh)",
        "en": {
            "question": "What is the difference between a command-line interface (CLI) and a graphical user interface (GUI)?",
            "options": [
                "A. CLI uses icons and windows, while GUI uses text commands.",
                "B. GUI is more user-friendly but uses more resources than CLI.",
                "C. CLI is only on old operating systems, while GUI is only on new ones.",
                "D. CLI does not allow file management, while GUI does."
            ],
            "answer": "B. GUI is more user-friendly but uses more resources than CLI.",
            "explanation": "A GUI uses visual elements like icons and windows, making it intuitive for most users but requiring more processing power and memory. A CLI is text-based, less intuitive, but is very efficient and powerful for experienced users. **Key takeaway: GUI = Graphical, user-friendly, resource-heavy. CLI = Text, powerful, lightweight.**"
        },
        "vi": {
            "question": "S·ª± kh√°c bi·ªát gi·ªØa giao di·ªán d√≤ng l·ªánh (CLI) v√† giao di·ªán ƒë·ªì h·ªça ng∆∞·ªùi d√πng (GUI) l√† g√¨?",
            "options": [
                "A. CLI s·ª≠ d·ª•ng bi·ªÉu t∆∞·ª£ng v√† c·ª≠a s·ªï, c√≤n GUI d√πng l·ªánh vƒÉn b·∫£n.",
                "B. GUI th√¢n thi·ªán v·ªõi ng∆∞·ªùi d√πng h∆°n nh∆∞ng t·ªën nhi·ªÅu t√†i nguy√™n h∆°n CLI.",
                "C. CLI ch·ªâ c√≥ tr√™n h·ªá ƒëi·ªÅu h√†nh c≈©, c√≤n GUI ch·ªâ c√≥ tr√™n h·ªá ƒëi·ªÅu h√†nh m·ªõi.",
                "D. CLI kh√¥ng cho ph√©p qu·∫£n l√Ω t·ªáp, c√≤n GUI th√¨ c√≥."
            ],
            "answer": "B. GUI th√¢n thi·ªán v·ªõi ng∆∞·ªùi d√πng h∆°n nh∆∞ng t·ªën nhi·ªÅu t√†i nguy√™n h∆°n CLI.",
            "explanation": "T√†i li·ªáu (M·ª•c 3.1) so s√°nh hai lo·∫°i giao di·ªán v√† k·∫øt lu·∫≠n: 'GUI is more user-friendly but uses more resources' (GUI th√¢n thi·ªán h∆°n nh∆∞ng t·ªën t√†i nguy√™n h∆°n). **M·∫πo ghi nh·ªõ: GUI = ƒê·∫πp, d·ªÖ d√πng, t·ªën k√©m. CLI = L·ªánh, kh√≥ d√πng, nh·∫π.**"
        }
    },
    {
        "id": 178,
        "category": "Chapter 5: Operating System (H·ªá ƒëi·ªÅu h√†nh)",
        "en": {
            "question": "In an operating system, what is a program 'in execution' called?",
            "options": [
                "A. A File.",
                "B. A Process.",
                "C. A Job.",
                "D. A Thread."
            ],
            "answer": "B. A Process.",
            "explanation": "A program is a passive set of instructions on disk. A process is the active instance of that program when it is loaded into memory and being executed by the CPU. **Key takeaway: Program + Execution = Process.**"
        },
        "vi": {
            "question": "Trong h·ªá ƒëi·ªÅu h√†nh, m·ªôt ch∆∞∆°ng tr√¨nh khi ƒëang ƒë∆∞·ª£c th·ª±c thi (in execution) ƒë∆∞·ª£c g·ªçi l√† g√¨?",
            "options": [
                "A. A File (M·ªôt t·ªáp tin).",
                "B. A Process (M·ªôt ti·∫øn tr√¨nh).",
                "C. A Job (M·ªôt c√¥ng vi·ªác).",
                "D. A Thread (M·ªôt lu·ªìng)."
            ],
            "answer": "B. A Process (M·ªôt ti·∫øn tr√¨nh).",
            "explanation": "T√†i li·ªáu (M·ª•c 3.3) ƒë·ªãnh nghƒ©a: 'A process = a program in execution' (Ti·∫øn tr√¨nh = ch∆∞∆°ng tr√¨nh ƒëang ch·∫°y). **M·∫πo ghi nh·ªõ: Program + Execution = Process.**"
        }
    },
    {
        "id": 179,
        "category": "Chapter 6: Algorithms (Thu·∫≠t to√°n)",
        "en": {
            "question": "A step-by-step solution to a problem is called _______.",
            "options": [
                "A. hardware",
                "B. an operating system",
                "C. a computer language",
                "D. an algorithm"
            ],
            "answer": "D. an algorithm",
            "explanation": "An algorithm is the fundamental concept of a precise, step-by-step procedure for solving a problem. It's the 'recipe' that a computer follows. **Key takeaway: Algorithm = a recipe for solving a problem.**"
        },
        "vi": {
            "question": "M·ªôt gi·∫£i ph√°p t·ª´ng b∆∞·ªõc cho m·ªôt v·∫•n ƒë·ªÅ ƒë∆∞·ª£c g·ªçi l√† _______.",
            "options": [
                "A. ph·∫ßn c·ª©ng",
                "B. m·ªôt h·ªá ƒëi·ªÅu h√†nh",
                "C. m·ªôt ng√¥n ng·ªØ m√°y t√≠nh",
                "D. m·ªôt thu·∫≠t to√°n"
            ],
            "answer": "D. m·ªôt thu·∫≠t to√°n",
            "explanation": "Thu·∫≠t to√°n l√† kh√°i ni·ªám c∆° b·∫£n v·ªÅ m·ªôt quy tr√¨nh ch√≠nh x√°c, t·ª´ng b∆∞·ªõc ƒë·ªÉ gi·∫£i quy·∫øt m·ªôt v·∫•n ƒë·ªÅ. N√≥ gi·ªëng nh∆∞ 'c√¥ng th·ª©c' m√† m√°y t√≠nh l√†m theo. **M·∫πo ghi nh·ªõ: Thu·∫≠t to√°n = c√¥ng th·ª©c/c√°c b∆∞·ªõc gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ.**"
        }
    },
    {
        "id": 180,
        "category": "Chapter 6: Algorithms (Thu·∫≠t to√°n)",
        "en": {
            "question": "The list of coded instructions is called _______.",
            "options": [
                "A. Computer program",
                "B. Algorithm",
                "C. Flowchart",
                "D. Utility programs"
            ],
            "answer": "A. Computer program",
            "explanation": "An algorithm is the abstract idea or set of steps. A computer program is the concrete implementation of that algorithm, written in a specific coding language for a computer to execute. **Key takeaway: Coded instructions = Program.**"
        },
        "vi": {
            "question": "Danh s√°ch c√°c ch·ªâ th·ªã ƒë√£ ƒë∆∞·ª£c m√£ h√≥a ƒë∆∞·ª£c g·ªçi l√† _______.",
            "options": [
                "A. Ch∆∞∆°ng tr√¨nh m√°y t√≠nh",
                "B. Thu·∫≠t to√°n",
                "C. L∆∞u ƒë·ªì",
                "D. Ch∆∞∆°ng tr√¨nh ti·ªán √≠ch"
            ],
            "answer": "A. Ch∆∞∆°ng tr√¨nh m√°y t√≠nh",
            "explanation": "Thu·∫≠t to√°n l√† √Ω t∆∞·ªüng tr·ª´u t∆∞·ª£ng ho·∫∑c t·∫≠p h·ª£p c√°c b∆∞·ªõc. Ch∆∞∆°ng tr√¨nh m√°y t√≠nh l√† s·ª± hi·ªán th·ª±c h√≥a c·ª• th·ªÉ c·ªßa thu·∫≠t to√°n ƒë√≥, ƒë∆∞·ª£c vi·∫øt b·∫±ng m·ªôt ng√¥n ng·ªØ m√£ h√≥a c·ª• th·ªÉ ƒë·ªÉ m√°y t√≠nh th·ª±c thi. **M·∫πo ghi nh·ªõ: Ch·ªâ th·ªã ƒë√£ m√£ h√≥a = Ch∆∞∆°ng tr√¨nh.**"
        }
    },
    {
        "id": 181,
        "category": "Chapter 6: Algorithms (Thu·∫≠t to√°n)",
        "en": {
            "question": "An ordered set of unambiguous steps that produces a result and terminates in a finite time is a(n) _______.",
            "options": [
                "A. A construct",
                "B. A recursion",
                "C. An iteration",
                "D. An algorithm"
            ],
            "answer": "D. An algorithm",
            "explanation": "This is the formal definition of an algorithm. It must be ordered, unambiguous (clear), effective, and finite (must terminate). **Key takeaway: This is the formal definition of an algorithm.**"
        },
        "vi": {
            "question": "M·ªôt t·∫≠p h·ª£p c√≥ th·ª© t·ª± c√°c b∆∞·ªõc r√µ r√†ng, t·∫°o ra k·∫øt qu·∫£ v√† k·∫øt th√∫c trong m·ªôt th·ªùi gian h·ªØu h·∫°n ƒë∆∞·ª£c g·ªçi l√† _______.",
            "options": [
                "A. M·ªôt c·∫•u tr√∫c",
                "B. M·ªôt ph√©p ƒë·ªá quy",
                "C. M·ªôt v√≤ng l·∫∑p",
                "D. M·ªôt thu·∫≠t to√°n"
            ],
            "answer": "D. M·ªôt thu·∫≠t to√°n",
            "explanation": "ƒê√¢y l√† ƒë·ªãnh nghƒ©a ch√≠nh th·ª©c c·ªßa m·ªôt thu·∫≠t to√°n. N√≥ ph·∫£i c√≥ th·ª© t·ª±, r√µ r√†ng (kh√¥ng m∆° h·ªì), hi·ªáu qu·∫£ v√† h·ªØu h·∫°n (ph·∫£i k·∫øt th√∫c). **M·∫πo ghi nh·ªõ: ƒê√¢y l√† ƒë·ªãnh nghƒ©a ch√≠nh th·ª©c c·ªßa m·ªôt thu·∫≠t to√°n.**"
        }
    },
    {
        "id": 182,
        "category": "Chapter 6: Algorithms (Thu·∫≠t to√°n)",
        "en": {
            "question": "_______ is a basic algorithm in which we want to find the location of a target in a list of items.",
            "options": [
                "A. Sorting",
                "B. Searching",
                "C. Product",
                "D. Summation"
            ],
            "answer": "B. Searching",
            "explanation": "Searching algorithms are a fundamental class of algorithms designed to retrieve an item with specific properties from a collection of items. **Key takeaway: Find an item = Searching.**"
        },
        "vi": {
            "question": "_______ l√† m·ªôt thu·∫≠t to√°n c∆° b·∫£n trong ƒë√≥ ch√∫ng ta mu·ªën t√¨m v·ªã tr√≠ c·ªßa m·ªôt m·ª•c ti√™u trong m·ªôt danh s√°ch c√°c m·ª•c.",
            "options": [
                "A. S·∫Øp x·∫øp",
                "B. T√¨m ki·∫øm",
                "C. T√≠ch",
                "D. T·ªïng"
            ],
            "answer": "B. T√¨m ki·∫øm",
            "explanation": "Thu·∫≠t to√°n t√¨m ki·∫øm l√† m·ªôt l·ªõp thu·∫≠t to√°n c∆° b·∫£n ƒë∆∞·ª£c thi·∫øt k·∫ø ƒë·ªÉ truy xu·∫•t m·ªôt m·ª•c c√≥ c√°c thu·ªôc t√≠nh c·ª• th·ªÉ t·ª´ m·ªôt t·∫≠p h·ª£p c√°c m·ª•c. **M·∫πo ghi nh·ªõ: T√¨m m·ªôt m·ª•c = T√¨m ki·∫øm.**"
        }
    },
    {
        "id": 183,
        "category": "Chapter 6: Algorithms (Thu·∫≠t to√°n)",
        "en": {
            "question": "_______ is a basic algorithm that arranges data according to its value.",
            "options": [
                "A. Inquiry",
                "B. Sorting",
                "C. Searching",
                "D. Recursion"
            ],
            "answer": "B. Sorting",
            "explanation": "Sorting algorithms arrange elements of a list in a certain order (e.g., numerical or lexicographical). **Key takeaway: Arrange data = Sorting.**"
        },
        "vi": {
            "question": "_______ l√† m·ªôt thu·∫≠t to√°n c∆° b·∫£n s·∫Øp x·∫øp d·ªØ li·ªáu theo gi√° tr·ªã c·ªßa n√≥.",
            "options": [
                "A. Truy v·∫•n",
                "B. S·∫Øp x·∫øp",
                "C. T√¨m ki·∫øm",
                "D. ƒê·ªá quy"
            ],
            "answer": "B. S·∫Øp x·∫øp",
            "explanation": "Thu·∫≠t to√°n s·∫Øp x·∫øp s·∫Øp x·∫øp c√°c ph·∫ßn t·ª≠ c·ªßa m·ªôt danh s√°ch theo m·ªôt th·ª© t·ª± nh·∫•t ƒë·ªãnh (v√≠ d·ª•: s·ªë h·ªçc ho·∫∑c t·ª´ ƒëi·ªÉn). **M·∫πo ghi nh·ªõ: S·∫Øp x·∫øp d·ªØ li·ªáu = S·∫Øp x·∫øp.**"
        }
    },
    {
        "id": 184,
        "category": "Chapter 6: Algorithms (Thu·∫≠t to√°n)",
        "en": {
            "question": "In _______ sort, the smallest item moves to the beginning of the unsorted list. There is no one-to-one swapping.",
            "options": [
                "A. Selection",
                "B. Bubble",
                "C. Insertion",
                "D. Every"
            ],
            "answer": "A. Selection",
            "explanation": "Selection sort works by repeatedly finding the minimum element from the unsorted part of the list and putting it at the beginning. It involves one swap per pass. **Key takeaway: Find smallest, move to front = Selection Sort.**"
        },
        "vi": {
            "question": "Trong s·∫Øp x·∫øp _______, m·ª•c nh·ªè nh·∫•t di chuy·ªÉn ƒë·∫øn ƒë·∫ßu danh s√°ch ch∆∞a ƒë∆∞·ª£c s·∫Øp x·∫øp. Kh√¥ng c√≥ vi·ªác ho√°n ƒë·ªïi m·ªôt-m·ªôt.",
            "options": [
                "A. Ch·ªçn",
                "B. N·ªïi b·ªçt",
                "C. Ch√®n",
                "D. M·ªçi lo·∫°i"
            ],
            "answer": "A. Ch·ªçn",
            "explanation": "S·∫Øp x·∫øp ch·ªçn ho·∫°t ƒë·ªông b·∫±ng c√°ch l·∫∑p ƒëi l·∫∑p l·∫°i vi·ªác t√¨m ph·∫ßn t·ª≠ nh·ªè nh·∫•t t·ª´ ph·∫ßn ch∆∞a ƒë∆∞·ª£c s·∫Øp x·∫øp c·ªßa danh s√°ch v√† ƒë·∫∑t n√≥ ·ªü ƒë·∫ßu. N√≥ bao g·ªìm m·ªôt l·∫ßn ho√°n ƒë·ªïi cho m·ªói l∆∞·ª£t. **M·∫πo ghi nh·ªõ: T√¨m nh·ªè nh·∫•t, chuy·ªÉn l√™n ƒë·∫ßu = S·∫Øp x·∫øp ch·ªçn.**"
        }
    },
    {
        "id": 185,
        "category": "Chapter 6: Algorithms (Thu·∫≠t to√°n)",
        "en": {
            "question": "In _______ sort, the item that goes into the sorted list is always the first item in the unsorted list.",
            "options": [
                "A. Selection",
                "B. Bubble",
                "C. Insertion",
                "D. Every"
            ],
            "answer": "C. Insertion",
            "explanation": "Insertion sort builds the final sorted array one item at a time. It iterates through the input elements and inserts each element into its correct position in the sorted part of the array. **Key takeaway: Take first unsorted, insert into sorted part = Insertion Sort.**"
        },
        "vi": {
            "question": "Trong s·∫Øp x·∫øp _______, m·ª•c ƒëi v√†o danh s√°ch ƒë√£ s·∫Øp x·∫øp lu√¥n l√† m·ª•c ƒë·∫ßu ti√™n trong danh s√°ch ch∆∞a ƒë∆∞·ª£c s·∫Øp x·∫øp.",
            "options": [
                "A. Ch·ªçn",
                "B. N·ªïi b·ªçt",
                "C. Ch√®n",
                "D. M·ªçi lo·∫°i"
            ],
            "answer": "C. Ch√®n",
            "explanation": "S·∫Øp x·∫øp ch√®n x√¢y d·ª±ng m·∫£ng ƒë√£ s·∫Øp x·∫øp cu·ªëi c√πng m·ªói l·∫ßn m·ªôt m·ª•c. N√≥ l·∫∑p qua c√°c ph·∫ßn t·ª≠ ƒë·∫ßu v√†o v√† ch√®n m·ªói ph·∫ßn t·ª≠ v√†o v·ªã tr√≠ ƒë√∫ng c·ªßa n√≥ trong ph·∫ßn ƒë√£ s·∫Øp x·∫øp c·ªßa m·∫£ng. **M·∫πo ghi nh·ªõ: L·∫•y ph·∫ßn t·ª≠ ch∆∞a s·∫Øp x·∫øp ƒë·∫ßu ti√™n, ch√®n v√†o ph·∫ßn ƒë√£ s·∫Øp x·∫øp = S·∫Øp x·∫øp ch√®n.**"
        }
    },
    {
        "id": 186,
        "category": "Chapter 6: Algorithms (Thu·∫≠t to√°n)",
        "en": {
            "question": "To search for elements, we can use _______ on sorted arrays that can help to decrease time complexity",
            "options": [
                "A. Sequential search",
                "B. Insertion sort",
                "C. Selection sort",
                "D. Binary search"
            ],
            "answer": "D. Binary search",
            "explanation": "Binary search is a highly efficient search algorithm that works only on sorted arrays. It has a time complexity of O(log n), which is much faster than the O(n) of a sequential search. **Key takeaway: Search on sorted array = Binary Search.**"
        },
        "vi": {
            "question": "ƒê·ªÉ t√¨m ki·∫øm c√°c ph·∫ßn t·ª≠, ch√∫ng ta c√≥ th·ªÉ s·ª≠ d·ª•ng _______ tr√™n c√°c m·∫£ng ƒë√£ ƒë∆∞·ª£c s·∫Øp x·∫øp ƒë·ªÉ gi√∫p gi·∫£m ƒë·ªô ph·ª©c t·∫°p th·ªùi gian",
            "options": [
                "A. T√¨m ki·∫øm tu·∫ßn t·ª±",
                "B. S·∫Øp x·∫øp ch√®n",
                "C. S·∫Øp x·∫øp ch·ªçn",
                "D. T√¨m ki·∫øm nh·ªã ph√¢n"
            ],
            "answer": "D. T√¨m ki·∫øm nh·ªã ph√¢n",
            "explanation": "T√¨m ki·∫øm nh·ªã ph√¢n l√† m·ªôt thu·∫≠t to√°n t√¨m ki·∫øm hi·ªáu qu·∫£ cao ch·ªâ ho·∫°t ƒë·ªông tr√™n c√°c m·∫£ng ƒë√£ ƒë∆∞·ª£c s·∫Øp x·∫øp. N√≥ c√≥ ƒë·ªô ph·ª©c t·∫°p th·ªùi gian l√† O(log n), nhanh h∆°n nhi·ªÅu so v·ªõi O(n) c·ªßa t√¨m ki·∫øm tu·∫ßn t·ª±. **M·∫πo ghi nh·ªõ: T√¨m ki·∫øm tr√™n m·∫£ng ƒë√£ s·∫Øp x·∫øp = T√¨m ki·∫øm nh·ªã ph√¢n.**"
        }
    },
    {
        "id": 187,
        "category": "Chapter 6: Algorithms (Thu·∫≠t to√°n)",
        "en": {
            "question": "The items are divided into two lists (sorted and unsorted) ______ sort.",
            "options": [
                "A. Only in a selection",
                "B. Only in a bubble",
                "C. Only in an insertion",
                "D. In selection, bubble, or insertion"
            ],
            "answer": "D. In selection, bubble, or insertion",
            "explanation": "All three of these simple sorting algorithms work by maintaining a sorted portion and an unsorted portion of the list, gradually growing the sorted part until the entire list is sorted. **Key takeaway: Selection, Bubble, and Insertion sorts all use a sorted/unsorted partition.**"
        },
        "vi": {
            "question": "C√°c m·ª•c ƒë∆∞·ª£c chia th√†nh hai danh s√°ch (ƒë√£ s·∫Øp x·∫øp v√† ch∆∞a s·∫Øp x·∫øp) trong s·∫Øp x·∫øp ______.",
            "options": [
                "A. Ch·ªâ trong s·∫Øp x·∫øp ch·ªçn",
                "B. Ch·ªâ trong s·∫Øp x·∫øp n·ªïi b·ªçt",
                "C. Ch·ªâ trong s·∫Øp x·∫øp ch√®n",
                "D. Trong s·∫Øp x·∫øp ch·ªçn, n·ªïi b·ªçt, ho·∫∑c ch√®n"
            ],
            "answer": "D. Trong s·∫Øp x·∫øp ch·ªçn, n·ªïi b·ªçt, ho·∫∑c ch√®n",
            "explanation": "C·∫£ ba thu·∫≠t to√°n s·∫Øp x·∫øp ƒë∆°n gi·∫£n n√†y ƒë·ªÅu ho·∫°t ƒë·ªông b·∫±ng c√°ch duy tr√¨ m·ªôt ph·∫ßn ƒë√£ s·∫Øp x·∫øp v√† m·ªôt ph·∫ßn ch∆∞a s·∫Øp x·∫øp c·ªßa danh s√°ch, d·∫ßn d·∫ßn m·ªü r·ªông ph·∫ßn ƒë√£ s·∫Øp x·∫øp cho ƒë·∫øn khi to√†n b·ªô danh s√°ch ƒë∆∞·ª£c s·∫Øp x·∫øp. **M·∫πo ghi nh·ªõ: S·∫Øp x·∫øp ch·ªçn, n·ªïi b·ªçt v√† ch√®n ƒë·ªÅu s·ª≠ d·ª•ng ph√¢n v√πng ƒë√£ s·∫Øp x·∫øp/ch∆∞a s·∫Øp x·∫øp.**"
        }
    },
    {
        "id": 188,
        "category": "Chapter 6: Algorithms (Thu·∫≠t to√°n)",
        "en": {
            "question": "A _______ is a pictorial representation of an algorithm.",
            "options": [
                "A. A UML diagram",
                "B. A program",
                "C. Pseudocode",
                "D. A flowchart"
            ],
            "answer": "D. A flowchart",
            "explanation": "A flowchart uses standard graphical symbols to represent the sequence of operations, decisions, and flow of control in an algorithm. UML can also be pictorial, but 'flowchart' is the more classic and direct answer. **Key takeaway: Pictorial/Graphical representation = Flowchart.**"
        },
        "vi": {
            "question": "_______ l√† m·ªôt bi·ªÉu di·ªÖn b·∫±ng h√¨nh ·∫£nh c·ªßa m·ªôt thu·∫≠t to√°n.",
            "options": [
                "A. M·ªôt s∆° ƒë·ªì UML",
                "B. M·ªôt ch∆∞∆°ng tr√¨nh",
                "C. M√£ gi·∫£",
                "D. M·ªôt l∆∞u ƒë·ªì"
            ],
            "answer": "D. M·ªôt l∆∞u ƒë·ªì",
            "explanation": "M·ªôt l∆∞u ƒë·ªì s·ª≠ d·ª•ng c√°c k√Ω hi·ªáu ƒë·ªì h·ªça ti√™u chu·∫©n ƒë·ªÉ bi·ªÉu di·ªÖn chu·ªói c√°c ho·∫°t ƒë·ªông, quy·∫øt ƒë·ªãnh v√† lu·ªìng ƒëi·ªÅu khi·ªÉn trong m·ªôt thu·∫≠t to√°n. UML c≈©ng c√≥ th·ªÉ l√† h√¨nh ·∫£nh, nh∆∞ng 'l∆∞u ƒë·ªì' l√† c√¢u tr·∫£ l·ªùi kinh ƒëi·ªÉn v√† tr·ª±c ti·∫øp h∆°n. **M·∫πo ghi nh·ªõ: Bi·ªÉu di·ªÖn h√¨nh ·∫£nh/ƒë·ªì h·ªça = L∆∞u ƒë·ªì.**"
        }
    },
    {
        "id": 189,
        "category": "Chapter 6: Algorithms (Thu·∫≠t to√°n)",
        "en": {
            "question": "A _______ is an English-language-like representation of an algorithm.",
            "options": [
                "A. Pseudocode",
                "B. Unified Modeling Language (UML)",
                "C. Flowchart",
                "D. State diagram"
            ],
            "answer": "A. Pseudocode",
            "explanation": "Pseudocode is an informal, high-level description of an algorithm that uses the structural conventions of a programming language, but is intended for human reading. **Key takeaway: English-like representation = Pseudocode.**"
        },
        "vi": {
            "question": "_______ l√† m·ªôt bi·ªÉu di·ªÖn gi·ªëng ng√¥n ng·ªØ ti·∫øng Anh c·ªßa m·ªôt thu·∫≠t to√°n.",
            "options": [
                "A. M√£ gi·∫£",
                "B. Ng√¥n ng·ªØ m√¥ h√¨nh h√≥a th·ªëng nh·∫•t (UML)",
                "C. L∆∞u ƒë·ªì",
                "D. S∆° ƒë·ªì tr·∫°ng th√°i"
            ],
            "answer": "A. M√£ gi·∫£",
            "explanation": "M√£ gi·∫£ l√† m·ªôt m√¥ t·∫£ kh√¥ng ch√≠nh th·ª©c, c·∫•p cao c·ªßa m·ªôt thu·∫≠t to√°n s·ª≠ d·ª•ng c√°c quy ∆∞·ªõc c·∫•u tr√∫c c·ªßa m·ªôt ng√¥n ng·ªØ l·∫≠p tr√¨nh, nh∆∞ng d√†nh cho con ng∆∞·ªùi ƒë·ªçc. **M·∫πo ghi nh·ªõ: Bi·ªÉu di·ªÖn gi·ªëng ti·∫øng Anh = M√£ gi·∫£.**"
        }
    },
    {
        "id": 190,
        "category": "Chapter 6: Algorithms (Thu·∫≠t to√°n)",
        "en": {
            "question": "What is statement that stores the value in the variable, which has already been created in the declaration section. We use the symbol --- in our algorithm to define it?",
            "options": [
                "A. Compound statement",
                "B. Assignment statement",
                "C. Control statement",
                "D. None of above"
            ],
            "answer": "B. Assignment statement",
            "explanation": "An assignment statement gives a value to a variable. In many pseudocode conventions, an arrow (`‚Üê`) or similar symbol is used to denote assignment (e.g., `x ‚Üê 5`). **Key takeaway: Storing a value in a variable = Assignment.**"
        },
        "vi": {
            "question": "C√¢u l·ªánh n√†o l∆∞u tr·ªØ gi√° tr·ªã v√†o bi·∫øn ƒë√£ ƒë∆∞·ª£c t·∫°o trong ph·∫ßn khai b√°o. Ch√∫ng ta s·ª≠ d·ª•ng k√Ω hi·ªáu --- trong thu·∫≠t to√°n c·ªßa m√¨nh ƒë·ªÉ ƒë·ªãnh nghƒ©a n√≥?",
            "options": [
                "A. C√¢u l·ªánh ph·ª©c h·ª£p",
                "B. C√¢u l·ªánh g√°n",
                "C. C√¢u l·ªánh ƒëi·ªÅu khi·ªÉn",
                "D. Kh√¥ng c√≥ ph∆∞∆°ng √°n n√†o ·ªü tr√™n"
            ],
            "answer": "B. C√¢u l·ªánh g√°n",
            "explanation": "M·ªôt c√¢u l·ªánh g√°n ƒë∆∞a m·ªôt gi√° tr·ªã cho m·ªôt bi·∫øn. Trong nhi·ªÅu quy ∆∞·ªõc m√£ gi·∫£, m·ªôt m≈©i t√™n (`‚Üê`) ho·∫∑c k√Ω hi·ªáu t∆∞∆°ng t·ª± ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ bi·ªÉu th·ªã ph√©p g√°n (v√≠ d·ª•: `x ‚Üê 5`). **M·∫πo ghi nh·ªõ: L∆∞u gi√° tr·ªã v√†o bi·∫øn = G√°n.**"
        }
    },
    {
        "id": 191,
        "category": "Chapter 6: Algorithms (Thu·∫≠t to√°n)",
        "en": {
            "question": "What are the three basic control structures that form all algorithms?",
            "options": [
                "A. Input, Process, Output.",
                "B. Sequence, Decision, Repetition.",
                "C. Variables, Constants, Literals.",
                "D. Summation, Sorting, Searching."
            ],
            "answer": "B. Sequence, Decision, Repetition.",
            "explanation": "According to the structured program theorem, any algorithm can be constructed from just three basic structures: Sequence (executing steps one after another), Decision (or selection, like if-else), and Repetition (or iteration, like while/for loops). **Key takeaway: 3 basic constructs = Sequence, Decision, Repetition.**"
        },
        "vi": {
            "question": "Ba c·∫•u tr√∫c ƒëi·ªÅu khi·ªÉn c∆° b·∫£n (Three Basic Constructs) h√¨nh th√†nh n√™n m·ªçi thu·∫≠t to√°n l√† g√¨?",
            "options": [
                "A. Input, Process, Output.",
                "B. Sequence, Decision, Repetition.",
                "C. Variables, Constants, Literals.",
                "D. Summation, Sorting, Searching."
            ],
            "answer": "B. Sequence, Decision, Repetition.",
            "explanation": "T√†i li·ªáu (M·ª•c 2) gi·ªõi thi·ªáu r√µ ba c·∫•u tr√∫c c∆° b·∫£n l√† Sequence (Tu·∫ßn t·ª±), Decision (R·∫Ω nh√°nh), v√† Repetition (L·∫∑p). **M·∫πo ghi nh·ªõ: 3 c·∫•u tr√∫c c∆° b·∫£n = Tu·∫ßn t·ª±, R·∫Ω nh√°nh, L·∫∑p.**"
        }
    },
    {
        "id": 192,
        "category": "Chapter 6: Algorithms (Thu·∫≠t to√°n)",
        "en": {
            "question": "Which sorting algorithm works by repeatedly comparing two adjacent elements and swapping them if they are in the wrong order?",
            "options": [
                "A. Selection Sort.",
                "B. Insertion Sort.",
                "C. Quick Sort.",
                "D. Bubble Sort."
            ],
            "answer": "D. Bubble Sort.",
            "explanation": "Bubble sort repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted. The largest elements 'bubble' to the top. **Key takeaway: Bubble = compare neighbors, swap.**"
        },
        "vi": {
            "question": "Thu·∫≠t to√°n s·∫Øp x·∫øp n√†o ho·∫°t ƒë·ªông b·∫±ng c√°ch li√™n t·ª•c so s√°nh hai ph·∫ßn t·ª≠ li·ªÅn k·ªÅ v√† ƒë·ªïi ch·ªó ch√∫ng n·∫øu ch√∫ng kh√¥ng ƒë√∫ng th·ª© t·ª±?",
            "options": [
                "A. Selection Sort (S·∫Øp x·∫øp ch·ªçn).",
                "B. Insertion Sort (S·∫Øp x·∫øp ch√®n).",
                "C. Quick Sort (S·∫Øp x·∫øp nhanh).",
                "D. Bubble Sort (S·∫Øp x·∫øp n·ªïi b·ªçt)."
            ],
            "answer": "D. Bubble Sort (S·∫Øp x·∫øp n·ªïi b·ªçt).",
            "explanation": "T√†i li·ªáu (M·ª•c 4.3) m√¥ t·∫£ Bubble Sort l√† 'Repeatedly compare adjacent elements and swap if out of order' (Li√™n t·ª•c so s√°nh hai ph·∫ßn t·ª≠ k·ªÅ nhau v√† ƒë·ªïi ch·ªó n·∫øu sai th·ª© t·ª±). **M·∫πo ghi nh·ªõ: Bubble = so s√°nh h√†ng x√≥m, ƒë·ªïi ch·ªó.**"
        }
    },
    {
        "id": 193,
        "category": "Chapter 6: Algorithms (Thu·∫≠t to√°n)",
        "en": {
            "question": "What is the key characteristic of the Binary Search algorithm?",
            "options": [
                "A. It works on any type of list, whether sorted or not.",
                "B. It repeatedly divides the list in half to find the target and only works on sorted lists.",
                "C. It checks each element one by one from beginning to end.",
                "D. It has a time complexity of O(n)."
            ],
            "answer": "B. It repeatedly divides the list in half to find the target and only works on sorted lists.",
            "explanation": "Binary search is a highly efficient algorithm that requires the list to be sorted. It works by comparing the target value to the middle element; if they are not equal, the half in which the target cannot lie is eliminated, and the search continues on the remaining half. **Key takeaway: Binary Search = divide in half, requires sorted list.**"
        },
        "vi": {
            "question": "ƒê·∫∑c ƒëi·ªÉm ch√≠nh c·ªßa thu·∫≠t to√°n t√¨m ki·∫øm nh·ªã ph√¢n (Binary Search) l√† g√¨?",
            "options": [
                "A. Ho·∫°t ƒë·ªông tr√™n m·ªçi lo·∫°i danh s√°ch, d√π ƒë√£ s·∫Øp x·∫øp hay ch∆∞a.",
                "B. Chia ƒë√¥i danh s√°ch m·ªôt c√°ch l·∫∑p ƒëi l·∫∑p l·∫°i ƒë·ªÉ t√¨m m·ª•c ti√™u v√† ch·ªâ ho·∫°t ƒë·ªông tr√™n danh s√°ch ƒë√£ s·∫Øp x·∫øp.",
                "C. Ki·ªÉm tra t·ª´ng ph·∫ßn t·ª≠ m·ªôt t·ª´ ƒë·∫ßu ƒë·∫øn cu·ªëi.",
                "D. C√≥ ƒë·ªô ph·ª©c t·∫°p th·ªùi gian l√† O(n)."
            ],
            "answer": "B. Chia ƒë√¥i danh s√°ch m·ªôt c√°ch l·∫∑p ƒëi l·∫∑p l·∫°i ƒë·ªÉ t√¨m m·ª•c ti√™u v√† ch·ªâ ho·∫°t ƒë·ªông tr√™n danh s√°ch ƒë√£ s·∫Øp x·∫øp.",
            "explanation": "T√†i li·ªáu (M·ª•c 5.2) n√™u r√µ Binary Search 'Works only on sorted lists' v√† 'Repeatedly divide the list in half to locate the target'. **M·∫πo ghi nh·ªõ: Binary Search = chia ƒë√¥i, y√™u c·∫ßu ƒë√£ s·∫Øp x·∫øp.**"
        }
    },
    {
        "id": 194,
        "category": "Chapter 6: Algorithms (Thu·∫≠t to√°n)",
        "en": {
            "question": "The 'divide-and-conquer' strategy is used in which of the following sorting algorithms?",
            "options": [
                "A. Bubble Sort and Selection Sort.",
                "B. Quick Sort and Merge Sort.",
                "C. Insertion Sort and Bubble Sort.",
                "D. Only Quick Sort."
            ],
            "answer": "B. Quick Sort and Merge Sort.",
            "explanation": "Both Quick Sort and Merge Sort are classic examples of the divide-and-conquer paradigm. They work by recursively breaking down a problem into smaller subproblems until they become simple enough to be solved directly, and then combining the results. **Key takeaway: Divide-and-conquer = Quick Sort & Merge Sort.**"
        },
        "vi": {
            "question": "Chi·∫øn l∆∞·ª£c 'chia ƒë·ªÉ tr·ªã' (divide-and-conquer) ƒë∆∞·ª£c s·ª≠ d·ª•ng trong c√°c thu·∫≠t to√°n s·∫Øp x·∫øp n√†o sau ƒë√¢y?",
            "options": [
                "A. Bubble Sort v√† Selection Sort.",
                "B. Quick Sort v√† Merge Sort.",
                "C. Insertion Sort v√† Bubble Sort.",
                "D. Ch·ªâ c√≥ Quick Sort."
            ],
            "answer": "B. Quick Sort v√† Merge Sort.",
            "explanation": "T√†i li·ªáu (M·ª•c 4.3) m√¥ t·∫£ c·∫£ Quick Sort v√† Merge Sort ƒë·ªÅu s·ª≠ d·ª•ng ph∆∞∆°ng ph√°p 'divide-and-conquer'. **M·∫πo ghi nh·ªõ: Chia ƒë·ªÉ tr·ªã = Quick Sort & Merge Sort.**"
        }
    },
    {
        "id": 195,
        "category": "Chapter 6: Algorithms (Thu·∫≠t to√°n)",
        "en": {
            "question": "Which of the following is an English-like representation of an algorithm that does not follow a strict syntactical standard?",
            "options": [
                "A. UML (Unified Modeling Language).",
                "B. Pseudocode.",
                "C. Java.",
                "D. Flowchart."
            ],
            "answer": "B. Pseudocode.",
            "explanation": "Pseudocode is an informal way of programming description that does not require any strict programming language syntax. It is used for creating an outline or a rough draft of a program. **Key takeaway: Pseudocode = Fake code, written freely like English.**"
        },
        "vi": {
            "question": "Ng√¥n ng·ªØ n√†o sau ƒë√¢y l√† m·ªôt d·∫°ng bi·ªÉu di·ªÖn thu·∫≠t to√°n gi·ªëng ti·∫øng Anh, kh√¥ng theo m·ªôt ti√™u chu·∫©n c√∫ ph√°p ch·∫∑t ch·∫Ω?",
            "options": [
                "A. UML (Unified Modeling Language).",
                "B. Pseudocode (M√£ gi·∫£).",
                "C. Java.",
                "D. Flowchart (L∆∞u ƒë·ªì)."
            ],
            "answer": "B. Pseudocode (M√£ gi·∫£).",
            "explanation": "T√†i li·ªáu (M·ª•c 3.2) ƒë·ªãnh nghƒ©a Pseudocode l√† 'an English-like description of algorithm steps' v√† 'No strict standard'. **M·∫πo ghi nh·ªõ: Pseudocode = M√£ gi·∫£, vi·∫øt t·ª± do gi·ªëng ti·∫øng Anh.**"
        }
    },
    {
        "id": 196,
        "category": "Chapter 7: Programming (L·∫≠p tr√¨nh)",
        "en": {
            "question": "_______ is a set of instructions in a computer language that tells the computer what to do with data.",
            "options": [
                "A. An operating system",
                "B. An algorithm",
                "C. A data processor",
                "D. A program"
            ],
            "answer": "D. A program",
            "explanation": "A program (or computer program) is the concrete implementation of an algorithm, written in a specific language, that a computer can execute. **Key takeaway: Set of instructions = Program.**"
        },
        "vi": {
            "question": "_______ l√† m·ªôt t·∫≠p h·ª£p c√°c ch·ªâ th·ªã trong m·ªôt ng√¥n ng·ªØ m√°y t√≠nh cho m√°y t√≠nh bi·∫øt ph·∫£i l√†m g√¨ v·ªõi d·ªØ li·ªáu.",
            "options": [
                "A. M·ªôt h·ªá ƒëi·ªÅu h√†nh",
                "B. M·ªôt thu·∫≠t to√°n",
                "C. M·ªôt b·ªô x·ª≠ l√Ω d·ªØ li·ªáu",
                "D. M·ªôt ch∆∞∆°ng tr√¨nh"
            ],
            "answer": "D. M·ªôt ch∆∞∆°ng tr√¨nh",
            "explanation": "M·ªôt ch∆∞∆°ng tr√¨nh (ho·∫∑c ch∆∞∆°ng tr√¨nh m√°y t√≠nh) l√† s·ª± hi·ªán th·ª±c h√≥a c·ª• th·ªÉ c·ªßa m·ªôt thu·∫≠t to√°n, ƒë∆∞·ª£c vi·∫øt b·∫±ng m·ªôt ng√¥n ng·ªØ c·ª• th·ªÉ, m√† m√°y t√≠nh c√≥ th·ªÉ th·ª±c thi. **M·∫πo ghi nh·ªõ: T·∫≠p h·ª£p c√°c ch·ªâ th·ªã = Ch∆∞∆°ng tr√¨nh.**"
        }
    },
    {
        "id": 197,
        "category": "Chapter 7: Programming (L·∫≠p tr√¨nh)",
        "en": {
            "question": "FORTRAN and COBOL are examples of _______.",
            "options": [
                "A. hardware",
                "B. operating systems",
                "C. computer languages",
                "D. algorithms"
            ],
            "answer": "C. computer languages",
            "explanation": "FORTRAN (Formula Translation) and COBOL (Common Business-Oriented Language) are two of the earliest high-level programming languages. **Key takeaway: FORTRAN/COBOL = Early high-level languages.**"
        },
        "vi": {
            "question": "FORTRAN v√† COBOL l√† c√°c v√≠ d·ª• v·ªÅ _______.",
            "options": [
                "A. ph·∫ßn c·ª©ng",
                "B. h·ªá ƒëi·ªÅu h√†nh",
                "C. ng√¥n ng·ªØ m√°y t√≠nh",
                "D. thu·∫≠t to√°n"
            ],
            "answer": "C. ng√¥n ng·ªØ m√°y t√≠nh",
            "explanation": "FORTRAN (Formula Translation) v√† COBOL (Common Business-Oriented Language) l√† hai trong s·ªë c√°c ng√¥n ng·ªØ l·∫≠p tr√¨nh b·∫≠c cao s·ªõm nh·∫•t. **M·∫πo ghi nh·ªõ: FORTRAN/COBOL = Ng√¥n ng·ªØ b·∫≠c cao ƒë·ªùi ƒë·∫ßu.**"
        }
    },
    {
        "id": 198,
        "category": "Chapter 7: Programming (L·∫≠p tr√¨nh)",
        "en": {
            "question": "Which is another name for functional language?",
            "options": [
                "A. Machine language",
                "B. Application language",
                "C. Low-level language",
                "D. High-level language"
            ],
            "answer": "D. High-level language",
            "explanation": "Functional languages (like LISP, Haskell) are a type of high-level programming paradigm. They are distinct from low-level languages like machine or assembly language. **Key takeaway: Functional language is a type of high-level language.**"
        },
        "vi": {
            "question": "T√™n g·ªçi kh√°c c·ªßa ng√¥n ng·ªØ h√†m (functional language) l√† g√¨?",
            "options": [
                "A. Ng√¥n ng·ªØ m√°y",
                "B. Ng√¥n ng·ªØ ·ª©ng d·ª•ng",
                "C. Ng√¥n ng·ªØ b·∫≠c th·∫•p",
                "D. Ng√¥n ng·ªØ b·∫≠c cao"
            ],
            "answer": "D. Ng√¥n ng·ªØ b·∫≠c cao",
            "explanation": "Ng√¥n ng·ªØ h√†m (nh∆∞ LISP, Haskell) l√† m·ªôt lo·∫°i m√¥ h√¨nh l·∫≠p tr√¨nh b·∫≠c cao. Ch√∫ng kh√°c bi·ªát v·ªõi c√°c ng√¥n ng·ªØ b·∫≠c th·∫•p nh∆∞ ng√¥n ng·ªØ m√°y ho·∫∑c h·ª£p ng·ªØ. **M·∫πo ghi nh·ªõ: Ng√¥n ng·ªØ h√†m l√† m·ªôt lo·∫°i ng√¥n ng·ªØ b·∫≠c cao.**"
        }
    },
    {
        "id": 199,
        "category": "Chapter 7: Programming (L·∫≠p tr√¨nh)",
        "en": {
            "question": "What is the language of the procedural paradigm that is a high-level language and also has some low-level instructions?",
            "options": [
                "A. Pascal",
                "B. C",
                "C. Ada",
                "D. COBOL"
            ],
            "answer": "B. C",
            "explanation": "The C programming language is famous for being a 'middle-level' language. It provides high-level constructs (loops, functions) but also allows for low-level memory manipulation through pointers. **Key takeaway: C = High-level + Low-level capabilities.**"
        },
        "vi": {
            "question": "Ng√¥n ng·ªØ n√†o thu·ªôc m√¥ h√¨nh th·ªß t·ª•c l√† m·ªôt ng√¥n ng·ªØ b·∫≠c cao v√† c≈©ng c√≥ m·ªôt s·ªë ch·ªâ th·ªã b·∫≠c th·∫•p?",
            "options": [
                "A. Pascal",
                "B. C",
                "C. Ada",
                "D. COBOL"
            ],
            "answer": "B. C",
            "explanation": "Ng√¥n ng·ªØ l·∫≠p tr√¨nh C n·ªïi ti·∫øng l√† m·ªôt ng√¥n ng·ªØ 'b·∫≠c trung'. N√≥ cung c·∫•p c√°c c·∫•u tr√∫c b·∫≠c cao (v√≤ng l·∫∑p, h√†m) nh∆∞ng c≈©ng cho ph√©p thao t√°c b·ªô nh·ªõ c·∫•p th·∫•p th√¥ng qua con tr·ªè. **M·∫πo ghi nh·ªõ: C = Kh·∫£ nƒÉng b·∫≠c cao + b·∫≠c th·∫•p.**"
        }
    },
    {
        "id": 200,
        "category": "Chapter 7: Programming (L·∫≠p tr√¨nh)",
        "en": {
            "question": "Pascal is a(n) ____ language.",
            "options": [
                "A. Procedural",
                "B. Functional",
                "C. Declarative",
                "D. Object-oriented"
            ],
            "answer": "A. Procedural",
            "explanation": "Pascal is a classic example of a procedural language, which focuses on a series of step-by-step instructions (procedures) to perform a task. **Key takeaway: Pascal = Procedural.**"
        },
        "vi": {
            "question": "Pascal l√† m·ªôt ng√¥n ng·ªØ ____.",
            "options": [
                "A. Th·ªß t·ª•c",
                "B. H√†m",
                "C. Khai b√°o",
                "D. H∆∞·ªõng ƒë·ªëi t∆∞·ª£ng"
            ],
            "answer": "A. Th·ªß t·ª•c",
            "explanation": "Pascal l√† m·ªôt v√≠ d·ª• kinh ƒëi·ªÉn c·ªßa ng√¥n ng·ªØ th·ªß t·ª•c, t·∫≠p trung v√†o m·ªôt lo·∫°t c√°c ch·ªâ th·ªã t·ª´ng b∆∞·ªõc (th·ªß t·ª•c) ƒë·ªÉ th·ª±c hi·ªán m·ªôt nhi·ªám v·ª•. **M·∫πo ghi nh·ªõ: Pascal = Th·ªß t·ª•c.**"
        }
    },
    {
        "id": 201,
        "category": "Chapter 7: Programming (L·∫≠p tr√¨nh)",
        "en": {
            "question": "FORTRAN is a(n) ____ language.",
            "options": [
                "A. Procedural",
                "B. Functional",
                "C. Declarative",
                "D. Object-oriented"
            ],
            "answer": "A. Procedural",
            "explanation": "FORTRAN (Formula Translation) is one of the earliest procedural languages, designed primarily for scientific and numerical computation. **Key takeaway: FORTRAN = Procedural.**"
        },
        "vi": {
            "question": "FORTRAN l√† m·ªôt ng√¥n ng·ªØ ____.",
            "options": [
                "A. Th·ªß t·ª•c",
                "B. H√†m",
                "C. Khai b√°o",
                "D. H∆∞·ªõng ƒë·ªëi t∆∞·ª£ng"
            ],
            "answer": "A. Th·ªß t·ª•c",
            "explanation": "FORTRAN (Formula Translation) l√† m·ªôt trong nh·ªØng ng√¥n ng·ªØ th·ªß t·ª•c s·ªõm nh·∫•t, ƒë∆∞·ª£c thi·∫øt k·∫ø ch·ªß y·∫øu cho t√≠nh to√°n khoa h·ªçc v√† s·ªë h·ªçc. **M·∫πo ghi nh·ªõ: FORTRAN = Th·ªß t·ª•c.**"
        }
    },
    {
        "id": 202,
        "category": "Chapter 7: Programming (L·∫≠p tr√¨nh)",
        "en": {
            "question": "Prolog is an example of a(n) ____ language.",
            "options": [
                "A. Procedural",
                "B. Functional",
                "C. Declarative",
                "D. Object-oriented"
            ],
            "answer": "C. Declarative",
            "explanation": "Prolog is a logic programming language, a type of declarative language. The programmer specifies the desired result ('what') by defining facts and rules, and the interpreter figures out 'how' to achieve it. **Key takeaway: Prolog = Logic = Declarative.**"
        },
        "vi": {
            "question": "Prolog l√† m·ªôt v√≠ d·ª• v·ªÅ ng√¥n ng·ªØ ____.",
            "options": [
                "A. Th·ªß t·ª•c",
                "B. H√†m",
                "C. Khai b√°o",
                "D. H∆∞·ªõng ƒë·ªëi t∆∞·ª£ng"
            ],
            "answer": "C. Khai b√°o",
            "explanation": "Prolog l√† m·ªôt ng√¥n ng·ªØ l·∫≠p tr√¨nh logic, l√† m·ªôt lo·∫°i ng√¥n ng·ªØ khai b√°o. L·∫≠p tr√¨nh vi√™n ch·ªâ ƒë·ªãnh k·∫øt qu·∫£ mong mu·ªën ('c√°i g√¨') b·∫±ng c√°ch ƒë·ªãnh nghƒ©a c√°c s·ª± ki·ªán v√† quy t·∫Øc, v√† tr√¨nh th√¥ng d·ªãch s·∫Ω t√¨m ra 'c√°ch' ƒë·ªÉ ƒë·∫°t ƒë∆∞·ª£c n√≥. **M·∫πo ghi nh·ªõ: Prolog = Logic = Khai b√°o.**"
        }
    },
    {
        "id": 203,
        "category": "Chapter 7: Programming (L·∫≠p tr√¨nh)",
        "en": {
            "question": "C++ and C# language are a(n) ____ language",
            "options": [
                "A. Procedural",
                "B. Functional",
                "C. Declarative",
                "D. Object-oriented"
            ],
            "answer": "D. Object-oriented",
            "explanation": "Both C++ and C# are primarily object-oriented programming (OOP) languages. They are built around the concepts of classes, objects, inheritance, and polymorphism. **Key takeaway: C++/C# = Object-Oriented.**"
        },
        "vi": {
            "question": "Ng√¥n ng·ªØ C++ v√† C# l√† m·ªôt ng√¥n ng·ªØ ____",
            "options": [
                "A. Th·ªß t·ª•c",
                "B. H√†m",
                "C. Khai b√°o",
                "D. H∆∞·ªõng ƒë·ªëi t∆∞·ª£ng"
            ],
            "answer": "D. H∆∞·ªõng ƒë·ªëi t∆∞·ª£ng",
            "explanation": "C·∫£ C++ v√† C# ch·ªß y·∫øu l√† c√°c ng√¥n ng·ªØ l·∫≠p tr√¨nh h∆∞·ªõng ƒë·ªëi t∆∞·ª£ng (OOP). Ch√∫ng ƒë∆∞·ª£c x√¢y d·ª±ng xung quanh c√°c kh√°i ni·ªám v·ªÅ l·ªõp, ƒë·ªëi t∆∞·ª£ng, k·∫ø th·ª´a v√† ƒëa h√¨nh. **M·∫πo ghi nh·ªõ: C++/C# = H∆∞·ªõng ƒë·ªëi t∆∞·ª£ng.**"
        }
    },
    {
        "id": 204,
        "category": "Chapter 7: Programming (L·∫≠p tr√¨nh)",
        "en": {
            "question": "The language that is an input for statement translation is called",
            "options": [
                "A. Assembly language",
                "B. Source language",
                "C. High-level language",
                "D. Object language"
            ],
            "answer": "B. Source language",
            "explanation": "In compilation, the program written by a human is called the source code/language. The output of the translator is the object code/language. **Key takeaway: Input to translator = Source language.**"
        },
        "vi": {
            "question": "Ng√¥n ng·ªØ l√† ƒë·∫ßu v√†o cho vi·ªác d·ªãch c√¢u l·ªánh ƒë∆∞·ª£c g·ªçi l√†",
            "options": [
                "A. H·ª£p ng·ªØ",
                "B. Ng√¥n ng·ªØ ngu·ªìn",
                "C. Ng√¥n ng·ªØ b·∫≠c cao",
                "D. Ng√¥n ng·ªØ ƒë·ªëi t∆∞·ª£ng"
            ],
            "answer": "B. Ng√¥n ng·ªØ ngu·ªìn",
            "explanation": "Trong bi√™n d·ªãch, ch∆∞∆°ng tr√¨nh do con ng∆∞·ªùi vi·∫øt ƒë∆∞·ª£c g·ªçi l√† m√£/ng√¥n ng·ªØ ngu·ªìn. ƒê·∫ßu ra c·ªßa tr√¨nh d·ªãch l√† m√£/ng√¥n ng·ªØ ƒë·ªëi t∆∞·ª£ng. **M·∫πo ghi nh·ªõ: ƒê·∫ßu v√†o c·ªßa tr√¨nh d·ªãch = Ng√¥n ng·ªØ ngu·ªìn.**"
        }
    },
    {
        "id": 205,
        "category": "Chapter 7: Programming (L·∫≠p tr√¨nh)",
        "en": {
            "question": "A computer language that is written in binary codes only is _______",
            "options": [
                "A. machine language",
                "B. C",
                "C. C#",
                "D. pascal"
            ],
            "answer": "A. machine language",
            "explanation": "Machine language is the lowest-level language, consisting of pure binary (0s and 1s) that the CPU can execute directly. **Key takeaway: Binary only = Machine language.**"
        },
        "vi": {
            "question": "M·ªôt ng√¥n ng·ªØ m√°y t√≠nh ch·ªâ ƒë∆∞·ª£c vi·∫øt b·∫±ng m√£ nh·ªã ph√¢n l√† _______",
            "options": [
                "A. ng√¥n ng·ªØ m√°y",
                "B. C",
                "C. C#",
                "D. pascal"
            ],
            "answer": "A. ng√¥n ng·ªØ m√°y",
            "explanation": "Ng√¥n ng·ªØ m√°y l√† ng√¥n ng·ªØ c·∫•p th·∫•p nh·∫•t, bao g·ªìm ho√†n to√†n l√† nh·ªã ph√¢n (0 v√† 1) m√† CPU c√≥ th·ªÉ th·ª±c thi tr·ª±c ti·∫øp. **M·∫πo ghi nh·ªõ: Ch·ªâ nh·ªã ph√¢n = Ng√¥n ng·ªØ m√°y.**"
        }
    },
    {
        "id": 206,
        "category": "Chapter 7: Programming (L·∫≠p tr√¨nh)",
        "en": {
            "question": "A program that reads each of the instructions in mnemonic form and translates it into the machine-language equivalent",
            "options": [
                "A. Machine language",
                "B. Assembler",
                "C. Interpreter",
                "D. C program"
            ],
            "answer": "B. Assembler",
            "explanation": "An assembler is a translator that converts assembly language (which uses mnemonics like ADD, MOV) into machine code. **Key takeaway: Translates mnemonics = Assembler.**"
        },
        "vi": {
            "question": "M·ªôt ch∆∞∆°ng tr√¨nh ƒë·ªçc t·ª´ng ch·ªâ th·ªã d∆∞·ªõi d·∫°ng g·ª£i nh·ªõ (mnemonic) v√† d·ªãch n√≥ th√†nh t∆∞∆°ng ƒë∆∞∆°ng ng√¥n ng·ªØ m√°y",
            "options": [
                "A. Ng√¥n ng·ªØ m√°y",
                "B. Tr√¨nh h·ª£p d·ªãch (Assembler)",
                "C. Tr√¨nh th√¥ng d·ªãch (Interpreter)",
                "D. Ch∆∞∆°ng tr√¨nh C"
            ],
            "answer": "B. Tr√¨nh h·ª£p d·ªãch (Assembler)",
            "explanation": "Tr√¨nh h·ª£p d·ªãch l√† m·ªôt tr√¨nh d·ªãch chuy·ªÉn ƒë·ªïi h·ª£p ng·ªØ (s·ª≠ d·ª•ng c√°c t·ª´ g·ª£i nh·ªõ nh∆∞ ADD, MOV) th√†nh m√£ m√°y. **M·∫πo ghi nh·ªõ: D·ªãch t·ª´ g·ª£i nh·ªõ = Tr√¨nh h·ª£p d·ªãch.**"
        }
    },
    {
        "id": 207,
        "category": "Chapter 7: Programming (L·∫≠p tr√¨nh)",
        "en": {
            "question": "Which Programming Paradigm treats a program as a series of mathematical functions that transform inputs into outputs and avoids changing state or variables?",
            "options": [
                "A. Procedural Paradigm.",
                "B. Object-Oriented Paradigm.",
                "C. Functional Paradigm.",
                "D. Declarative Paradigm."
            ],
            "answer": "C. Functional Paradigm.",
            "explanation": "The core idea of the functional paradigm is to use pure functions, which have no side effects (they don't change any state) and always produce the same output for the same input. **Key takeaway: Functional = Mathematical functions, no changing state.**"
        },
        "vi": {
            "question": "M√¥ h√¨nh l·∫≠p tr√¨nh (Programming Paradigm) n√†o xem ch∆∞∆°ng tr√¨nh nh∆∞ m·ªôt chu·ªói c√°c h√†m to√°n h·ªçc chuy·ªÉn ƒë·ªïi ƒë·∫ßu v√†o th√†nh ƒë·∫ßu ra v√† tr√°nh thay ƒë·ªïi tr·∫°ng th√°i ho·∫∑c bi·∫øn?",
            "options": [
                "A. Procedural Paradigm (M√¥ h√¨nh th·ªß t·ª•c).",
                "B. Object-Oriented Paradigm (M√¥ h√¨nh h∆∞·ªõng ƒë·ªëi t∆∞·ª£ng).",
                "C. Functional Paradigm (M√¥ h√¨nh h√†m).",
                "D. Declarative Paradigm (M√¥ h√¨nh khai b√°o)."
            ],
            "answer": "C. Functional Paradigm (M√¥ h√¨nh h√†m).",
            "explanation": "T√†i li·ªáu (M·ª•c 3.4) m√¥ t·∫£ Functional Paradigm l√† 'Treats programs as mathematical functions mapping inputs to outputs' v√† 'Avoids changing state or variables'. **M·∫πo ghi nh·ªõ: Functional = H√†m to√°n h·ªçc, kh√¥ng thay ƒë·ªïi tr·∫°ng th√°i.**"
        }
    },
    {
        "id": 208,
        "category": "Chapter 7: Programming (L·∫≠p tr√¨nh)",
        "en": {
            "question": "What is the main difference between a Compiler and an Interpreter?",
            "options": [
                "A. A compiler translates and executes line by line, while an interpreter translates the entire source code before execution.",
                "B. An interpreter translates the entire source code first, while a compiler translates and executes line by line.",
                "C. A compiler translates the entire source code before execution, while an interpreter translates and executes line by line.",
                "D. Both work exactly the same, only the names are different."
            ],
            "answer": "C. A compiler translates the entire source code before execution, while an interpreter translates and executes line by line.",
            "explanation": "A compiler creates a standalone executable file from the entire source code. An interpreter reads the source code one statement at a time, translates it, and executes it immediately before moving to the next line. **Key takeaway: Compiler = translates all, then runs. Interpreter = translates and runs one line at a time.**"
        },
        "vi": {
            "question": "S·ª± kh√°c bi·ªát ch√≠nh gi·ªØa tr√¨nh bi√™n d·ªãch (Compiler) v√† tr√¨nh th√¥ng d·ªãch (Interpreter) l√† g√¨?",
            "options": [
                "A. Compiler d·ªãch v√† th·ª±c thi t·ª´ng d√≤ng m·ªôt, c√≤n Interpreter d·ªãch to√†n b·ªô m√£ ngu·ªìn tr∆∞·ªõc khi th·ª±c thi.",
                "B. Interpreter d·ªãch to√†n b·ªô m√£ ngu·ªìn tr∆∞·ªõc, c√≤n Compiler d·ªãch v√† th·ª±c thi t·ª´ng d√≤ng.",
                "C. Compiler d·ªãch to√†n b·ªô m√£ ngu·ªìn tr∆∞·ªõc khi th·ª±c thi, c√≤n Interpreter d·ªãch v√† th·ª±c thi t·ª´ng d√≤ng m·ªôt.",
                "D. C·∫£ hai ƒë·ªÅu ho·∫°t ƒë·ªông gi·ªëng h·ªát nhau, ch·ªâ kh√°c t√™n g·ªçi."
            ],
            "answer": "C. Compiler d·ªãch to√†n b·ªô m√£ ngu·ªìn tr∆∞·ªõc khi th·ª±c thi, c√≤n Interpreter d·ªãch v√† th·ª±c thi t·ª´ng d√≤ng m·ªôt.",
            "explanation": "T√†i li·ªáu (M·ª•c 2.2) ph√¢n bi·ªát r√µ: 'Compilation: Translates the entire source code before execution' v√† 'Interpretation: Translates and executes code line by line'. **M·∫πo ghi nh·ªõ: Compiler = d·ªãch h·∫øt r·ªìi ch·∫°y. Interpreter = d·ªãch d√≤ng n√†o, ch·∫°y d√≤ng ƒë√≥.**"
        }
    },
    {
        "id": 209,
        "category": "Chapter 7: Programming (L·∫≠p tr√¨nh)",
        "en": {
            "question": "In programming, what is a fixed value written directly in the source code (e.g., the number `3.14` in the expression `area = 3.14 * r * r`) called?",
            "options": [
                "A. Variable.",
                "B. Constant.",
                "C. Literal.",
                "D. Identifier."
            ],
            "answer": "C. Literal.",
            "explanation": "A literal is a notation for representing a fixed value in source code. While it might be assigned to a constant, the value `3.14` itself is the literal. **Key takeaway: Literal = value written directly in code.**"
        },
        "vi": {
            "question": "Trong l·∫≠p tr√¨nh, m·ªôt gi√° tr·ªã c·ªë ƒë·ªãnh ƒë∆∞·ª£c vi·∫øt tr·ª±c ti·∫øp trong m√£ ngu·ªìn (v√≠ d·ª•: s·ªë `3.14` trong bi·ªÉu th·ª©c `area = 3.14 * r * r`) ƒë∆∞·ª£c g·ªçi l√† g√¨?",
            "options": [
                "A. Variable (Bi·∫øn).",
                "B. Constant (H·∫±ng).",
                "C. Literal (Gi√° tr·ªã nguy√™n b·∫£n/ch·ªØ).",
                "D. Identifier (ƒê·ªãnh danh)."
            ],
            "answer": "C. Literal (Gi√° tr·ªã nguy√™n b·∫£n/ch·ªØ).",
            "explanation": "T√†i li·ªáu (M·ª•c 4.5) ƒë·ªãnh nghƒ©a Literal l√† 'Fixed values written directly in code' (Gi√° tr·ªã c·ªë ƒë·ªãnh ƒë∆∞·ª£c vi·∫øt tr·ª±c ti·∫øp trong m√£). **M·∫πo ghi nh·ªõ: Literal = gi√° tr·ªã vi·∫øt th·∫≥ng trong code.**"
        }
    },
    {
        "id": 210,
        "category": "Chapter 7: Programming (L·∫≠p tr√¨nh)",
        "en": {
            "question": "Which of the following is considered a low-level language that replaces binary code with mnemonic symbols like ADD, MOV but is still hardware-dependent?",
            "options": [
                "A. Machine Language.",
                "B. Assembly Language.",
                "C. High-Level Language.",
                "D. Java."
            ],
            "answer": "B. Assembly Language.",
            "explanation": "Assembly language provides a layer of abstraction above raw machine code by using human-readable mnemonics, but each assembly instruction typically corresponds to one machine instruction, making it specific to a particular CPU architecture. **Key takeaway: Assembly = replaces binary with text, still hardware-dependent.**"
        },
        "vi": {
            "question": "Ng√¥n ng·ªØ n√†o sau ƒë√¢y ƒë∆∞·ª£c coi l√† ng√¥n ng·ªØ b·∫≠c th·∫•p, thay th·∫ø m√£ nh·ªã ph√¢n b·∫±ng c√°c k√Ω hi·ªáu g·ª£i nh·ªõ (mnemonics) nh∆∞ ADD, MOV nh∆∞ng v·∫´n ph·ª• thu·ªôc v√†o ph·∫ßn c·ª©ng?",
            "options": [
                "A. Machine Language (Ng√¥n ng·ªØ m√°y).",
                "B. Assembly Language (H·ª£p ng·ªØ).",
                "C. High-Level Language (Ng√¥n ng·ªØ b·∫≠c cao).",
                "D. Java."
            ],
            "answer": "B. Assembly Language (H·ª£p ng·ªØ).",
            "explanation": "T√†i li·ªáu (M·ª•c 1.3) m√¥ t·∫£ Assembly Language l√† 'Replaced binary codes with symbols (mnemonics) like ADD, MOV' v√† 'still hardware-dependent'. **M·∫πo ghi nh·ªõ: Assembly = thay m√£ nh·ªã ph√¢n b·∫±ng ch·ªØ, ph·ª• thu·ªôc ph·∫ßn c·ª©ng.**"
        }
    },
    {
        "id": 211,
        "category": "Chapter 7: Programming (L·∫≠p tr√¨nh)",
        "en": {
            "question": "Which programming paradigm focuses on 'active objects' that combine both data and behavior?",
            "options": [
                "A. Procedural Paradigm.",
                "B. Object-Oriented Paradigm.",
                "C. Functional Paradigm.",
                "D. Declarative Paradigm."
            ],
            "answer": "B. Object-Oriented Paradigm.",
            "explanation": "Object-Oriented Programming (OOP) is based on the concept of 'objects', which can contain data (in the form of fields or attributes) and code (in the form of procedures or methods). This bundling of data and behavior is a key feature. **Key takeaway: Object-Oriented = Objects with both data and behavior.**"
        },
        "vi": {
            "question": "M√¥ h√¨nh l·∫≠p tr√¨nh n√†o t·∫≠p trung v√†o c√°c 'ƒë·ªëi t∆∞·ª£ng ch·ªß ƒë·ªông' (active objects) k·∫øt h·ª£p c·∫£ d·ªØ li·ªáu v√† h√†nh vi (behavior)?",
            "options": [
                "A. Procedural Paradigm (M√¥ h√¨nh th·ªß t·ª•c).",
                "B. Object-Oriented Paradigm (M√¥ h√¨nh h∆∞·ªõng ƒë·ªëi t∆∞·ª£ng).",
                "C. Functional Paradigm (M√¥ h√¨nh h√†m).",
                "D. Declarative Paradigm (M√¥ h√¨nh khai b√°o)."
            ],
            "answer": "B. Object-Oriented Paradigm (M√¥ h√¨nh h∆∞·ªõng ƒë·ªëi t∆∞·ª£ng).",
            "explanation": "T√†i li·ªáu (M·ª•c 3.3) ƒë·ªãnh nghƒ©a Object-Oriented Paradigm l√† 'Works with active objects that combine data and behavior'. **M·∫πo ghi nh·ªõ: Object-Oriented = ƒê·ªëi t∆∞·ª£ng c√≥ c·∫£ d·ªØ li·ªáu v√† h√†nh vi.**"
        }
    },
    {
        "id": 212,
        "category": "Chapter 8: Software Engineering (K·ªπ thu·∫≠t ph·∫ßn m·ªÅm)",
        "en": {
            "question": "_______ is the design and writing of a program in structured form.",
            "options": [
                "A. Software engineering",
                "B. Hardware engineering",
                "C. Algorithm development",
                "D. Instructional architecture"
            ],
            "answer": "A. Software engineering",
            "explanation": "Software engineering is the systematic approach to the design, development, testing, and maintenance of software. It emphasizes structure, process, and quality. **Key takeaway: Systematic design of software = Software engineering.**"
        },
        "vi": {
            "question": "_______ l√† vi·ªác thi·∫øt k·∫ø v√† vi·∫øt m·ªôt ch∆∞∆°ng tr√¨nh theo d·∫°ng c√≥ c·∫•u tr√∫c.",
            "options": [
                "A. K·ªπ thu·∫≠t ph·∫ßn m·ªÅm",
                "B. K·ªπ thu·∫≠t ph·∫ßn c·ª©ng",
                "C. Ph√°t tri·ªÉn thu·∫≠t to√°n",
                "D. Ki·∫øn tr√∫c ch·ªâ th·ªã"
            ],
            "answer": "A. K·ªπ thu·∫≠t ph·∫ßn m·ªÅm",
            "explanation": "K·ªπ thu·∫≠t ph·∫ßn m·ªÅm l√† c√°ch ti·∫øp c·∫≠n c√≥ h·ªá th·ªëng ƒë·ªÉ thi·∫øt k·∫ø, ph√°t tri·ªÉn, ki·ªÉm th·ª≠ v√† b·∫£o tr√¨ ph·∫ßn m·ªÅm. N√≥ nh·∫•n m·∫°nh v√†o c·∫•u tr√∫c, quy tr√¨nh v√† ch·∫•t l∆∞·ª£ng. **M·∫πo ghi nh·ªõ: Thi·∫øt k·∫ø ph·∫ßn m·ªÅm c√≥ h·ªá th·ªëng = K·ªπ thu·∫≠t ph·∫ßn m·ªÅm.**"
        }
    },
    {
        "id": 213,
        "category": "Chapter 8: Software Engineering (K·ªπ thu·∫≠t ph·∫ßn m·ªÅm)",
        "en": {
            "question": "A program that is employed in the development, repair or enhancement of other programs is known as a _______.",
            "options": [
                "A. System software",
                "B. Software tool",
                "C. Applications program",
                "D. Utility program"
            ],
            "answer": "B. Software tool",
            "explanation": "A software tool is designed to help programmers create, debug, maintain, or otherwise support other programs. Examples include compilers, debuggers, and text editors. **Key takeaway: Program for programmers = Software tool.**"
        },
        "vi": {
            "question": "M·ªôt ch∆∞∆°ng tr√¨nh ƒë∆∞·ª£c s·ª≠ d·ª•ng trong vi·ªác ph√°t tri·ªÉn, s·ª≠a ch·ªØa ho·∫∑c n√¢ng cao c√°c ch∆∞∆°ng tr√¨nh kh√°c ƒë∆∞·ª£c g·ªçi l√† _______.",
            "options": [
                "A. Ph·∫ßn m·ªÅm h·ªá th·ªëng",
                "B. C√¥ng c·ª• ph·∫ßn m·ªÅm",
                "C. Ch∆∞∆°ng tr√¨nh ·ª©ng d·ª•ng",
                "D. Ch∆∞∆°ng tr√¨nh ti·ªán √≠ch"
            ],
            "answer": "B. C√¥ng c·ª• ph·∫ßn m·ªÅm",
            "explanation": "M·ªôt c√¥ng c·ª• ph·∫ßn m·ªÅm ƒë∆∞·ª£c thi·∫øt k·∫ø ƒë·ªÉ gi√∫p c√°c l·∫≠p tr√¨nh vi√™n t·∫°o, g·ª° l·ªói, b·∫£o tr√¨ ho·∫∑c h·ªó tr·ª£ c√°c ch∆∞∆°ng tr√¨nh kh√°c. V√≠ d·ª• bao g·ªìm tr√¨nh bi√™n d·ªãch, tr√¨nh g·ª° l·ªói v√† tr√¨nh so·∫°n th·∫£o vƒÉn b·∫£n. **M·∫πo ghi nh·ªõ: Ch∆∞∆°ng tr√¨nh cho l·∫≠p tr√¨nh vi√™n = C√¥ng c·ª• ph·∫ßn m·ªÅm.**"
        }
    },
    {
        "id": 214,
        "category": "Chapter 8: Software Engineering (K·ªπ thu·∫≠t ph·∫ßn m·ªÅm)",
        "en": {
            "question": "What is the model of software development where requirements are divided into multiple standalone modules of the software development cycle?",
            "options": [
                "A. waterfall model",
                "B. incremental model",
                "C. development process",
                "D. software engineering"
            ],
            "answer": "B. incremental model",
            "explanation": "The incremental model builds and delivers the software in pieces (increments). Each increment adds more functionality, allowing for early feedback and gradual development. **Key takeaway: Development in pieces = Incremental model.**"
        },
        "vi": {
            "question": "M√¥ h√¨nh ph√°t tri·ªÉn ph·∫ßn m·ªÅm n√†o m√† c√°c y√™u c·∫ßu ƒë∆∞·ª£c chia th√†nh nhi·ªÅu m√¥-ƒëun ƒë·ªôc l·∫≠p trong chu k·ª≥ ph√°t tri·ªÉn ph·∫ßn m·ªÅm?",
            "options": [
                "A. m√¥ h√¨nh th√°c n∆∞·ªõc",
                "B. m√¥ h√¨nh gia tƒÉng",
                "C. quy tr√¨nh ph√°t tri·ªÉn",
                "D. k·ªπ thu·∫≠t ph·∫ßn m·ªÅm"
            ],
            "answer": "B. m√¥ h√¨nh gia tƒÉng",
            "explanation": "M√¥ h√¨nh gia tƒÉng x√¢y d·ª±ng v√† cung c·∫•p ph·∫ßn m·ªÅm theo t·ª´ng ph·∫ßn (gia tƒÉng). M·ªói ph·∫ßn gia tƒÉng th√™m nhi·ªÅu ch·ª©c nƒÉng h∆°n, cho ph√©p nh·∫≠n ph·∫£n h·ªìi s·ªõm v√† ph√°t tri·ªÉn d·∫ßn d·∫ßn. **M·∫πo ghi nh·ªõ: Ph√°t tri·ªÉn theo t·ª´ng ph·∫ßn = M√¥ h√¨nh gia tƒÉng.**"
        }
    },
    {
        "id": 215,
        "category": "Chapter 8: Software Engineering (K·ªπ thu·∫≠t ph·∫ßn m·ªÅm)",
        "en": {
            "question": "What is the analysis process in the system implementation phase that will use a program as an active agent that manipulates passive objects?",
            "options": [
                "A. Procedure-oriented analysis",
                "B. Structured analysis",
                "C. Object-oriented analysis",
                "D. Classical analysis"
            ],
            "answer": "A. Procedure-oriented analysis",
            "explanation": "This describes the procedural paradigm. The program (composed of procedures/functions) is the 'active' part that acts upon the 'passive' data structures. In contrast, Object-Oriented analysis views objects as active agents with their own data and behavior. **Key takeaway: Active program + Passive data = Procedural.**"
        },
        "vi": {
            "question": "Quy tr√¨nh ph√¢n t√≠ch n√†o trong giai ƒëo·∫°n tri·ªÉn khai h·ªá th·ªëng s·∫Ω s·ª≠ d·ª•ng m·ªôt ch∆∞∆°ng tr√¨nh nh∆∞ m·ªôt t√°c nh√¢n ch·ªß ƒë·ªông thao t√°c c√°c ƒë·ªëi t∆∞·ª£ng th·ª• ƒë·ªông?",
            "options": [
                "A. Ph√¢n t√≠ch h∆∞·ªõng th·ªß t·ª•c",
                "B. Ph√¢n t√≠ch c√≥ c·∫•u tr√∫c",
                "C. Ph√¢n t√≠ch h∆∞·ªõng ƒë·ªëi t∆∞·ª£ng",
                "D. Ph√¢n t√≠ch c·ªï ƒëi·ªÉn"
            ],
            "answer": "A. Ph√¢n t√≠ch h∆∞·ªõng th·ªß t·ª•c",
            "explanation": "ƒêi·ªÅu n√†y m√¥ t·∫£ m√¥ h√¨nh th·ªß t·ª•c. Ch∆∞∆°ng tr√¨nh (bao g·ªìm c√°c th·ªß t·ª•c/h√†m) l√† ph·∫ßn 'ch·ªß ƒë·ªông' t√°c ƒë·ªông l√™n c√°c c·∫•u tr√∫c d·ªØ li·ªáu 'th·ª• ƒë·ªông'. Ng∆∞·ª£c l·∫°i, ph√¢n t√≠ch H∆∞·ªõng ƒë·ªëi t∆∞·ª£ng xem c√°c ƒë·ªëi t∆∞·ª£ng l√† t√°c nh√¢n ch·ªß ƒë·ªông v·ªõi d·ªØ li·ªáu v√† h√†nh vi ri√™ng. **M·∫πo ghi nh·ªõ: Ch∆∞∆°ng tr√¨nh ch·ªß ƒë·ªông + D·ªØ li·ªáu th·ª• ƒë·ªông = H∆∞·ªõng th·ªß t·ª•c.**"
        }
    },
    {
        "id": 216,
        "category": "Chapter 8: Software Engineering (K·ªπ thu·∫≠t ph·∫ßn m·ªÅm)",
        "en": {
            "question": "What kind of testing uses the structure of the software to guarantee that all decision constructs are tested on each branch?",
            "options": [
                "A. Testing phase",
                "B. White-box testing",
                "C. Black-box testing",
                "D. Boundary testing"
            ],
            "answer": "B. White-box testing",
            "explanation": "White-box (or glass-box) testing involves looking inside the 'box' to see the internal code structure. Testers use their knowledge of the code to ensure that all paths, branches, and conditions are executed. **Key takeaway: Testing internal structure = White-box.**"
        },
        "vi": {
            "question": "Lo·∫°i ki·ªÉm th·ª≠ n√†o s·ª≠ d·ª•ng c·∫•u tr√∫c c·ªßa ph·∫ßn m·ªÅm ƒë·ªÉ ƒë·∫£m b·∫£o r·∫±ng t·∫•t c·∫£ c√°c c·∫•u tr√∫c quy·∫øt ƒë·ªãnh ƒë·ªÅu ƒë∆∞·ª£c ki·ªÉm tra tr√™n m·ªói nh√°nh?",
            "options": [
                "A. Giai ƒëo·∫°n ki·ªÉm th·ª≠",
                "B. Ki·ªÉm th·ª≠ h·ªôp tr·∫Øng",
                "C. Ki·ªÉm th·ª≠ h·ªôp ƒëen",
                "D. Ki·ªÉm th·ª≠ bi√™n"
            ],
            "answer": "B. Ki·ªÉm th·ª≠ h·ªôp tr·∫Øng",
            "explanation": "Ki·ªÉm th·ª≠ h·ªôp tr·∫Øng (ho·∫∑c h·ªôp k√≠nh) li√™n quan ƒë·∫øn vi·ªác nh√¨n v√†o b√™n trong 'h·ªôp' ƒë·ªÉ xem c·∫•u tr√∫c m√£ n·ªôi b·ªô. Ng∆∞·ªùi ki·ªÉm th·ª≠ s·ª≠ d·ª•ng ki·∫øn th·ª©c v·ªÅ m√£ ƒë·ªÉ ƒë·∫£m b·∫£o r·∫±ng t·∫•t c·∫£ c√°c ƒë∆∞·ªùng ƒëi, nh√°nh v√† ƒëi·ªÅu ki·ªán ƒë·ªÅu ƒë∆∞·ª£c th·ª±c thi. **M·∫πo ghi nh·ªõ: Ki·ªÉm th·ª≠ c·∫•u tr√∫c b√™n trong = H·ªôp tr·∫Øng.**"
        }
    },
    {
        "id": 217,
        "category": "Chapter 8: Software Engineering (K·ªπ thu·∫≠t ph·∫ßn m·ªÅm)",
        "en": {
            "question": "What is the method in black-box testing where tests are designed to include representatives of boundary values in a range?",
            "options": [
                "A. Boundary-value testing",
                "B. Random testing",
                "C. Exhaustive testing",
                "D. Data flow testing"
            ],
            "answer": "A. Boundary-value testing",
            "explanation": "Boundary-value analysis is a black-box testing technique that focuses on testing the 'edges' or boundaries of an input domain (e.g., minimum, maximum, just inside/outside the boundary), as this is where errors often occur. **Key takeaway: Testing edges of a range = Boundary-value testing.**"
        },
        "vi": {
            "question": "Ph∆∞∆°ng ph√°p n√†o trong ki·ªÉm th·ª≠ h·ªôp ƒëen m√† c√°c b√†i ki·ªÉm tra ƒë∆∞·ª£c thi·∫øt k·∫ø ƒë·ªÉ bao g·ªìm c√°c ƒë·∫°i di·ªán c·ªßa c√°c gi√° tr·ªã bi√™n trong m·ªôt ph·∫°m vi?",
            "options": [
                "A. Ki·ªÉm th·ª≠ gi√° tr·ªã bi√™n",
                "B. Ki·ªÉm th·ª≠ ng·∫´u nhi√™n",
                "C. Ki·ªÉm th·ª≠ to√†n di·ªán",
                "D. Ki·ªÉm th·ª≠ lu·ªìng d·ªØ li·ªáu"
            ],
            "answer": "A. Ki·ªÉm th·ª≠ gi√° tr·ªã bi√™n",
            "explanation": "Ph√¢n t√≠ch gi√° tr·ªã bi√™n l√† m·ªôt k·ªπ thu·∫≠t ki·ªÉm th·ª≠ h·ªôp ƒëen t·∫≠p trung v√†o vi·ªác ki·ªÉm tra c√°c 'c·∫°nh' ho·∫∑c ranh gi·ªõi c·ªßa m·ªôt mi·ªÅn ƒë·∫ßu v√†o (v√≠ d·ª•: t·ªëi thi·ªÉu, t·ªëi ƒëa, ngay b√™n trong/b√™n ngo√†i ranh gi·ªõi), v√¨ ƒë√¢y l√† n∆°i l·ªói th∆∞·ªùng x·∫£y ra. **M·∫πo ghi nh·ªõ: Ki·ªÉm th·ª≠ c√°c c·∫°nh c·ªßa m·ªôt ph·∫°m vi = Ki·ªÉm th·ª≠ gi√° tr·ªã bi√™n.**"
        }
    },
    {
        "id": 218,
        "category": "Chapter 8: Software Engineering (K·ªπ thu·∫≠t ph·∫ßn m·ªÅm)",
        "en": {
            "question": "The _______ phase results in a specification document that shows what the software will do without specifying how it will be done.",
            "options": [
                "A. Analysis phase",
                "B. Design phase",
                "C. Implementation phase",
                "D. Testing phase"
            ],
            "answer": "A. Analysis phase",
            "explanation": "The analysis phase focuses on understanding and documenting the requirements ('what' the system must do). The design phase then figures out 'how' to build it. **Key takeaway: 'What' the software does = Analysis phase.**"
        },
        "vi": {
            "question": "Giai ƒëo·∫°n _______ t·∫°o ra m·ªôt t√†i li·ªáu ƒë·∫∑c t·∫£ cho th·∫•y ph·∫ßn m·ªÅm s·∫Ω l√†m g√¨ m√† kh√¥ng ch·ªâ ƒë·ªãnh c√°ch th·ª©c th·ª±c hi·ªán.",
            "options": [
                "A. Giai ƒëo·∫°n ph√¢n t√≠ch",
                "B. Giai ƒëo·∫°n thi·∫øt k·∫ø",
                "C. Giai ƒëo·∫°n tri·ªÉn khai",
                "D. Giai ƒëo·∫°n ki·ªÉm th·ª≠"
            ],
            "answer": "A. Giai ƒëo·∫°n ph√¢n t√≠ch",
            "explanation": "Giai ƒëo·∫°n ph√¢n t√≠ch t·∫≠p trung v√†o vi·ªác hi·ªÉu v√† ghi l·∫°i c√°c y√™u c·∫ßu ('c√°i g√¨' h·ªá th·ªëng ph·∫£i l√†m). Giai ƒëo·∫°n thi·∫øt k·∫ø sau ƒë√≥ s·∫Ω t√¨m ra 'c√°ch' ƒë·ªÉ x√¢y d·ª±ng n√≥. **M·∫πo ghi nh·ªõ: 'C√°i g√¨' ph·∫ßn m·ªÅm l√†m = Giai ƒëo·∫°n ph√¢n t√≠ch.**"
        }
    },
    {
        "id": 219,
        "category": "Chapter 8: Software Engineering (K·ªπ thu·∫≠t ph·∫ßn m·ªÅm)",
        "en": {
            "question": "If modules are written so that they can be reused in other systems then they have high levels of _______.",
            "options": [
                "A. Flexibility",
                "B. Interoperability",
                "C. Reusability",
                "D. Changeability"
            ],
            "answer": "C. Reusability",
            "explanation": "Reusability is the software quality metric that refers to the ability to use existing software components (modules, functions, classes) in new applications with minimal modification. **Key takeaway: Reused in other systems = Reusability.**"
        },
        "vi": {
            "question": "N·∫øu c√°c m√¥-ƒëun ƒë∆∞·ª£c vi·∫øt ƒë·ªÉ c√≥ th·ªÉ t√°i s·ª≠ d·ª•ng trong c√°c h·ªá th·ªëng kh√°c th√¨ ch√∫ng c√≥ m·ª©c ƒë·ªô _______ cao.",
            "options": [
                "A. Linh ho·∫°t",
                "B. T∆∞∆°ng t√°c",
                "C. T√°i s·ª≠ d·ª•ng",
                "D. Kh·∫£ nƒÉng thay ƒë·ªïi"
            ],
            "answer": "C. T√°i s·ª≠ d·ª•ng",
            "explanation": "T√°i s·ª≠ d·ª•ng l√† m·ªôt ch·ªâ s·ªë ch·∫•t l∆∞·ª£ng ph·∫ßn m·ªÅm ƒë·ªÅ c·∫≠p ƒë·∫øn kh·∫£ nƒÉng s·ª≠ d·ª•ng c√°c th√†nh ph·∫ßn ph·∫ßn m·ªÅm hi·ªán c√≥ (m√¥-ƒëun, h√†m, l·ªõp) trong c√°c ·ª©ng d·ª•ng m·ªõi v·ªõi s·ª± s·ª≠a ƒë·ªïi t·ªëi thi·ªÉu. **M·∫πo ghi nh·ªõ: T√°i s·ª≠ d·ª•ng trong h·ªá th·ªëng kh√°c = T√°i s·ª≠ d·ª•ng.**"
        }
    },
    {
        "id": 220,
        "category": "Chapter 8: Software Engineering (K·ªπ thu·∫≠t ph·∫ßn m·ªÅm)",
        "en": {
            "question": "Programs designed to perform specific tasks is called known as",
            "options": [
                "A. System software",
                "B. Application software",
                "C. Utility programs",
                "D. Operating system"
            ],
            "answer": "B. Application software",
            "explanation": "Application software (or an 'app') is designed for end-users to perform specific tasks, such as word processing, browsing the web, or playing a game. System software manages the computer itself. **Key takeaway: Specific user tasks = Application software.**"
        },
        "vi": {
            "question": "C√°c ch∆∞∆°ng tr√¨nh ƒë∆∞·ª£c thi·∫øt k·∫ø ƒë·ªÉ th·ª±c hi·ªán c√°c nhi·ªám v·ª• c·ª• th·ªÉ ƒë∆∞·ª£c g·ªçi l√†",
            "options": [
                "A. Ph·∫ßn m·ªÅm h·ªá th·ªëng",
                "B. Ph·∫ßn m·ªÅm ·ª©ng d·ª•ng",
                "C. Ch∆∞∆°ng tr√¨nh ti·ªán √≠ch",
                "D. H·ªá ƒëi·ªÅu h√†nh"
            ],
            "answer": "B. Ph·∫ßn m·ªÅm ·ª©ng d·ª•ng",
            "explanation": "Ph·∫ßn m·ªÅm ·ª©ng d·ª•ng (ho·∫∑c 'app') ƒë∆∞·ª£c thi·∫øt k·∫ø cho ng∆∞·ªùi d√πng cu·ªëi ƒë·ªÉ th·ª±c hi·ªán c√°c nhi·ªám v·ª• c·ª• th·ªÉ, ch·∫≥ng h·∫°n nh∆∞ x·ª≠ l√Ω vƒÉn b·∫£n, duy·ªát web ho·∫∑c ch∆°i game. Ph·∫ßn m·ªÅm h·ªá th·ªëng qu·∫£n l√Ω ch√≠nh m√°y t√≠nh. **M·∫πo ghi nh·ªõ: Nhi·ªám v·ª• ng∆∞·ªùi d√πng c·ª• th·ªÉ = Ph·∫ßn m·ªÅm ·ª©ng d·ª•ng.**"
        }
    },
    {
        "id": 221,
        "category": "Chapter 8: Software Engineering (K·ªπ thu·∫≠t ph·∫ßn m·ªÅm)",
        "en": {
            "question": "What is quality referring to the ability to move software from one hardware platform to another?",
            "options": [
                "A. Flexibility",
                "B. Interoperability",
                "C. Reusability",
                "D. Changeability"
            ],
            "answer": "B. Interoperability",
            "explanation": "While 'Portability' or 'Transferability' are more precise, 'Interoperability' is the closest fit, referring to the ability of systems to work together, which implies functioning across different platforms. **Key takeaway: Move software to different platforms = Portability/Interoperability.**"
        },
        "vi": {
            "question": "Ch·∫•t l∆∞·ª£ng n√†o ƒë·ªÅ c·∫≠p ƒë·∫øn kh·∫£ nƒÉng chuy·ªÉn ph·∫ßn m·ªÅm t·ª´ m·ªôt n·ªÅn t·∫£ng ph·∫ßn c·ª©ng n√†y sang n·ªÅn t·∫£ng ph·∫ßn c·ª©ng kh√°c?",
            "options": [
                "A. Linh ho·∫°t",
                "B. T∆∞∆°ng t√°c",
                "C. T√°i s·ª≠ d·ª•ng",
                "D. Kh·∫£ nƒÉng thay ƒë·ªïi"
            ],
            "answer": "B. T∆∞∆°ng t√°c",
            "explanation": "M·∫∑c d√π 'T√≠nh di ƒë·ªông' (Portability) ho·∫∑c 'Kh·∫£ nƒÉng chuy·ªÉn giao' (Transferability) ch√≠nh x√°c h∆°n, 'T∆∞∆°ng t√°c' (Interoperability) l√† l·ª±a ch·ªçn g·∫ßn nh·∫•t, ƒë·ªÅ c·∫≠p ƒë·∫øn kh·∫£ nƒÉng c√°c h·ªá th·ªëng l√†m vi·ªác c√πng nhau, ng·ª• √Ω ho·∫°t ƒë·ªông tr√™n c√°c n·ªÅn t·∫£ng kh√°c nhau. **M·∫πo ghi nh·ªõ: Chuy·ªÉn ph·∫ßn m·ªÅm sang n·ªÅn t·∫£ng kh√°c = T√≠nh di ƒë·ªông/T∆∞∆°ng t√°c.**"
        }
    },
    {
        "id": 222,
        "category": "Chapter 8: Software Engineering (K·ªπ thu·∫≠t ph·∫ßn m·ªÅm)",
        "en": {
            "question": "In software development models, which model has a process that flows strictly downward, where each phase only begins after the previous one is fully completed?",
            "options": [
                "A. Incremental Model.",
                "B. Agile Model.",
                "C. Waterfall Model.",
                "D. Spiral Model."
            ],
            "answer": "C. Waterfall Model.",
            "explanation": "The Waterfall Model is a sequential design process, in which progress is seen as flowing steadily downwards (like a waterfall) through the phases of conception, initiation, analysis, design, construction, testing, deployment and maintenance. **Key takeaway: Waterfall = flows down, one phase finishes before the next starts.**"
        },
        "vi": {
            "question": "Trong c√°c m√¥ h√¨nh ph√°t tri·ªÉn ph·∫ßn m·ªÅm, m√¥ h√¨nh n√†o c√≥ quy tr√¨nh di·ªÖn ra nghi√™m ng·∫∑t theo h∆∞·ªõng t·ª´ tr√™n xu·ªëng (downward), m·ªói giai ƒëo·∫°n ch·ªâ b·∫Øt ƒë·∫ßu khi giai ƒëo·∫°n tr∆∞·ªõc ƒë√≥ ƒë√£ ho√†n t·∫•t ho√†n to√†n?",
            "options": [
                "A. Incremental Model (M√¥ h√¨nh gia tƒÉng).",
                "B. Agile Model (M√¥ h√¨nh linh ho·∫°t).",
                "C. Waterfall Model (M√¥ h√¨nh th√°c n∆∞·ªõc).",
                "D. Spiral Model (M√¥ h√¨nh xo·∫Øn ·ªëc)."
            ],
            "answer": "C. Waterfall Model (M√¥ h√¨nh th√°c n∆∞·ªõc).",
            "explanation": "T√†i li·ªáu (M·ª•c 1.3) m√¥ t·∫£ Waterfall Model l√† 'The process flows strictly downward ‚Äî each phase starts only after the previous one finishes'. **M·∫πo ghi nh·ªõ: Waterfall = Th√°c n∆∞·ªõc = Ch·∫£y t·ª´ tr√™n xu·ªëng, xong b∆∞·ªõc n√†o m·ªõi t·ªõi b∆∞·ªõc ti·∫øp theo.**"
        }
    },
    {
        "id": 223,
        "category": "Chapter 8: Software Engineering (K·ªπ thu·∫≠t ph·∫ßn m·ªÅm)",
        "en": {
            "question": "Which type of software testing is performed without knowledge of the internal code structure of the program, focusing only on inputs and outputs?",
            "options": [
                "A. White-box Testing.",
                "B. Black-box Testing.",
                "C. Unit Testing.",
                "D. Integration Testing."
            ],
            "answer": "B. Black-box Testing.",
            "explanation": "In black-box testing, the tester treats the software as a 'black box'‚Äîthey cannot see its internal workings. Tests are based purely on the software's requirements and specifications. **Key takeaway: Black-box = Can't see inside, only test inputs/outputs.**"
        },
        "vi": {
            "question": "Lo·∫°i ki·ªÉm th·ª≠ ph·∫ßn m·ªÅm n√†o ƒë∆∞·ª£c th·ª±c hi·ªán m√† kh√¥ng c·∫ßn bi·∫øt ƒë·∫øn c·∫•u tr√∫c m√£ ngu·ªìn b√™n trong c·ªßa ch∆∞∆°ng tr√¨nh, ch·ªâ t·∫≠p trung v√†o ƒë·∫ßu v√†o v√† ƒë·∫ßu ra?",
            "options": [
                "A. White-box Testing (Ki·ªÉm th·ª≠ h·ªôp tr·∫Øng).",
                "B. Black-box Testing (Ki·ªÉm th·ª≠ h·ªôp ƒëen).",
                "C. Unit Testing (Ki·ªÉm th·ª≠ ƒë∆°n v·ªã).",
                "D. Integration Testing (Ki·ªÉm th·ª≠ t√≠ch h·ª£p)."
            ],
            "answer": "B. Black-box Testing (Ki·ªÉm th·ª≠ h·ªôp ƒëen).",
            "explanation": "T√†i li·ªáu (M·ª•c 5.3) ƒë·ªãnh nghƒ©a Black-box Testing l√† 'Tests the software without knowing its internal workings'. **M·∫πo ghi nh·ªõ: Black-box = H·ªôp ƒëen = Kh√¥ng bi·∫øt b√™n trong c√≥ g√¨, ch·ªâ quan t√¢m ƒë·∫ßu v√†o/ƒë·∫ßu ra.**"
        }
    },
    {
        "id": 224,
        "category": "Chapter 8: Software Engineering (K·ªπ thu·∫≠t ph·∫ßn m·ªÅm)",
        "en": {
            "question": "What is the output of the Analysis Phase in the software development life cycle?",
            "options": [
                "A. A complete software program.",
                "B. A specification document describing system requirements.",
                "C. A set of written source code modules.",
                "D. A detailed plan of the system architecture."
            ],
            "answer": "B. A specification document describing system requirements.",
            "explanation": "The primary goal and deliverable of the analysis phase is to produce a detailed requirements specification document. This document defines 'what' the system must do, serving as the foundation for the design phase. **Key takeaway: Analysis = 'What' = Requirements specification document.**"
        },
        "vi": {
            "question": "K·∫øt qu·∫£ ƒë·∫ßu ra c·ªßa Giai ƒëo·∫°n Ph√¢n t√≠ch (Analysis Phase) trong v√≤ng ƒë·ªùi ph√°t tri·ªÉn ph·∫ßn m·ªÅm l√† g√¨?",
            "options": [
                "A. M·ªôt ch∆∞∆°ng tr√¨nh ph·∫ßn m·ªÅm ho√†n ch·ªânh.",
                "B. M·ªôt t√†i li·ªáu ƒë·∫∑c t·∫£ y√™u c·∫ßu h·ªá th·ªëng (a specification document describing system requirements).",
                "C. M·ªôt b·ªô c√°c module m√£ ngu·ªìn ƒë√£ ƒë∆∞·ª£c vi·∫øt.",
                "D. M·ªôt b·∫£n k·∫ø ho·∫°ch chi ti·∫øt v·ªÅ ki·∫øn tr√∫c h·ªá th·ªëng."
            ],
            "answer": "B. M·ªôt t√†i li·ªáu ƒë·∫∑c t·∫£ y√™u c·∫ßu h·ªá th·ªëng (a specification document describing system requirements).",
            "explanation": "T√†i li·ªáu (M·ª•c 2.1) n√™u r√µ: 'The result is a specification document describing system requirements' v√† giai ƒëo·∫°n n√†y x√°c ƒë·ªãnh 'what the software will do, not how it will do it'. **M·∫πo ghi nh·ªõ: Analysis = What = T√†i li·ªáu ƒë·∫∑c t·∫£ y√™u c·∫ßu.**"
        }
    },
    {
        "id": 225,
        "category": "Chapter 8: Software Engineering (K·ªπ thu·∫≠t ph·∫ßn m·ªÅm)",
        "en": {
            "question": "Which software development model builds and improves software step-by-step through multiple small versions, with each new version adding new features?",
            "options": [
                "A. Waterfall Model.",
                "B. V-Model.",
                "C. Incremental Model.",
                "D. RAD Model."
            ],
            "answer": "C. Incremental Model.",
            "explanation": "The incremental model involves developing the system in a series of increments. Each increment delivers a portion of the total functionality, allowing for early user feedback and a more flexible development process than the Waterfall model. **Key takeaway: Incremental = Build in parts, adding features with each part.**"
        },
        "vi": {
            "question": "M√¥ h√¨nh ph√°t tri·ªÉn ph·∫ßn m·ªÅm n√†o x√¢y d·ª±ng v√† c·∫£i ti·∫øn ph·∫ßn m·ªÅm theo t·ª´ng b∆∞·ªõc qua nhi·ªÅu phi√™n b·∫£n nh·ªè, m·ªói phi√™n b·∫£n m·ªõi l·∫°i b·ªï sung th√™m c√°c t√≠nh nƒÉng m·ªõi?",
            "options": [
                "A. Waterfall Model (M√¥ h√¨nh th√°c n∆∞·ªõc).",
                "B. V-Model.",
                "C. Incremental Model (M√¥ h√¨nh gia tƒÉng).",
                "D. RAD Model."
            ],
            "answer": "C. Incremental Model (M√¥ h√¨nh gia tƒÉng).",
            "explanation": "T√†i li·ªáu (M·ª•c 1.4) m√¥ t·∫£ Incremental Model l√† 'Software is built and improved step by step in multiple versions. Each version adds new features...'. **M·∫πo ghi nh·ªõ: Incremental = Gia tƒÉng = L√†m t·ª´ng ph·∫ßn, m·ªói ph·∫ßn th√™m ch·ª©c nƒÉng.**"
        }
    },
    {
        "id": 226,
        "category": "Chapter 8: Software Engineering (K·ªπ thu·∫≠t ph·∫ßn m·ªÅm)",
        "en": {
            "question": "What is the ability to move or reuse software across different hardware platforms called?",
            "options": [
                "A. Operability.",
                "B. Maintainability.",
                "C. Transferability.",
                "D. Usability."
            ],
            "answer": "C. Transferability.",
            "explanation": "Transferability, often called portability, is a quality attribute of software that refers to how easily it can be transferred from one environment (e.g., hardware platform or operating system) to another. **Key takeaway: Transfer = Move software.**"
        },
        "vi": {
            "question": "Kh·∫£ nƒÉng di chuy·ªÉn ho·∫∑c t√°i s·ª≠ d·ª•ng ph·∫ßn m·ªÅm tr√™n nhi·ªÅu n·ªÅn t·∫£ng ph·∫ßn c·ª©ng kh√°c nhau ƒë∆∞·ª£c g·ªçi l√† g√¨?",
            "options": [
                "A. Operability (Kh·∫£ nƒÉng v·∫≠n h√†nh).",
                "B. Maintainability (Kh·∫£ nƒÉng b·∫£o tr√¨).",
                "C. Transferability (Kh·∫£ nƒÉng chuy·ªÉn giao).",
                "D. Usability (T√≠nh kh·∫£ d·ª•ng)."
            ],
            "answer": "C. Transferability (Kh·∫£ nƒÉng chuy·ªÉn giao).",
            "explanation": "T√†i li·ªáu (M·ª•c 4.6) ƒë·ªãnh nghƒ©a Transferability l√† 'Ability to move or reuse software across platforms'. **M·∫πo ghi nh·ªõ: Transfer = Chuy·ªÉn, di chuy·ªÉn ph·∫ßn m·ªÅm.**"
        }
    },
    {
        "id": 227,
        "category": "Chapter 9: Data Structures (C·∫•u tr√∫c d·ªØ li·ªáu)",
        "en": {
            "question": "A(n)___ is a suitable structure when a small number of insertions and deletions are required but a lot of searching and retrieval is needed.",
            "options": [
                "A. Record",
                "B. Array",
                "C. Linked list",
                "D. Tree"
            ],
            "answer": "B. Array",
            "explanation": "Arrays offer fast random access (searching/retrieval) using an index (O(1) complexity). However, insertions and deletions are slow (O(n)) because they may require shifting many elements. Linked lists are the opposite. **Key takeaway: Array = Fast search, slow insertion/deletion.**"
        },
        "vi": {
            "question": "M·ªôt ___ l√† m·ªôt c·∫•u tr√∫c ph√π h·ª£p khi y√™u c·∫ßu √≠t thao t√°c ch√®n v√† x√≥a nh∆∞ng c·∫ßn nhi·ªÅu thao t√°c t√¨m ki·∫øm v√† truy xu·∫•t.",
            "options": [
                "A. B·∫£n ghi",
                "B. M·∫£ng",
                "C. Danh s√°ch li√™n k·∫øt",
                "D. C√¢y"
            ],
            "answer": "B. M·∫£ng",
            "explanation": "M·∫£ng cung c·∫•p kh·∫£ nƒÉng truy c·∫≠p ng·∫´u nhi√™n nhanh (t√¨m ki·∫øm/truy xu·∫•t) b·∫±ng c√°ch s·ª≠ d·ª•ng ch·ªâ s·ªë (ƒë·ªô ph·ª©c t·∫°p O(1)). Tuy nhi√™n, vi·ªác ch√®n v√† x√≥a l·∫°i ch·∫≠m (O(n)) v√¨ c√≥ th·ªÉ ph·∫£i d·ªãch chuy·ªÉn nhi·ªÅu ph·∫ßn t·ª≠. Danh s√°ch li√™n k·∫øt th√¨ ng∆∞·ª£c l·∫°i. **M·∫πo ghi nh·ªõ: M·∫£ng = T√¨m ki·∫øm nhanh, ch√®n/x√≥a ch·∫≠m.**"
        }
    },
    {
        "id": 228,
        "category": "Chapter 9: Data Structures (C·∫•u tr√∫c d·ªØ li·ªáu)",
        "en": {
            "question": "The enqueue operation ___ an item at the ___ of the queue.",
            "options": [
                "A. Deletes, end",
                "B. Deletes, front",
                "C. Inserts, front",
                "D. inserts, rear"
            ],
            "answer": "D. inserts, rear",
            "explanation": "A queue follows a FIFO (First-In, First-Out) principle. New items are added (enqueued) to the back (rear) of the line. **Key takeaway: Enqueue = Insert at rear.**"
        },
        "vi": {
            "question": "Thao t√°c enqueue ___ m·ªôt m·ª•c ·ªü ___ c·ªßa h√†ng ƒë·ª£i.",
            "options": [
                "A. X√≥a, cu·ªëi",
                "B. X√≥a, ƒë·∫ßu",
                "C. Ch√®n, ƒë·∫ßu",
                "D. ch√®n, cu·ªëi"
            ],
            "answer": "D. ch√®n, cu·ªëi",
            "explanation": "M·ªôt h√†ng ƒë·ª£i tu√¢n theo nguy√™n t·∫Øc FIFO (V√†o tr∆∞·ªõc, Ra tr∆∞·ªõc). C√°c m·ª•c m·ªõi ƒë∆∞·ª£c th√™m (enqueue) v√†o cu·ªëi (rear) c·ªßa h√†ng. **M·∫πo ghi nh·ªõ: Enqueue = Ch√®n v√†o cu·ªëi.**"
        }
    },
    {
        "id": 229,
        "category": "Chapter 9: Data Structures (C·∫•u tr√∫c d·ªØ li·ªáu)",
        "en": {
            "question": "The dequeue operation ___ the item at the ___ of the queue.",
            "options": [
                "A. deletes, front",
                "B. Deletes, end",
                "C. Inserts, front",
                "D. Inserts, rear"
            ],
            "answer": "A. deletes, front",
            "explanation": "A queue follows a FIFO (First-In, First-Out) principle. Items are removed (dequeued) from the front of the line. **Key takeaway: Dequeue = Delete from front.**"
        },
        "vi": {
            "question": "Thao t√°c dequeue ___ m·ª•c ·ªü ___ c·ªßa h√†ng ƒë·ª£i.",
            "options": [
                "A. x√≥a, ƒë·∫ßu",
                "B. X√≥a, cu·ªëi",
                "C. Ch√®n, ƒë·∫ßu",
                "D. Ch√®n, cu·ªëi"
            ],
            "answer": "A. x√≥a, ƒë·∫ßu",
            "explanation": "M·ªôt h√†ng ƒë·ª£i tu√¢n theo nguy√™n t·∫Øc FIFO (V√†o tr∆∞·ªõc, Ra tr∆∞·ªõc). C√°c m·ª•c ƒë∆∞·ª£c x√≥a (dequeue) kh·ªèi ƒë·∫ßu h√†ng. **M·∫πo ghi nh·ªõ: Dequeue = X√≥a t·ª´ ƒë·∫ßu.**"
        }
    },
    {
        "id": 230,
        "category": "Chapter 9: Data Structures (C·∫•u tr√∫c d·ªØ li·ªáu)",
        "en": {
            "question": "What is the order of postorder traversal in a Binary Tree?",
            "options": [
                "A. Right, root, left",
                "B. Root, right, left",
                "C. Left, right, root",
                "D. Left, root, right"
            ],
            "answer": "C. Left, right, root",
            "explanation": "The name 'postorder' means the root node is processed 'post' (after) its children. The traversal order is always Left subtree, then Right subtree, then the Root itself. **Key takeaway: Postorder = Left, Right, Root.**"
        },
        "vi": {
            "question": "Th·ª© t·ª± duy·ªát h·∫≠u th·ª© t·ª± (postorder) trong m·ªôt C√¢y nh·ªã ph√¢n l√† g√¨?",
            "options": [
                "A. Ph·∫£i, g·ªëc, tr√°i",
                "B. G·ªëc, ph·∫£i, tr√°i",
                "C. Tr√°i, ph·∫£i, g·ªëc",
                "D. Tr√°i, g·ªëc, ph·∫£i"
            ],
            "answer": "C. Tr√°i, ph·∫£i, g·ªëc",
            "explanation": "T√™n 'postorder' (h·∫≠u th·ª© t·ª±) c√≥ nghƒ©a l√† n√∫t g·ªëc ƒë∆∞·ª£c x·ª≠ l√Ω 'sau' (post) c√°c con c·ªßa n√≥. Th·ª© t·ª± duy·ªát lu√¥n l√† C√¢y con tr√°i, sau ƒë√≥ C√¢y con ph·∫£i, r·ªìi ƒë·∫øn ch√≠nh N√∫t g·ªëc. **M·∫πo ghi nh·ªõ: H·∫≠u th·ª© t·ª± = Tr√°i, Ph·∫£i, G·ªëc.**"
        }
    },
    {
        "id": 231,
        "category": "Chapter 9: Data Structures (C·∫•u tr√∫c d·ªØ li·ªáu)",
        "en": {
            "question": "Before insertion into a linked list we first apply the searching algorithm because we DO NOT allow ____.",
            "options": [
                "A. insertion into an empty list",
                "B. insertion in the middle of the list",
                "C. insertion at the beginning of the list",
                "D. data with duplicate values"
            ],
            "answer": "D. data with duplicate values",
            "explanation": "This is a common constraint for ordered linked lists or sets implemented with linked lists. To maintain uniqueness, you must first search the list to ensure the item to be inserted does not already exist. **Key takeaway: Search before insert to prevent duplicates.**"
        },
        "vi": {
            "question": "Tr∆∞·ªõc khi ch√®n v√†o m·ªôt danh s√°ch li√™n k·∫øt, ch√∫ng ta √°p d·ª•ng thu·∫≠t to√°n t√¨m ki·∫øm tr∆∞·ªõc v√¨ ch√∫ng ta KH√îNG cho ph√©p ____.",
            "options": [
                "A. ch√®n v√†o m·ªôt danh s√°ch r·ªóng",
                "B. ch√®n v√†o gi·ªØa danh s√°ch",
                "C. ch√®n v√†o ƒë·∫ßu danh s√°ch",
                "D. d·ªØ li·ªáu c√≥ gi√° tr·ªã tr√πng l·∫∑p"
            ],
            "answer": "D. d·ªØ li·ªáu c√≥ gi√° tr·ªã tr√πng l·∫∑p",
            "explanation": "ƒê√¢y l√† m·ªôt r√†ng bu·ªôc ph·ªï bi·∫øn cho c√°c danh s√°ch li√™n k·∫øt c√≥ th·ª© t·ª± ho·∫∑c c√°c t·∫≠p h·ª£p ƒë∆∞·ª£c tri·ªÉn khai b·∫±ng danh s√°ch li√™n k·∫øt. ƒê·ªÉ duy tr√¨ t√≠nh duy nh·∫•t, b·∫°n ph·∫£i t√¨m ki·∫øm danh s√°ch tr∆∞·ªõc ƒë·ªÉ ƒë·∫£m b·∫£o m·ª•c c·∫ßn ch√®n ch∆∞a t·ªìn t·∫°i. **M·∫πo ghi nh·ªõ: T√¨m ki·∫øm tr∆∞·ªõc khi ch√®n ƒë·ªÉ ngƒÉn tr√πng l·∫∑p.**"
        }
    },
    {
        "id": 232,
        "category": "Chapter 9: Data Structures (C·∫•u tr√∫c d·ªØ li·ªáu)",
        "en": {
            "question": "The number of logical records in a physical record is the _______.",
            "options": [
                "A. Group",
                "B. Blocking factor",
                "C. Sector",
                "D. Field"
            ],
            "answer": "B. Blocking factor",
            "explanation": "In file systems, a 'physical record' or 'block' is the unit of data transferred from storage. To improve efficiency, multiple 'logical records' (the records your program sees) are grouped into one physical block. The number of logical records per block is the blocking factor. **Key takeaway: Logical records per physical block = Blocking factor.**"
        },
        "vi": {
            "question": "S·ªë l∆∞·ª£ng b·∫£n ghi logic trong m·ªôt b·∫£n ghi v·∫≠t l√Ω l√† _______.",
            "options": [
                "A. Nh√≥m",
                "B. H·ªá s·ªë kh·ªëi",
                "C. Cung",
                "D. Tr∆∞·ªùng"
            ],
            "answer": "B. H·ªá s·ªë kh·ªëi",
            "explanation": "Trong c√°c h·ªá th·ªëng t·ªáp, m·ªôt 'b·∫£n ghi v·∫≠t l√Ω' ho·∫∑c 'kh·ªëi' l√† ƒë∆°n v·ªã d·ªØ li·ªáu ƒë∆∞·ª£c truy·ªÅn t·ª´ b·ªô l∆∞u tr·ªØ. ƒê·ªÉ c·∫£i thi·ªán hi·ªáu qu·∫£, nhi·ªÅu 'b·∫£n ghi logic' (c√°c b·∫£n ghi m√† ch∆∞∆°ng tr√¨nh c·ªßa b·∫°n th·∫•y) ƒë∆∞·ª£c nh√≥m v√†o m·ªôt kh·ªëi v·∫≠t l√Ω. S·ªë l∆∞·ª£ng b·∫£n ghi logic tr√™n m·ªói kh·ªëi l√† h·ªá s·ªë kh·ªëi. **M·∫πo ghi nh·ªõ: B·∫£n ghi logic tr√™n m·ªói kh·ªëi v·∫≠t l√Ω = H·ªá s·ªë kh·ªëi.**"
        }
    },
    {
        "id": 233,
        "category": "Chapter 9: Data Structures (C·∫•u tr√∫c d·ªØ li·ªáu)",
        "en": {
            "question": "Given a linked list called children, the pointer variable children identifies the ___ element of the linked list.",
            "options": [
                "A. The first",
                "B. The second",
                "C. The last",
                "D. Any"
            ],
            "answer": "A. The first",
            "explanation": "The head pointer of a linked list is the entry point to the entire list. It holds the memory address of the very first node. **Key takeaway: List's name/pointer = First element.**"
        },
        "vi": {
            "question": "Cho m·ªôt danh s√°ch li√™n k·∫øt c√≥ t√™n l√† children, bi·∫øn con tr·ªè children x√°c ƒë·ªãnh ph·∫ßn t·ª≠ ___ c·ªßa danh s√°ch li√™n k·∫øt.",
            "options": [
                "A. ƒê·∫ßu ti√™n",
                "B. Th·ª© hai",
                "C. Cu·ªëi c√πng",
                "D. B·∫•t k·ª≥"
            ],
            "answer": "A. ƒê·∫ßu ti√™n",
            "explanation": "Con tr·ªè ƒë·∫ßu c·ªßa m·ªôt danh s√°ch li√™n k·∫øt l√† ƒëi·ªÉm v√†o c·ªßa to√†n b·ªô danh s√°ch. N√≥ gi·ªØ ƒë·ªãa ch·ªâ b·ªô nh·ªõ c·ªßa n√∫t ƒë·∫ßu ti√™n. **M·∫πo ghi nh·ªõ: T√™n/con tr·ªè c·ªßa danh s√°ch = Ph·∫ßn t·ª≠ ƒë·∫ßu ti√™n.**"
        }
    },
    {
        "id": 234,
        "category": "Chapter 9: Data Structures (C·∫•u tr√∫c d·ªØ li·ªáu)",
        "en": {
            "question": "The queue operation: queue(queueName) is used to ____.",
            "options": [
                "A. delete a queue",
                "B. check the status of a queue",
                "C. create an empty queue",
                "D. insert into a queue"
            ],
            "answer": "C. create an empty queue",
            "explanation": "This syntax typically represents the constructor or initialization function for a data structure. It creates a new, empty instance of a queue named `queueName`. **Key takeaway: `struct(name)` usually means create/initialize.**"
        },
        "vi": {
            "question": "Thao t√°c h√†ng ƒë·ª£i: queue(queueName) ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ ____.",
            "options": [
                "A. x√≥a m·ªôt h√†ng ƒë·ª£i",
                "B. ki·ªÉm tra tr·∫°ng th√°i c·ªßa m·ªôt h√†ng ƒë·ª£i",
                "C. t·∫°o m·ªôt h√†ng ƒë·ª£i r·ªóng",
                "D. ch√®n v√†o m·ªôt h√†ng ƒë·ª£i"
            ],
            "answer": "C. t·∫°o m·ªôt h√†ng ƒë·ª£i r·ªóng",
            "explanation": "C√∫ ph√°p n√†y th∆∞·ªùng ƒë·∫°i di·ªán cho h√†m t·∫°o ho·∫∑c h√†m kh·ªüi t·∫°o cho m·ªôt c·∫•u tr√∫c d·ªØ li·ªáu. N√≥ t·∫°o ra m·ªôt th·ªÉ hi·ªán m·ªõi, r·ªóng c·ªßa m·ªôt h√†ng ƒë·ª£i c√≥ t√™n l√† `queueName`. **M·∫πo ghi nh·ªõ: `struct(name)` th∆∞·ªùng c√≥ nghƒ©a l√† t·∫°o/kh·ªüi t·∫°o.**"
        }
    },
    {
        "id": 235,
        "category": "Chapter 9: Data Structures (C·∫•u tr√∫c d·ªØ li·ªáu)",
        "en": {
            "question": "Each node in a graph can have ___ parents.",
            "options": [
                "A. One or more",
                "B. Only one",
                "C. At most two",
                "D. No node"
            ],
            "answer": "A. One or more",
            "explanation": "This distinguishes a graph from a tree. In a tree, each node (except the root) has exactly one parent. In a graph, a node (vertex) can have multiple incoming edges, meaning it can have one or more 'parents'. **Key takeaway: Graph nodes can have multiple parents; tree nodes cannot.**"
        },
        "vi": {
            "question": "M·ªói n√∫t trong m·ªôt ƒë·ªì th·ªã c√≥ th·ªÉ c√≥ ___ n√∫t cha.",
            "options": [
                "A. M·ªôt ho·∫∑c nhi·ªÅu",
                "B. Ch·ªâ m·ªôt",
                "C. T·ªëi ƒëa hai",
                "D. Kh√¥ng c√≥ n√∫t n√†o"
            ],
            "answer": "A. M·ªôt ho·∫∑c nhi·ªÅu",
            "explanation": "ƒêi·ªÅu n√†y ph√¢n bi·ªát m·ªôt ƒë·ªì th·ªã v·ªõi m·ªôt c√¢y. Trong m·ªôt c√¢y, m·ªói n√∫t (tr·ª´ g·ªëc) c√≥ ƒë√∫ng m·ªôt n√∫t cha. Trong m·ªôt ƒë·ªì th·ªã, m·ªôt n√∫t (ƒë·ªânh) c√≥ th·ªÉ c√≥ nhi·ªÅu c·∫°nh ƒëi v√†o, c√≥ nghƒ©a l√† n√≥ c√≥ th·ªÉ c√≥ m·ªôt ho·∫∑c nhi·ªÅu 'n√∫t cha'. **M·∫πo ghi nh·ªõ: N√∫t ƒë·ªì th·ªã c√≥ th·ªÉ c√≥ nhi·ªÅu cha; n√∫t c√¢y th√¨ kh√¥ng.**"
        }
    },
    {
        "id": 236,
        "category": "Chapter 9: Data Structures (C·∫•u tr√∫c d·ªØ li·ªáu)",
        "en": {
            "question": "In ____ , edges are ordered pairs of vertices. If an edge e = (x, y), x is called the starting point and y is called the endpoint.",
            "options": [
                "A. Directed graph",
                "B. Undirected graph",
                "C. Edges",
                "D. Arcs"
            ],
            "answer": "A. Directed graph",
            "explanation": "The concept of an 'ordered pair' (x, y) implies direction, from x to y. This is the definition of a directed graph (or digraph). In an undirected graph, an edge (x, y) is the same as (y, x). **Key takeaway: Ordered pair / Start & End point = Directed Graph.**"
        },
        "vi": {
            "question": "Trong ____ , c√°c c·∫°nh l√† c√°c c·∫∑p ƒë·ªânh c√≥ th·ª© t·ª±. N·∫øu m·ªôt c·∫°nh e = (x, y), x ƒë∆∞·ª£c g·ªçi l√† ƒëi·ªÉm b·∫Øt ƒë·∫ßu v√† y ƒë∆∞·ª£c g·ªçi l√† ƒëi·ªÉm k·∫øt th√∫c.",
            "options": [
                "A. ƒê·ªì th·ªã c√≥ h∆∞·ªõng",
                "B. ƒê·ªì th·ªã v√¥ h∆∞·ªõng",
                "C. C√°c c·∫°nh",
                "D. C√°c cung"
            ],
            "answer": "A. ƒê·ªì th·ªã c√≥ h∆∞·ªõng",
            "explanation": "Kh√°i ni·ªám 'c·∫∑p c√≥ th·ª© t·ª±' (x, y) ng·ª• √Ω h∆∞·ªõng, t·ª´ x ƒë·∫øn y. ƒê√¢y l√† ƒë·ªãnh nghƒ©a c·ªßa m·ªôt ƒë·ªì th·ªã c√≥ h∆∞·ªõng (hay digraph). Trong m·ªôt ƒë·ªì th·ªã v√¥ h∆∞·ªõng, m·ªôt c·∫°nh (x, y) gi·ªëng nh∆∞ (y, x). **M·∫πo ghi nh·ªõ: C·∫∑p c√≥ th·ª© t·ª± / ƒêi·ªÉm ƒë·∫ßu & cu·ªëi = ƒê·ªì th·ªã c√≥ h∆∞·ªõng.**"
        }
    },
    {
        "id": 237,
        "category": "Chapter 9: Data Structures (C·∫•u tr√∫c d·ªØ li·ªáu)",
        "en": {
            "question": "Inside the ADT are two different parts of the model that are ___ and ___.",
            "options": [
                "A. Data structure and application program",
                "B. Application program and private operations",
                "C. Application program and public operations",
                "D. Data structure and operations"
            ],
            "answer": "D. Data structure and operations",
            "explanation": "An Abstract Data Type (ADT) defines a logical model for a data type by specifying the data it holds and the operations that can be performed on that data, hiding the implementation details. **Key takeaway: ADT = Data + Operations.**"
        },
        "vi": {
            "question": "B√™n trong m·ªôt ADT (Ki·ªÉu d·ªØ li·ªáu tr·ª´u t∆∞·ª£ng) c√≥ hai ph·∫ßn kh√°c nhau c·ªßa m√¥ h√¨nh l√† ___ v√† ___.",
            "options": [
                "A. C·∫•u tr√∫c d·ªØ li·ªáu v√† ch∆∞∆°ng tr√¨nh ·ª©ng d·ª•ng",
                "B. Ch∆∞∆°ng tr√¨nh ·ª©ng d·ª•ng v√† c√°c ho·∫°t ƒë·ªông ri√™ng t∆∞",
                "C. Ch∆∞∆°ng tr√¨nh ·ª©ng d·ª•ng v√† c√°c ho·∫°t ƒë·ªông c√¥ng khai",
                "D. C·∫•u tr√∫c d·ªØ li·ªáu v√† c√°c ho·∫°t ƒë·ªông"
            ],
            "answer": "D. C·∫•u tr√∫c d·ªØ li·ªáu v√† c√°c ho·∫°t ƒë·ªông",
            "explanation": "M·ªôt Ki·ªÉu d·ªØ li·ªáu tr·ª´u t∆∞·ª£ng (ADT) ƒë·ªãnh nghƒ©a m·ªôt m√¥ h√¨nh logic cho m·ªôt ki·ªÉu d·ªØ li·ªáu b·∫±ng c√°ch ch·ªâ ƒë·ªãnh d·ªØ li·ªáu m√† n√≥ ch·ª©a v√† c√°c ho·∫°t ƒë·ªông c√≥ th·ªÉ ƒë∆∞·ª£c th·ª±c hi·ªán tr√™n d·ªØ li·ªáu ƒë√≥, che gi·∫•u c√°c chi ti·∫øt tri·ªÉn khai. **M·∫πo ghi nh·ªõ: ADT = D·ªØ li·ªáu + Ho·∫°t ƒë·ªông.**"
        }
    },
    {
        "id": 238,
        "category": "Chapter 9: Data Structures (C·∫•u tr√∫c d·ªØ li·ªáu)",
        "en": {
            "question": "An array that consists of just rows and columns is a _______ array.",
            "options": [
                "A. One-dimensional",
                "B. Two-dimensional",
                "C. Three-dimensional",
                "D. Multidimensional"
            ],
            "answer": "B. Two-dimensional",
            "explanation": "A one-dimensional array is a single line of elements. An array with a grid-like structure of rows and columns is a two-dimensional (2D) array. **Key takeaway: Rows and Columns = 2D array.**"
        },
        "vi": {
            "question": "M·ªôt m·∫£ng ch·ªâ bao g·ªìm c√°c h√†ng v√† c·ªôt l√† m·ªôt m·∫£ng _______.",
            "options": [
                "A. M·ªôt chi·ªÅu",
                "B. Hai chi·ªÅu",
                "C. Ba chi·ªÅu",
                "D. ƒêa chi·ªÅu"
            ],
            "answer": "B. Hai chi·ªÅu",
            "explanation": "M·ªôt m·∫£ng m·ªôt chi·ªÅu l√† m·ªôt d√≤ng duy nh·∫•t c√°c ph·∫ßn t·ª≠. M·ªôt m·∫£ng c√≥ c·∫•u tr√∫c d·∫°ng l∆∞·ªõi g·ªìm c√°c h√†ng v√† c·ªôt l√† m·ªôt m·∫£ng hai chi·ªÅu (2D). **M·∫πo ghi nh·ªõ: H√†ng v√† C·ªôt = M·∫£ng 2D.**"
        }
    },
    {
        "id": 239,
        "category": "Chapter 9: Data Structures (C·∫•u tr√∫c d·ªØ li·ªáu)",
        "en": {
            "question": "To traverse a list, you need a _______ pointer.",
            "options": [
                "A. Null",
                "B. Walking",
                "C. Beginning",
                "D. Insertion"
            ],
            "answer": "B. Walking",
            "explanation": "A 'walking' or 'traversal' pointer is a temporary pointer variable that starts at the head of the list and moves from node to node (e.g., `walker = walker->next`) until it reaches the end. **Key takeaway: Moving through a list = Walking pointer.**"
        },
        "vi": {
            "question": "ƒê·ªÉ duy·ªát qua m·ªôt danh s√°ch, b·∫°n c·∫ßn m·ªôt con tr·ªè _______.",
            "options": [
                "A. Null",
                "B. Di chuy·ªÉn (Walking)",
                "C. B·∫Øt ƒë·∫ßu",
                "D. Ch√®n"
            ],
            "answer": "B. Di chuy·ªÉn (Walking)",
            "explanation": "M·ªôt con tr·ªè 'di chuy·ªÉn' ho·∫∑c 'duy·ªát' l√† m·ªôt bi·∫øn con tr·ªè t·∫°m th·ªùi b·∫Øt ƒë·∫ßu t·ª´ ƒë·∫ßu danh s√°ch v√† di chuy·ªÉn t·ª´ n√∫t n√†y sang n√∫t kh√°c (v√≠ d·ª•: `walker = walker->next`) cho ƒë·∫øn khi n√≥ ƒë·∫øn cu·ªëi. **M·∫πo ghi nh·ªõ: Di chuy·ªÉn qua danh s√°ch = Con tr·ªè di chuy·ªÉn.**"
        }
    },
    {
        "id": 240,
        "category": "Chapter 9: Data Structures (C·∫•u tr√∫c d·ªØ li·ªáu)",
        "en": {
            "question": "What is more common technique of two-dimensional arrays that can be stored in memory?",
            "options": [
                "A. Column-major storage",
                "B. DMA",
                "C. Isolated I/O",
                "D. Row-major storage"
            ],
            "answer": "D. Row-major storage",
            "explanation": "Row-major order stores a 2D array by storing all elements of the first row consecutively, followed by all elements of the second row, and so on. This is the standard in languages like C, C++, and Python. **Key takeaway: C-like languages store arrays row-by-row.**"
        },
        "vi": {
            "question": "K·ªπ thu·∫≠t ph·ªï bi·∫øn h∆°n ƒë·ªÉ l∆∞u tr·ªØ m·∫£ng hai chi·ªÅu trong b·ªô nh·ªõ l√† g√¨?",
            "options": [
                "A. L∆∞u tr·ªØ theo c·ªôt ch√≠nh",
                "B. DMA",
                "C. I/O c√¥ l·∫≠p",
                "D. L∆∞u tr·ªØ theo h√†ng ch√≠nh"
            ],
            "answer": "D. L∆∞u tr·ªØ theo h√†ng ch√≠nh",
            "explanation": "Th·ª© t·ª± h√†ng ch√≠nh l∆∞u tr·ªØ m·ªôt m·∫£ng 2D b·∫±ng c√°ch l∆∞u tr·ªØ t·∫•t c·∫£ c√°c ph·∫ßn t·ª≠ c·ªßa h√†ng ƒë·∫ßu ti√™n li√™n ti·∫øp, ti·∫øp theo l√† t·∫•t c·∫£ c√°c ph·∫ßn t·ª≠ c·ªßa h√†ng th·ª© hai, v√† c·ª© th·∫ø. ƒê√¢y l√† ti√™u chu·∫©n trong c√°c ng√¥n ng·ªØ nh∆∞ C, C++, v√† Python. **M·∫πo ghi nh·ªõ: C√°c ng√¥n ng·ªØ gi·ªëng C l∆∞u tr·ªØ m·∫£ng theo t·ª´ng h√†ng.**"
        }
    },
    {
        "id": 241,
        "category": "Chapter 9: Data Structures (C·∫•u tr√∫c d·ªØ li·ªáu)",
        "en": {
            "question": "The _______ of each node includes one of its children and all descendents of that child.",
            "options": [
                "A. Left tree",
                "B. Binary tree",
                "C. Subtree",
                "D. Right tree"
            ],
            "answer": "C. Subtree",
            "explanation": "A subtree of a node in a tree is a tree consisting of a child of that node and all of its descendants. **Key takeaway: A child and all its descendants = Subtree.**"
        },
        "vi": {
            "question": "_______ c·ªßa m·ªói n√∫t bao g·ªìm m·ªôt trong c√°c con c·ªßa n√≥ v√† t·∫•t c·∫£ c√°c h·∫≠u du·ªá c·ªßa ƒë·ª©a con ƒë√≥.",
            "options": [
                "A. C√¢y con tr√°i",
                "B. C√¢y nh·ªã ph√¢n",
                "C. C√¢y con",
                "D. C√¢y con ph·∫£i"
            ],
            "answer": "C. C√¢y con",
            "explanation": "M·ªôt c√¢y con c·ªßa m·ªôt n√∫t trong m·ªôt c√¢y l√† m·ªôt c√¢y bao g·ªìm m·ªôt ƒë·ª©a con c·ªßa n√∫t ƒë√≥ v√† t·∫•t c·∫£ c√°c h·∫≠u du·ªá c·ªßa n√≥. **M·∫πo ghi nh·ªõ: M·ªôt ƒë·ª©a con v√† t·∫•t c·∫£ h·∫≠u du·ªá c·ªßa n√≥ = C√¢y con.**"
        }
    },
    {
        "id": 242,
        "category": "Chapter 9: Data Structures (C·∫•u tr√∫c d·ªØ li·ªáu)",
        "en": {
            "question": "An empty linked list consists of _______",
            "options": [
                "A. A node",
                "B. Two nodes",
                "C. Data and a link",
                "D. A null head pointer"
            ],
            "answer": "D. A null head pointer",
            "explanation": "An empty linked list is represented by its head pointer having a null value, indicating that it does not point to any nodes. **Key takeaway: Empty list = Head pointer is NULL.**"
        },
        "vi": {
            "question": "M·ªôt danh s√°ch li√™n k·∫øt r·ªóng bao g·ªìm _______",
            "options": [
                "A. M·ªôt n√∫t",
                "B. Hai n√∫t",
                "C. D·ªØ li·ªáu v√† m·ªôt li√™n k·∫øt",
                "D. M·ªôt con tr·ªè ƒë·∫ßu null"
            ],
            "answer": "D. M·ªôt con tr·ªè ƒë·∫ßu null",
            "explanation": "M·ªôt danh s√°ch li√™n k·∫øt r·ªóng ƒë∆∞·ª£c bi·ªÉu di·ªÖn b·∫±ng con tr·ªè ƒë·∫ßu c·ªßa n√≥ c√≥ gi√° tr·ªã null, cho bi·∫øt r·∫±ng n√≥ kh√¥ng tr·ªè ƒë·∫øn b·∫•t k·ª≥ n√∫t n√†o. **M·∫πo ghi nh·ªõ: Danh s√°ch r·ªóng = Con tr·ªè ƒë·∫ßu l√† NULL.**"
        }
    },
    {
        "id": 243,
        "category": "Chapter 9: Data Structures (C·∫•u tr√∫c d·ªØ li·ªáu)",
        "en": {
            "question": "The name of a linked list is the name of the head pointer that points to the _______ of the list.",
            "options": [
                "A. First node",
                "B. Second node",
                "C. Null node",
                "D. Last node"
            ],
            "answer": "A. First node",
            "explanation": "This is a repeated concept. The head pointer is the sole entry point to the linked list, so its value is the address of the first node. **Key takeaway: List pointer = First node.**"
        },
        "vi": {
            "question": "T√™n c·ªßa m·ªôt danh s√°ch li√™n k·∫øt l√† t√™n c·ªßa con tr·ªè ƒë·∫ßu tr·ªè ƒë·∫øn _______ c·ªßa danh s√°ch.",
            "options": [
                "A. N√∫t ƒë·∫ßu ti√™n",
                "B. N√∫t th·ª© hai",
                "C. N√∫t null",
                "D. N√∫t cu·ªëi c√πng"
            ],
            "answer": "A. N√∫t ƒë·∫ßu ti√™n",
            "explanation": "ƒê√¢y l√† m·ªôt kh√°i ni·ªám l·∫∑p l·∫°i. Con tr·ªè ƒë·∫ßu l√† ƒëi·ªÉm v√†o duy nh·∫•t c·ªßa danh s√°ch li√™n k·∫øt, v√¨ v·∫≠y gi√° tr·ªã c·ªßa n√≥ l√† ƒë·ªãa ch·ªâ c·ªßa n√∫t ƒë·∫ßu ti√™n. **M·∫πo ghi nh·ªõ: Con tr·ªè danh s√°ch = N√∫t ƒë·∫ßu ti√™n.**"
        }
    },
    {
        "id": 244,
        "category": "Chapter 9: Data Structures (C·∫•u tr√∫c d·ªØ li·ªáu)",
        "en": {
            "question": "The Stack operation returns a/an _______",
            "options": [
                "A. Full stack",
                "B. Empty stack",
                "C. Check status of stack",
                "D. All of the others"
            ],
            "answer": "C. Check status of stack",
            "explanation": "This question is ambiguously worded. Operations like `isEmpty()` or `isFull()` would check the status of the stack. `push()` and `pop()` modify the stack. The most general answer covering status checks is C. **Key takeaway: Stack operations can check status (e.g., isEmpty).**"
        },
        "vi": {
            "question": "Thao t√°c NgƒÉn x·∫øp (Stack) tr·∫£ v·ªÅ m·ªôt _______",
            "options": [
                "A. NgƒÉn x·∫øp ƒë·∫ßy",
                "B. NgƒÉn x·∫øp r·ªóng",
                "C. Ki·ªÉm tra tr·∫°ng th√°i c·ªßa ngƒÉn x·∫øp",
                "D. T·∫•t c·∫£ c√°c ph∆∞∆°ng √°n kh√°c"
            ],
            "answer": "C. Ki·ªÉm tra tr·∫°ng th√°i c·ªßa ngƒÉn x·∫øp",
            "explanation": "C√¢u h·ªèi n√†y ƒë∆∞·ª£c di·ªÖn ƒë·∫°t m·ªôt c√°ch m∆° h·ªì. C√°c thao t√°c nh∆∞ `isEmpty()` ho·∫∑c `isFull()` s·∫Ω ki·ªÉm tra tr·∫°ng th√°i c·ªßa ngƒÉn x·∫øp. `push()` v√† `pop()` s·ª≠a ƒë·ªïi ngƒÉn x·∫øp. C√¢u tr·∫£ l·ªùi chung nh·∫•t bao g·ªìm vi·ªác ki·ªÉm tra tr·∫°ng th√°i l√† C. **M·∫πo ghi nh·ªõ: Thao t√°c ngƒÉn x·∫øp c√≥ th·ªÉ ki·ªÉm tra tr·∫°ng th√°i (v√≠ d·ª•: isEmpty).**"
        }
    },
    {
        "id": 245,
        "category": "Chapter 9: Data Structures (C·∫•u tr√∫c d·ªØ li·ªáu)",
        "en": {
            "question": "The push operation _______ of the stack.",
            "options": [
                "A. Deletes an item from the top",
                "B. Deletes an item from the bottom",
                "C. Inserts an item at the top",
                "D. Inserts an item at the bottom"
            ],
            "answer": "C. Inserts an item at the top",
            "explanation": "A stack is a LIFO (Last-In, First-Out) structure. The 'push' operation adds a new item to the top of the stack. **Key takeaway: Push = Add to top.**"
        },
        "vi": {
            "question": "Thao t√°c push _______ c·ªßa ngƒÉn x·∫øp.",
            "options": [
                "A. X√≥a m·ªôt m·ª•c t·ª´ ƒë·ªânh",
                "B. X√≥a m·ªôt m·ª•c t·ª´ ƒë√°y",
                "C. Ch√®n m·ªôt m·ª•c v√†o ƒë·ªânh",
                "D. Ch√®n m·ªôt m·ª•c v√†o ƒë√°y"
            ],
            "answer": "C. Ch√®n m·ªôt m·ª•c v√†o ƒë·ªânh",
            "explanation": "NgƒÉn x·∫øp l√† m·ªôt c·∫•u tr√∫c LIFO (V√†o sau, Ra tr∆∞·ªõc). Thao t√°c 'push' th√™m m·ªôt m·ª•c m·ªõi v√†o ƒë·ªânh c·ªßa ngƒÉn x·∫øp. **M·∫πo ghi nh·ªõ: Push = Th√™m v√†o ƒë·ªânh.**"
        }
    },
    {
        "id": 246,
        "category": "Chapter 9: Data Structures (C·∫•u tr√∫c d·ªØ li·ªáu)",
        "en": {
            "question": "Each element in a record is called _______",
            "options": [
                "A. A variable",
                "B. An index",
                "C. A field",
                "D. A node"
            ],
            "answer": "C. A field",
            "explanation": "A record (or struct in C-like languages) is a collection of related data items. Each individual data item within the record is called a field (or member). **Key takeaway: Element of a record = Field.**"
        },
        "vi": {
            "question": "M·ªói ph·∫ßn t·ª≠ trong m·ªôt b·∫£n ghi ƒë∆∞·ª£c g·ªçi l√† _______",
            "options": [
                "A. M·ªôt bi·∫øn",
                "B. M·ªôt ch·ªâ s·ªë",
                "C. M·ªôt tr∆∞·ªùng",
                "D. M·ªôt n√∫t"
            ],
            "answer": "C. M·ªôt tr∆∞·ªùng",
            "explanation": "M·ªôt b·∫£n ghi (ho·∫∑c struct trong c√°c ng√¥n ng·ªØ gi·ªëng C) l√† m·ªôt t·∫≠p h·ª£p c√°c m·ª•c d·ªØ li·ªáu li√™n quan. M·ªói m·ª•c d·ªØ li·ªáu ri√™ng l·∫ª trong b·∫£n ghi ƒë∆∞·ª£c g·ªçi l√† m·ªôt tr∆∞·ªùng (ho·∫∑c th√†nh vi√™n). **M·∫πo ghi nh·ªõ: Ph·∫ßn t·ª≠ c·ªßa m·ªôt b·∫£n ghi = Tr∆∞·ªùng.**"
        }
    },
    {
        "id": 247,
        "category": "Chapter 9: Data Structures (C·∫•u tr√∫c d·ªØ li·ªáu)",
        "en": {
            "question": "The dequeue operation _______ the item at the _______ of the queue.",
            "options": [
                "A. delete/front",
                "B. delete/end",
                "C. inserts/front",
                "D. insert/rear"
            ],
            "answer": "A. delete/front",
            "explanation": "This is a repeated concept. Dequeue removes an item from the front of the queue, following the FIFO principle. **Key takeaway: Dequeue = Delete from front.**"
        },
        "vi": {
            "question": "Thao t√°c dequeue _______ m·ª•c ·ªü _______ c·ªßa h√†ng ƒë·ª£i.",
            "options": [
                "A. x√≥a/ƒë·∫ßu",
                "B. x√≥a/cu·ªëi",
                "C. ch√®n/ƒë·∫ßu",
                "D. ch√®n/cu·ªëi"
            ],
            "answer": "A. x√≥a/ƒë·∫ßu",
            "explanation": "ƒê√¢y l√† m·ªôt kh√°i ni·ªám l·∫∑p l·∫°i. Dequeue x√≥a m·ªôt m·ª•c kh·ªèi ƒë·∫ßu h√†ng ƒë·ª£i, tu√¢n theo nguy√™n t·∫Øc FIFO. **M·∫πo ghi nh·ªõ: Dequeue = X√≥a t·ª´ ƒë·∫ßu.**"
        }
    },
    {
        "id": 248,
        "category": "Chapter 9: Data Structures (C·∫•u tr√∫c d·ªØ li·ªáu)",
        "en": {
            "question": "In inorder traversal of a binary tree, the root is processed _______",
            "options": [
                "A. First",
                "B. Second",
                "C. Last",
                "D. Two times"
            ],
            "answer": "B. Second",
            "explanation": "The name 'inorder' means the root is processed 'in' between its children. The traversal order is: Left subtree, then the Root, then the Right subtree. This makes the root the second of the three main components to be processed. **Key takeaway: Inorder = Left, Root, Right.**"
        },
        "vi": {
            "question": "Trong ph√©p duy·ªát trung th·ª© t·ª± (inorder) c·ªßa m·ªôt c√¢y nh·ªã ph√¢n, g·ªëc ƒë∆∞·ª£c x·ª≠ l√Ω _______",
            "options": [
                "A. ƒê·∫ßu ti√™n",
                "B. Th·ª© hai",
                "C. Cu·ªëi c√πng",
                "D. Hai l·∫ßn"
            ],
            "answer": "B. Th·ª© hai",
            "explanation": "T√™n 'inorder' (trung th·ª© t·ª±) c√≥ nghƒ©a l√† g·ªëc ƒë∆∞·ª£c x·ª≠ l√Ω '·ªü gi·ªØa' c√°c con c·ªßa n√≥. Th·ª© t·ª± duy·ªát l√†: C√¢y con tr√°i, sau ƒë√≥ ƒë·∫øn G·ªëc, r·ªìi ƒë·∫øn C√¢y con ph·∫£i. ƒêi·ªÅu n√†y l√†m cho g·ªëc tr·ªü th√†nh th√†nh ph·∫ßn th·ª© hai trong ba th√†nh ph·∫ßn ch√≠nh ƒë∆∞·ª£c x·ª≠ l√Ω. **M·∫πo ghi nh·ªõ: Trung th·ª© t·ª± = Tr√°i, G·ªëc, Ph·∫£i.**"
        }
    },
{
        "id": 249,
        "category": "Chapter 9: Data Structures (C·∫•u tr√∫c d·ªØ li·ªáu)",
        "en": {
            "question": "In a Linked List, what identifies the first element?",
            "options": [
                "A. An index of 0.",
                "B. A pointer variable, which is also the name of the list.",
                "C. The address of the last element.",
                "D. The number of elements in the list."
            ],
            "answer": "B. A pointer variable, which is also the name of the list.",
            "explanation": "A linked list is accessed via its head pointer. This pointer holds the memory address of the first node and is the sole entry point to traverse the entire list. **Key takeaway: Head Pointer = The starting point of a linked list.**"
        },
        "vi": {
            "question": "Trong m·ªôt danh s√°ch li√™n k·∫øt (Linked List), ph·∫ßn t·ª≠ ƒë·∫ßu ti√™n ƒë∆∞·ª£c x√°c ƒë·ªãnh b·ªüi c√°i g√¨?",
            "options": [
                "A. M·ªôt ch·ªâ s·ªë (index) b·∫±ng 0.",
                "B. M·ªôt bi·∫øn con tr·ªè (a pointer variable), c≈©ng l√† t√™n c·ªßa danh s√°ch.",
                "C. ƒê·ªãa ch·ªâ c·ªßa ph·∫ßn t·ª≠ cu·ªëi c√πng.",
                "D. S·ªë l∆∞·ª£ng c√°c ph·∫ßn t·ª≠ trong danh s√°ch."
            ],
            "answer": "B. M·ªôt bi·∫øn con tr·ªè (a pointer variable), c≈©ng l√† t√™n c·ªßa danh s√°ch.",
            "explanation": "T√†i li·ªáu (Ch 9, M·ª•c 3.1) n√™u: 'The first element is identified by a pointer variable (the list's name)'. Con tr·ªè ƒë·∫ßu n√†y l√† c·ªïng v√†o duy nh·∫•t c·ªßa to√†n b·ªô danh s√°ch. **M·∫πo ghi nh·ªõ: Con tr·ªè ƒë·∫ßu (Head Pointer) = ƒêi·ªÉm b·∫Øt ƒë·∫ßu c·ªßa danh s√°ch li√™n k·∫øt.**"
        }    },
   {
        "id": 250,
        "category": "Chapter 10: File Structure (C·∫•u tr√∫c t·ªáp)",
        "en": {
            "question": "Which file type stores data in the computer's internal format (integers, floats, media) and is generally not human-readable?",
            "options": [
                "A. Text File.",
                "B. Binary File.",
                "C. Sequential File.",
                "D. Indexed File."
            ],
            "answer": "B. Binary File.",
            "explanation": "Binary files store data as raw sequences of bytes, exactly as they are represented in memory. This is efficient for the computer but requires a specific program to decode and understand the data. **Key takeaway: Binary File = Raw computer data, not human-readable.**"
        },
        "vi": {
            "question": "T·ªáp tin n√†o l∆∞u tr·ªØ d·ªØ li·ªáu theo ƒë·ªãnh d·∫°ng n·ªôi b·ªô c·ªßa m√°y t√≠nh (s·ªë nguy√™n, s·ªë th·ª±c, media) v√† th∆∞·ªùng kh√¥ng th·ªÉ ƒë·ªçc ƒë∆∞·ª£c tr·ª±c ti·∫øp b·ªüi con ng∆∞·ªùi?",
            "options": [
                "A. Text File (T·ªáp vƒÉn b·∫£n).",
                "B. Binary File (T·ªáp nh·ªã ph√¢n).",
                "C. Sequential File (T·ªáp tu·∫ßn t·ª±).",
                "D. Indexed File (T·ªáp ch·ªâ m·ª•c)."
            ],
            "answer": "B. Binary File (T·ªáp nh·ªã ph√¢n).",
            "explanation": "T√†i li·ªáu (Ch 10, M·ª•c 2.3) m√¥ t·∫£ t·ªáp nh·ªã ph√¢n 'Store data in the computer's internal format' v√† 'Not human-readable without proper decoding'. **M·∫πo ghi nh·ªõ: Binary File = D·ªØ li·ªáu th√¥ c·ªßa m√°y t√≠nh, ng∆∞·ªùi kh√¥ng ƒë·ªçc tr·ª±c ti·∫øp ƒë∆∞·ª£c.**"
        }
    },
    {
        "id": 251,
        "category": "Chapter 11: Databases (C∆° s·ªü d·ªØ li·ªáu)",
        "en": {
            "question": "_______ is the process by which a given set of relations are transformed to a new set of relations with a more solid structure.",
            "options": [
                "A. Relational database",
                "B. Database system",
                "C. Atomic operations",
                "D. Normalization"
            ],
            "answer": "D. Normalization",
            "explanation": "Normalization is the process of organizing columns and tables in a relational database to minimize data redundancy and improve data integrity. It involves dividing larger tables into smaller, well-structured tables. **Key takeaway: Process to reduce redundancy = Normalization.**"
        },
        "vi": {
            "question": "_______ l√† qu√° tr√¨nh bi·∫øn ƒë·ªïi m·ªôt t·∫≠p h·ª£p c√°c quan h·ªá ƒë√£ cho th√†nh m·ªôt t·∫≠p h·ª£p c√°c quan h·ªá m·ªõi c√≥ c·∫•u tr√∫c v·ªØng ch·∫Øc h∆°n.",
            "options": [
                "A. C∆° s·ªü d·ªØ li·ªáu quan h·ªá",
                "B. H·ªá th·ªëng c∆° s·ªü d·ªØ li·ªáu",
                "C. C√°c ho·∫°t ƒë·ªông nguy√™n t·ª≠",
                "D. Chu·∫©n h√≥a"
            ],
            "answer": "D. Chu·∫©n h√≥a",
            "explanation": "Chu·∫©n h√≥a l√† qu√° tr√¨nh t·ªï ch·ª©c c√°c c·ªôt v√† b·∫£ng trong m·ªôt c∆° s·ªü d·ªØ li·ªáu quan h·ªá ƒë·ªÉ gi·∫£m thi·ªÉu s·ª± d∆∞ th·ª´a d·ªØ li·ªáu v√† c·∫£i thi·ªán t√≠nh to√†n v·∫πn d·ªØ li·ªáu. N√≥ bao g·ªìm vi·ªác chia c√°c b·∫£ng l·ªõn h∆°n th√†nh c√°c b·∫£ng nh·ªè h∆°n, c√≥ c·∫•u tr√∫c t·ªët. **M·∫πo ghi nh·ªõ: Qu√° tr√¨nh gi·∫£m d∆∞ th·ª´a = Chu·∫©n h√≥a.**"
        }
    },
    {
        "id": 252,
        "category": "Chapter 11: Databases (C∆° s·ªü d·ªØ li·ªáu)",
        "en": {
            "question": "A _______ is a collection of related logically coherent data used by the application programs in an organization.",
            "options": [
                "A. Database",
                "B. File",
                "C. Directory",
                "D. Flat-file"
            ],
            "answer": "A. Database",
            "explanation": "This is the fundamental definition of a database: a structured, organized collection of logically related data. **Key takeaway: Organized collection of related data = Database.**"
        },
        "vi": {
            "question": "M·ªôt _______ l√† m·ªôt t·∫≠p h·ª£p d·ªØ li·ªáu c√≥ li√™n quan, m·∫°ch l·∫°c v·ªÅ m·∫∑t logic ƒë∆∞·ª£c s·ª≠ d·ª•ng b·ªüi c√°c ch∆∞∆°ng tr√¨nh ·ª©ng d·ª•ng trong m·ªôt t·ªï ch·ª©c.",
            "options": [
                "A. C∆° s·ªü d·ªØ li·ªáu",
                "B. T·ªáp",
                "C. Th∆∞ m·ª•c",
                "D. T·ªáp ph·∫≥ng"
            ],
            "answer": "A. C∆° s·ªü d·ªØ li·ªáu",
            "explanation": "ƒê√¢y l√† ƒë·ªãnh nghƒ©a c∆° b·∫£n c·ªßa m·ªôt c∆° s·ªü d·ªØ li·ªáu: m·ªôt t·∫≠p h·ª£p d·ªØ li·ªáu c√≥ c·∫•u tr√∫c, ƒë∆∞·ª£c t·ªï ch·ª©c v√† c√≥ li√™n quan logic v·ªõi nhau. **M·∫πo ghi nh·ªõ: T·∫≠p h·ª£p d·ªØ li·ªáu c√≥ t·ªï ch·ª©c, li√™n quan = C∆° s·ªü d·ªØ li·ªáu.**"
        }
    },
    {
        "id": 253,
        "category": "Chapter 11: Databases (C∆° s·ªü d·ªØ li·ªáu)",
        "en": {
            "question": "The term users in a DBMS has a broad meaning. We can divide users into:",
            "options": [
                "A. End users and database asministrators",
                "B. End users and normal users",
                "C. Application programs and end users",
                "D. Application programs and database adminitrators"
            ],
            "answer": "C. Application programs and end users",
            "explanation": "In a DBMS context, 'users' are not just people. End users interact with the database (often through an application), but the application programs themselves are also considered 'users' of the DBMS as they make requests to it. **Key takeaway: DBMS users = People + Programs.**"
        },
        "vi": {
            "question": "Thu·∫≠t ng·ªØ ng∆∞·ªùi d√πng trong m·ªôt DBMS c√≥ m·ªôt √Ω nghƒ©a r·ªông. Ch√∫ng ta c√≥ th·ªÉ chia ng∆∞·ªùi d√πng th√†nh:",
            "options": [
                "A. Ng∆∞·ªùi d√πng cu·ªëi v√† qu·∫£n tr·ªã vi√™n c∆° s·ªü d·ªØ li·ªáu",
                "B. Ng∆∞·ªùi d√πng cu·ªëi v√† ng∆∞·ªùi d√πng th√¥ng th∆∞·ªùng",
                "C. Ch∆∞∆°ng tr√¨nh ·ª©ng d·ª•ng v√† ng∆∞·ªùi d√πng cu·ªëi",
                "D. Ch∆∞∆°ng tr√¨nh ·ª©ng d·ª•ng v√† qu·∫£n tr·ªã vi√™n c∆° s·ªü d·ªØ li·ªáu"
            ],
            "answer": "C. Ch∆∞∆°ng tr√¨nh ·ª©ng d·ª•ng v√† ng∆∞·ªùi d√πng cu·ªëi",
            "explanation": "Trong b·ªëi c·∫£nh DBMS, 'ng∆∞·ªùi d√πng' kh√¥ng ch·ªâ l√† con ng∆∞·ªùi. Ng∆∞·ªùi d√πng cu·ªëi t∆∞∆°ng t√°c v·ªõi c∆° s·ªü d·ªØ li·ªáu (th∆∞·ªùng th√¥ng qua m·ªôt ·ª©ng d·ª•ng), nh∆∞ng b·∫£n th√¢n c√°c ch∆∞∆°ng tr√¨nh ·ª©ng d·ª•ng c≈©ng ƒë∆∞·ª£c coi l√† 'ng∆∞·ªùi d√πng' c·ªßa DBMS v√¨ ch√∫ng g·ª≠i y√™u c·∫ßu ƒë·∫øn n√≥. **M·∫πo ghi nh·ªõ: Ng∆∞·ªùi d√πng DBMS = Con ng∆∞·ªùi + Ch∆∞∆°ng tr√¨nh.**"
        }
    },
    {
        "id": 254,
        "category": "Chapter 11: Databases (C∆° s·ªü d·ªØ li·ªáu)",
        "en": {
            "question": "Each column in a relation is called _______",
            "options": [
                "A. An attribute",
                "B. A tuple",
                "C. A union",
                "D. An attitude"
            ],
            "answer": "A. An attribute",
            "explanation": "In the relational database model, a table is called a 'relation', a row is a 'tuple', and a column is an 'attribute'. **Key takeaway: Column = Attribute.**"
        },
        "vi": {
            "question": "M·ªói c·ªôt trong m·ªôt quan h·ªá ƒë∆∞·ª£c g·ªçi l√† _______",
            "options": [
                "A. M·ªôt thu·ªôc t√≠nh",
                "B. M·ªôt b·ªô (tuple)",
                "C. M·ªôt ph√©p h·ª£p",
                "D. M·ªôt th√°i ƒë·ªô"
            ],
            "answer": "A. M·ªôt thu·ªôc t√≠nh",
            "explanation": "Trong m√¥ h√¨nh c∆° s·ªü d·ªØ li·ªáu quan h·ªá, m·ªôt b·∫£ng ƒë∆∞·ª£c g·ªçi l√† 'quan h·ªá', m·ªôt h√†ng l√† 'b·ªô' (tuple), v√† m·ªôt c·ªôt l√† 'thu·ªôc t√≠nh'. **M·∫πo ghi nh·ªõ: C·ªôt = Thu·ªôc t√≠nh.**"
        }
    },
    {
        "id": 255,
        "category": "Chapter 11: Databases (C∆° s·ªü d·ªØ li·ªáu)",
        "en": {
            "question": "Each row in a relation is called _______",
            "options": [
                "A. An attribute",
                "B. A tuple",
                "C. A union",
                "D. An attitude"
            ],
            "answer": "B. A tuple",
            "explanation": "In the relational database model, a table is called a 'relation', a row is a 'tuple', and a column is an 'attribute'. **Key takeaway: Row = Tuple.**"
        },
        "vi": {
            "question": "M·ªói h√†ng trong m·ªôt quan h·ªá ƒë∆∞·ª£c g·ªçi l√† _______",
            "options": [
                "A. M·ªôt thu·ªôc t√≠nh",
                "B. M·ªôt b·ªô (tuple)",
                "C. M·ªôt ph√©p h·ª£p",
                "D. M·ªôt th√°i ƒë·ªô"
            ],
            "answer": "B. M·ªôt b·ªô (tuple)",
            "explanation": "Trong m√¥ h√¨nh c∆° s·ªü d·ªØ li·ªáu quan h·ªá, m·ªôt b·∫£ng ƒë∆∞·ª£c g·ªçi l√† 'quan h·ªá', m·ªôt h√†ng l√† 'b·ªô' (tuple), v√† m·ªôt c·ªôt l√† 'thu·ªôc t√≠nh'. **M·∫πo ghi nh·ªõ: H√†ng = B·ªô (Tuple).**"
        }
    },
    {
        "id": 256,
        "category": "Chapter 11: Databases (C∆° s·ªü d·ªØ li·ªáu)",
        "en": {
            "question": "In a three-level DBMS architecture, the _______ level interacts directly with the users.",
            "options": [
                "A. External",
                "B. Conceptual",
                "C. Internal",
                "D. Physical"
            ],
            "answer": "A. External",
            "explanation": "The three-level architecture consists of: Internal (physical storage), Conceptual (logical structure of the whole database), and External (user views). The External level provides customized views of the data for different users or applications. **Key takeaway: User view = External level.**"
        },
        "vi": {
            "question": "Trong ki·∫øn tr√∫c DBMS ba t·∫ßng, t·∫ßng _______ t∆∞∆°ng t√°c tr·ª±c ti·∫øp v·ªõi ng∆∞·ªùi d√πng.",
            "options": [
                "A. Ngo√†i",
                "B. Kh√°i ni·ªám",
                "C. Trong",
                "D. V·∫≠t l√Ω"
            ],
            "answer": "A. Ngo√†i",
            "explanation": "Ki·∫øn tr√∫c ba t·∫ßng bao g·ªìm: T·∫ßng trong (l∆∞u tr·ªØ v·∫≠t l√Ω), T·∫ßng kh√°i ni·ªám (c·∫•u tr√∫c logic c·ªßa to√†n b·ªô c∆° s·ªü d·ªØ li·ªáu), v√† T·∫ßng ngo√†i (khung nh√¨n c·ªßa ng∆∞·ªùi d√πng). T·∫ßng ngo√†i cung c·∫•p c√°c khung nh√¨n t√πy ch·ªânh c·ªßa d·ªØ li·ªáu cho nh·ªØng ng∆∞·ªùi d√πng ho·∫∑c ·ª©ng d·ª•ng kh√°c nhau. **M·∫πo ghi nh·ªõ: Khung nh√¨n ng∆∞·ªùi d√πng = T·∫ßng ngo√†i.**"
        }
    },
    {
        "id": 257,
        "category": "Chapter 11: Databases (C∆° s·ªü d·ªØ li·ªáu)",
        "en": {
            "question": "In a three-level DBMS architecture, the layer that interacts directly with the hardware is the _______ level.",
            "options": [
                "A. External",
                "B. Conceptual",
                "C. Internal",
                "D. Physical"
            ],
            "answer": "C. Internal",
            "explanation": "The Internal (or Physical) level is the lowest level, describing the physical storage structure of the database. It deals with how the data is actually stored on disks. **Key takeaway: Hardware interaction = Internal/Physical level.**"
        },
        "vi": {
            "question": "Trong ki·∫øn tr√∫c DBMS ba t·∫ßng, t·∫ßng t∆∞∆°ng t√°c tr·ª±c ti·∫øp v·ªõi ph·∫ßn c·ª©ng l√† t·∫ßng _______.",
            "options": [
                "A. Ngo√†i",
                "B. Kh√°i ni·ªám",
                "C. Trong",
                "D. V·∫≠t l√Ω"
            ],
            "answer": "C. Trong",
            "explanation": "T·∫ßng Trong (ho·∫∑c V·∫≠t l√Ω) l√† t·∫ßng th·∫•p nh·∫•t, m√¥ t·∫£ c·∫•u tr√∫c l∆∞u tr·ªØ v·∫≠t l√Ω c·ªßa c∆° s·ªü d·ªØ li·ªáu. N√≥ x·ª≠ l√Ω c√°ch d·ªØ li·ªáu ƒë∆∞·ª£c l∆∞u tr·ªØ th·ª±c t·∫ø tr√™n ƒëƒ©a. **M·∫πo ghi nh·ªõ: T∆∞∆°ng t√°c ph·∫ßn c·ª©ng = T·∫ßng trong/v·∫≠t l√Ω.**"
        }
    },
    {
        "id": 258,
        "category": "Chapter 11: Databases (C∆° s·ªü d·ªØ li·ªáu)",
        "en": {
            "question": "The _______ level of a three-level DBMS architecture defines the logical view of the data.",
            "options": [
                "A. External",
                "B. Conceptual",
                "C. Internal",
                "D. Physical"
            ],
            "answer": "B. Conceptual",
            "explanation": "The Conceptual level provides a unified, logical view of the entire database for the database administrator. It hides the physical storage details and describes entities, relationships, and constraints. **Key takeaway: Overall logical view = Conceptual level.**"
        },
        "vi": {
            "question": "T·∫ßng _______ c·ªßa ki·∫øn tr√∫c DBMS ba t·∫ßng ƒë·ªãnh nghƒ©a khung nh√¨n logic c·ªßa d·ªØ li·ªáu.",
            "options": [
                "A. Ngo√†i",
                "B. Kh√°i ni·ªám",
                "C. Trong",
                "D. V·∫≠t l√Ω"
            ],
            "answer": "B. Kh√°i ni·ªám",
            "explanation": "T·∫ßng Kh√°i ni·ªám cung c·∫•p m·ªôt khung nh√¨n logic, th·ªëng nh·∫•t c·ªßa to√†n b·ªô c∆° s·ªü d·ªØ li·ªáu cho qu·∫£n tr·ªã vi√™n c∆° s·ªü d·ªØ li·ªáu. N√≥ che gi·∫•u c√°c chi ti·∫øt l∆∞u tr·ªØ v·∫≠t l√Ω v√† m√¥ t·∫£ c√°c th·ª±c th·ªÉ, m·ªëi quan h·ªá v√† r√†ng bu·ªôc. **M·∫πo ghi nh·ªõ: Khung nh√¨n logic t·ªïng th·ªÉ = T·∫ßng kh√°i ni·ªám.**"
        }
    },
    {
        "id": 259,
        "category": "Chapter 11: Databases (C∆° s·ªü d·ªØ li·ªáu)",
        "en": {
            "question": "A binary operator is applied to _______ relations (s) and creates an output of _______ relation(s).",
            "options": [
                "A. One, one",
                "B. One, two",
                "C. Two, one",
                "D. Two, two"
            ],
            "answer": "C. Two, one",
            "explanation": "A binary operator in relational algebra (like UNION, INTERSECT, JOIN) takes two relations (tables) as input and produces a single new relation as output. **Key takeaway: Binary operator = 2 inputs, 1 output.**"
        },
        "vi": {
            "question": "M·ªôt to√°n t·ª≠ nh·ªã ph√¢n ƒë∆∞·ª£c √°p d·ª•ng cho _______ quan h·ªá v√† t·∫°o ra m·ªôt ƒë·∫ßu ra c·ªßa _______ quan h·ªá.",
            "options": [
                "A. M·ªôt, m·ªôt",
                "B. M·ªôt, hai",
                "C. Hai, m·ªôt",
                "D. Hai, hai"
            ],
            "answer": "C. Hai, m·ªôt",
            "explanation": "M·ªôt to√°n t·ª≠ nh·ªã ph√¢n trong ƒë·∫°i s·ªë quan h·ªá (nh∆∞ UNION, INTERSECT, JOIN) nh·∫≠n hai quan h·ªá (b·∫£ng) l√†m ƒë·∫ßu v√†o v√† t·∫°o ra m·ªôt quan h·ªá m·ªõi duy nh·∫•t l√†m ƒë·∫ßu ra. **M·∫πo ghi nh·ªõ: To√°n t·ª≠ nh·ªã ph√¢n = 2 ƒë·∫ßu v√†o, 1 ƒë·∫ßu ra.**"
        }
    },
    {
        "id": 260,
        "category": "Chapter 11: Databases (C∆° s·ªü d·ªØ li·ªáu)",
        "en": {
            "question": "The union database operation is taking two relations and creating a new relation. What is a result of this operation?",
            "options": [
                "A. Neither the first relation nor the second.",
                "B. Both of the first relation and the second.",
                "C. The first relation but not the second.",
                "D. The second but not the first."
            ],
            "answer": "B. Both of the first relation and the second.",
            "explanation": "The UNION operation combines all rows from two tables, removing any duplicate rows. The result contains all unique rows from both the first and the second relation. **Key takeaway: UNION = All rows from both tables (no duplicates).**"
        },
        "vi": {
            "question": "Ph√©p to√°n h·ª£p (union) trong c∆° s·ªü d·ªØ li·ªáu l·∫•y hai quan h·ªá v√† t·∫°o ra m·ªôt quan h·ªá m·ªõi. K·∫øt qu·∫£ c·ªßa ph√©p to√°n n√†y l√† g√¨?",
            "options": [
                "A. Kh√¥ng ph·∫£i quan h·ªá th·ª© nh·∫•t c≈©ng kh√¥ng ph·∫£i th·ª© hai.",
                "B. C·∫£ quan h·ªá th·ª© nh·∫•t v√† th·ª© hai.",
                "C. Quan h·ªá th·ª© nh·∫•t nh∆∞ng kh√¥ng ph·∫£i th·ª© hai.",
                "D. Quan h·ªá th·ª© hai nh∆∞ng kh√¥ng ph·∫£i th·ª© nh·∫•t."
            ],
            "answer": "B. C·∫£ quan h·ªá th·ª© nh·∫•t v√† th·ª© hai.",
            "explanation": "Ph√©p to√°n UNION k·∫øt h·ª£p t·∫•t c·∫£ c√°c h√†ng t·ª´ hai b·∫£ng, lo·∫°i b·ªè b·∫•t k·ª≥ h√†ng tr√πng l·∫∑p n√†o. K·∫øt qu·∫£ ch·ª©a t·∫•t c·∫£ c√°c h√†ng duy nh·∫•t t·ª´ c·∫£ quan h·ªá th·ª© nh·∫•t v√† th·ª© hai. **M·∫πo ghi nh·ªõ: UNION = T·∫•t c·∫£ c√°c h√†ng t·ª´ c·∫£ hai b·∫£ng (kh√¥ng tr√πng l·∫∑p).**"
        }
    },
    {
        "id": 261,
        "category": "Chapter 11: Databases (C∆° s·ªü d·ªØ li·ªáu)",
        "en": {
            "question": "What is the result of difference database operation from 2 relation tables?",
            "options": [
                "A. Neither the first relation nor the second.",
                "B. Both of the first relation and the second.",
                "C. The first relation but not the second.",
                "D. The second but not the first"
            ],
            "answer": "C. The first relation but not the second.",
            "explanation": "The DIFFERENCE operation (Table A - Table B) returns all rows that are in Table A but are NOT in Table B. **Key takeaway: A - B = Rows in A that are not in B.**"
        },
        "vi": {
            "question": "K·∫øt qu·∫£ c·ªßa ph√©p to√°n hi·ªáu (difference) trong c∆° s·ªü d·ªØ li·ªáu t·ª´ 2 b·∫£ng quan h·ªá l√† g√¨?",
            "options": [
                "A. Kh√¥ng ph·∫£i quan h·ªá th·ª© nh·∫•t c≈©ng kh√¥ng ph·∫£i th·ª© hai.",
                "B. C·∫£ quan h·ªá th·ª© nh·∫•t v√† th·ª© hai.",
                "C. Quan h·ªá th·ª© nh·∫•t nh∆∞ng kh√¥ng ph·∫£i th·ª© hai.",
                "D. Quan h·ªá th·ª© hai nh∆∞ng kh√¥ng ph·∫£i th·ª© nh·∫•t."
            ],
            "answer": "C. Quan h·ªá th·ª© nh·∫•t nh∆∞ng kh√¥ng ph·∫£i th·ª© hai.",
            "explanation": "Ph√©p to√°n HI·ªÜU (B·∫£ng A - B·∫£ng B) tr·∫£ v·ªÅ t·∫•t c·∫£ c√°c h√†ng c√≥ trong B·∫£ng A nh∆∞ng KH√îNG c√≥ trong B·∫£ng B. **M·∫πo ghi nh·ªõ: A - B = C√°c h√†ng trong A kh√¥ng c√≥ trong B.**"
        }
    },
    {
        "id": 262,
        "category": "Chapter 11: Databases (C∆° s·ªü d·ªØ li·ªáu)",
        "en": {
            "question": "For each entity set in the E-R diagram we create a relation (table) in which there are n columns related to the _______ attributes defined for that set.",
            "options": [
                "A. n-1",
                "B. n",
                "C. n+1",
                "D. 1-n"
            ],
            "answer": "B. n",
            "explanation": "When converting an Entity-Relationship (E-R) diagram to a relational model, the standard first step is to create a table for each entity. This table will have one column for each attribute of that entity. **Key takeaway: One attribute in E-R = One column in table.**"
        },
        "vi": {
            "question": "ƒê·ªëi v·ªõi m·ªói t·∫≠p th·ª±c th·ªÉ trong s∆° ƒë·ªì E-R, ch√∫ng ta t·∫°o m·ªôt quan h·ªá (b·∫£ng) trong ƒë√≥ c√≥ n c·ªôt li√™n quan ƒë·∫øn _______ thu·ªôc t√≠nh ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a cho t·∫≠p ƒë√≥.",
            "options": [
                "A. n-1",
                "B. n",
                "C. n+1",
                "D. 1-n"
            ],
            "answer": "B. n",
            "explanation": "Khi chuy·ªÉn ƒë·ªïi m·ªôt s∆° ƒë·ªì Quan h·ªá-Th·ª±c th·ªÉ (E-R) sang m√¥ h√¨nh quan h·ªá, b∆∞·ªõc ti√™u chu·∫©n ƒë·∫ßu ti√™n l√† t·∫°o m·ªôt b·∫£ng cho m·ªói th·ª±c th·ªÉ. B·∫£ng n√†y s·∫Ω c√≥ m·ªôt c·ªôt cho m·ªói thu·ªôc t√≠nh c·ªßa th·ª±c th·ªÉ ƒë√≥. **M·∫πo ghi nh·ªõ: M·ªôt thu·ªôc t√≠nh trong E-R = M·ªôt c·ªôt trong b·∫£ng.**"
        }
    },
    {
        "id": 263,
        "category": "Chapter 11: Databases (C∆° s·ªü d·ªØ li·ªáu)",
        "en": {
            "question": "The intersection of a column and row in a spreadsheet is called a bon or",
            "options": [
                "A. Key",
                "B. Field",
                "C. Cell",
                "D. Menu"
            ],
            "answer": "C. Cell",
            "explanation": "In a spreadsheet, the basic unit for storing data is a cell, which is located at the intersection of a specific row and column. **Key takeaway: Spreadsheet row + column = Cell.**"
        },
        "vi": {
            "question": "Giao ƒëi·ªÉm c·ªßa m·ªôt c·ªôt v√† m·ªôt h√†ng trong m·ªôt b·∫£ng t√≠nh ƒë∆∞·ª£c g·ªçi l√† m·ªôt bon ho·∫∑c",
            "options": [
                "A. Kh√≥a",
                "B. Tr∆∞·ªùng",
                "C. √î",
                "D. Menu"
            ],
            "answer": "C. √î",
            "explanation": "Trong m·ªôt b·∫£ng t√≠nh, ƒë∆°n v·ªã c∆° b·∫£n ƒë·ªÉ l∆∞u tr·ªØ d·ªØ li·ªáu l√† m·ªôt √¥, n·∫±m ·ªü giao ƒëi·ªÉm c·ªßa m·ªôt h√†ng v√† m·ªôt c·ªôt c·ª• th·ªÉ. **M·∫πo ghi nh·ªõ: B·∫£ng t√≠nh h√†ng + c·ªôt = √î (Cell).**"
        }
    },
    {
        "id": 264,
        "category": "Chapter 11: Databases (C∆° s·ªü d·ªØ li·ªáu)",
        "en": {
            "question": "In the three-level ANSI/SPARC DBMS architecture model, which level is responsible for defining the logical structure of the entire database and hiding physical details?",
            "options": [
                "A. Internal Level.",
                "B. External Level.",
                "C. Conceptual Level.",
                "D. Physical Level."
            ],
            "answer": "C. Conceptual Level.",
            "explanation": "The Conceptual Level provides a global, community view of the database. It describes all entities, attributes, and relationships, independent of how the data is physically stored or how users view it. **Key takeaway: Conceptual = Overall logical structure of the DB.**"
        },
        "vi": {
            "question": "Trong m√¥ h√¨nh ki·∫øn tr√∫c DBMS ba t·∫ßng ANSI/SPARC, t·∫ßng n√†o ch·ªãu tr√°ch nhi·ªám ƒë·ªãnh nghƒ©a c·∫•u tr√∫c logic c·ªßa to√†n b·ªô c∆° s·ªü d·ªØ li·ªáu v√† che gi·∫•u c√°c chi ti·∫øt v·∫≠t l√Ω?",
            "options": [
                "A. Internal Level (T·∫ßng n·ªôi b·ªô).",
                "B. External Level (T·∫ßng ngo·∫°i vi).",
                "C. Conceptual Level (T·∫ßng kh√°i ni·ªám).",
                "D. Physical Level (T·∫ßng v·∫≠t l√Ω)."
            ],
            "answer": "C. Conceptual Level (T·∫ßng kh√°i ni·ªám).",
            "explanation": "T√†i li·ªáu (Ch 11, M·ª•c 2.3) ƒë·ªãnh nghƒ©a Conceptual Level l√† 'Defines the logical structure of the entire database, hiding physical details'. **M·∫πo ghi nh·ªõ: Conceptual = Logic t·ªïng th·ªÉ c·ªßa CSDL.**"
        }
    },
    {
        "id": 265,
        "category": "Chapter 12: Security and Ethical Issues (B·∫£o m·∫≠t & V·∫•n ƒë·ªÅ ƒë·∫°o ƒë·ª©c)",
        "en": {
            "question": "_______ ciphers are sometimes called public-key ciphers",
            "options": [
                "A. Symmetric-key",
                "B. Asymmetric-key",
                "C. Public-key",
                "D. Private-key"
            ],
            "answer": "B. Asymmetric-key",
            "explanation": "Asymmetric-key cryptography uses a pair of keys: a public key for encryption and a private key for decryption. Because one of the keys is public, it's also known as public-key cryptography. **Key takeaway: Asymmetric = Public-key.**"
        },
        "vi": {
            "question": "M√£ h√≥a _______ ƒë√¥i khi ƒë∆∞·ª£c g·ªçi l√† m√£ h√≥a kh√≥a c√¥ng khai",
            "options": [
                "A. Kh√≥a ƒë·ªëi x·ª©ng",
                "B. Kh√≥a b·∫•t ƒë·ªëi x·ª©ng",
                "C. Kh√≥a c√¥ng khai",
                "D. Kh√≥a ri√™ng t∆∞"
            ],
            "answer": "B. Kh√≥a b·∫•t ƒë·ªëi x·ª©ng",
            "explanation": "M·∫≠t m√£ kh√≥a b·∫•t ƒë·ªëi x·ª©ng s·ª≠ d·ª•ng m·ªôt c·∫∑p kh√≥a: m·ªôt kh√≥a c√¥ng khai ƒë·ªÉ m√£ h√≥a v√† m·ªôt kh√≥a ri√™ng t∆∞ ƒë·ªÉ gi·∫£i m√£. V√¨ m·ªôt trong c√°c kh√≥a l√† c√¥ng khai, n√≥ c√≤n ƒë∆∞·ª£c g·ªçi l√† m·∫≠t m√£ kh√≥a c√¥ng khai. **M·∫πo ghi nh·ªõ: B·∫•t ƒë·ªëi x·ª©ng = Kh√≥a c√¥ng khai.**"
        }
    },
    {
        "id": 266,
        "category": "Chapter 12: Security and Ethical Issues (B·∫£o m·∫≠t & V·∫•n ƒë·ªÅ ƒë·∫°o ƒë·ª©c)",
        "en": {
            "question": "A _______ does not substitute one symbol for another, instead it changes the location of the symbols",
            "options": [
                "A. Monoalphabetic cipher",
                "B. Substitution cipher",
                "C. Polyalphabetic cipher",
                "D. Transposition cipher"
            ],
            "answer": "D. Transposition cipher",
            "explanation": "A transposition cipher rearranges the letters of the plaintext without changing the letters themselves. A substitution cipher replaces letters with other letters or symbols. **Key takeaway: Changes location = Transposition. Changes symbol = Substitution.**"
        },
        "vi": {
            "question": "M·ªôt _______ kh√¥ng thay th·∫ø m·ªôt k√Ω hi·ªáu n√†y b·∫±ng m·ªôt k√Ω hi·ªáu kh√°c, thay v√†o ƒë√≥ n√≥ thay ƒë·ªïi v·ªã tr√≠ c·ªßa c√°c k√Ω hi·ªáu",
            "options": [
                "A. M·∫≠t m√£ ƒë∆°n b·∫£ng ch·ªØ c√°i",
                "B. M·∫≠t m√£ thay th·∫ø",
                "C. M·∫≠t m√£ ƒëa b·∫£ng ch·ªØ c√°i",
                "D. M·∫≠t m√£ ho√°n v·ªã"
            ],
            "answer": "D. M·∫≠t m√£ ho√°n v·ªã",
            "explanation": "M·∫≠t m√£ ho√°n v·ªã s·∫Øp x·∫øp l·∫°i c√°c ch·ªØ c√°i c·ªßa b·∫£n r√µ m√† kh√¥ng thay ƒë·ªïi b·∫£n th√¢n c√°c ch·ªØ c√°i. M·∫≠t m√£ thay th·∫ø thay th·∫ø c√°c ch·ªØ c√°i b·∫±ng c√°c ch·ªØ c√°i ho·∫∑c k√Ω hi·ªáu kh√°c. **M·∫πo ghi nh·ªõ: Thay ƒë·ªïi v·ªã tr√≠ = Ho√°n v·ªã. Thay ƒë·ªïi k√Ω hi·ªáu = Thay th·∫ø.**"
        }
    },
    {
        "id": 267,
        "category": "Chapter 12: Security and Ethical Issues (B·∫£o m·∫≠t & V·∫•n ƒë·ªÅ ƒë·∫°o ƒë·ª©c)",
        "en": {
            "question": "In a _______ the relationship between a character in the plaintext to a character in the ciphertext is one-to-many",
            "options": [
                "A. Monoalphabetic cipher",
                "B. Substitution cipher",
                "C. Polyalphabetic cipher",
                "D. Transposition cipher"
            ],
            "answer": "C. Polyalphabetic cipher",
            "explanation": "In a polyalphabetic cipher (like the Vigen√®re cipher), the same plaintext letter can be encrypted to different ciphertext letters depending on its position in the message. This one-to-many relationship makes it much harder to break with frequency analysis. **Key takeaway: One plaintext char -> Many ciphertext chars = Polyalphabetic.**"
        },
        "vi": {
            "question": "Trong m·ªôt _______, m·ªëi quan h·ªá gi·ªØa m·ªôt k√Ω t·ª± trong b·∫£n r√µ v√† m·ªôt k√Ω t·ª± trong b·∫£n m√£ l√† m·ªôt-nhi·ªÅu",
            "options": [
                "A. M·∫≠t m√£ ƒë∆°n b·∫£ng ch·ªØ c√°i",
                "B. M·∫≠t m√£ thay th·∫ø",
                "C. M·∫≠t m√£ ƒëa b·∫£ng ch·ªØ c√°i",
                "D. M·∫≠t m√£ ho√°n v·ªã"
            ],
            "answer": "C. M·∫≠t m√£ ƒëa b·∫£ng ch·ªØ c√°i",
            "explanation": "Trong m·ªôt m·∫≠t m√£ ƒëa b·∫£ng ch·ªØ c√°i (nh∆∞ m·∫≠t m√£ Vigen√®re), c√πng m·ªôt ch·ªØ c√°i b·∫£n r√µ c√≥ th·ªÉ ƒë∆∞·ª£c m√£ h√≥a th√†nh c√°c ch·ªØ c√°i b·∫£n m√£ kh√°c nhau t√πy thu·ªôc v√†o v·ªã tr√≠ c·ªßa n√≥ trong th√¥ng ƒëi·ªáp. M·ªëi quan h·ªá m·ªôt-nhi·ªÅu n√†y l√†m cho n√≥ kh√≥ b·ªã ph√° h∆°n nhi·ªÅu b·∫±ng ph√¢n t√≠ch t·∫ßn su·∫•t. **M·∫πo ghi nh·ªõ: M·ªôt k√Ω t·ª± b·∫£n r√µ -> Nhi·ªÅu k√Ω t·ª± b·∫£n m√£ = ƒêa b·∫£ng ch·ªØ c√°i.**"
        }
    },
    {
        "id": 268,
        "category": "Chapter 12: Security and Ethical Issues (B·∫£o m·∫≠t & V·∫•n ƒë·ªÅ ƒë·∫°o ƒë·ª©c)",
        "en": {
            "question": "The attack that reduces the capability of a computer is called a _______ attack.",
            "options": [
                "A. Penetration",
                "B. Denial of service",
                "C. Either a or b",
                "D. Neither a nor b"
            ],
            "answer": "B. Denial of service",
            "explanation": "A Denial-of-Service (DoS) attack aims to make a machine or network resource unavailable to its intended users by overwhelming it with traffic or crashing its services. This reduces its capability. **Key takeaway: Reduces capability/availability = Denial of Service.**"
        },
        "vi": {
            "question": "Cu·ªôc t·∫•n c√¥ng l√†m gi·∫£m kh·∫£ nƒÉng c·ªßa m·ªôt m√°y t√≠nh ƒë∆∞·ª£c g·ªçi l√† m·ªôt cu·ªôc t·∫•n c√¥ng _______.",
            "options": [
                "A. Th√¢m nh·∫≠p",
                "B. T·ª´ ch·ªëi d·ªãch v·ª•",
                "C. Ho·∫∑c a ho·∫∑c b",
                "D. C·∫£ a v√† b ƒë·ªÅu kh√¥ng"
            ],
            "answer": "B. T·ª´ ch·ªëi d·ªãch v·ª•",
            "explanation": "M·ªôt cu·ªôc t·∫•n c√¥ng T·ª´ ch·ªëi d·ªãch v·ª• (DoS) nh·∫±m m·ª•c ƒë√≠ch l√†m cho m·ªôt m√°y ho·∫∑c t√†i nguy√™n m·∫°ng kh√¥ng kh·∫£ d·ª•ng cho ng∆∞·ªùi d√πng d·ª± ƒë·ªãnh c·ªßa n√≥ b·∫±ng c√°ch l√†m qu√° t·∫£i n√≥ v·ªõi l∆∞u l∆∞·ª£ng truy c·∫≠p ho·∫∑c l√†m s·∫≠p c√°c d·ªãch v·ª• c·ªßa n√≥. ƒêi·ªÅu n√†y l√†m gi·∫£m kh·∫£ nƒÉng c·ªßa n√≥. **M·∫πo ghi nh·ªõ: Gi·∫£m kh·∫£ nƒÉng/t√≠nh s·∫µn s√†ng = T·ª´ ch·ªëi d·ªãch v·ª•.**"
        }
    },
    {
        "id": 269,
        "category": "Chapter 12: Security and Ethical Issues (B·∫£o m·∫≠t & V·∫•n ƒë·ªÅ ƒë·∫°o ƒë·ª©c)",
        "en": {
            "question": "_______ can be threatened by security attacks.",
            "options": [
                "A. Confidentiality, cryptography, nonrepudiation",
                "B. Confidentiality, encryption, decryption",
                "C. Confidentiality, integrity, availability",
                "D. Confidentiality, denial of service, masquerading"
            ],
            "answer": "C. Confidentiality, integrity, availability",
            "explanation": "These three form the 'CIA Triad', the fundamental goals of information security. Confidentiality (secrecy), Integrity (data is accurate), and Availability (system is accessible). **Key takeaway: CIA Triad = Confidentiality, Integrity, Availability.**"
        },
        "vi": {
            "question": "_______ c√≥ th·ªÉ b·ªã ƒëe d·ªça b·ªüi c√°c cu·ªôc t·∫•n c√¥ng an ninh.",
            "options": [
                "A. T√≠nh b·∫£o m·∫≠t, m·∫≠t m√£ h·ªçc, t√≠nh kh√¥ng th·ªÉ ch·ªëi c√£i",
                "B. T√≠nh b·∫£o m·∫≠t, m√£ h√≥a, gi·∫£i m√£",
                "C. T√≠nh b·∫£o m·∫≠t, t√≠nh to√†n v·∫πn, t√≠nh s·∫µn s√†ng",
                "D. T√≠nh b·∫£o m·∫≠t, t·ª´ ch·ªëi d·ªãch v·ª•, gi·∫£ m·∫°o"
            ],
            "answer": "C. T√≠nh b·∫£o m·∫≠t, t√≠nh to√†n v·∫πn, t√≠nh s·∫µn s√†ng",
            "explanation": "Ba y·∫øu t·ªë n√†y t·∫°o th√†nh 'Tam gi√°c CIA', c√°c m·ª•c ti√™u c∆° b·∫£n c·ªßa an ninh th√¥ng tin. T√≠nh b·∫£o m·∫≠t (Confidentiality), T√≠nh to√†n v·∫πn (Integrity - d·ªØ li·ªáu ch√≠nh x√°c), v√† T√≠nh s·∫µn s√†ng (Availability - h·ªá th·ªëng c√≥ th·ªÉ truy c·∫≠p). **M·∫πo ghi nh·ªõ: Tam gi√°c CIA = Confidentiality, Integrity, Availability.**"
        }
    },
    {
        "id": 270,
        "category": "Chapter 12: Security and Ethical Issues (B·∫£o m·∫≠t & V·∫•n ƒë·ªÅ ƒë·∫°o ƒë·ª©c)",
        "en": {
            "question": "In the attacks that threaten integrity, with _______ attack, the attacker modifies the information to make it beneficial to them",
            "options": [
                "A. Snooping",
                "B. Repudiation",
                "C. Denial of service",
                "D. Modification"
            ],
            "answer": "D. Modification",
            "explanation": "A modification attack directly targets data integrity. An attacker intercepts and alters data in transit or in storage. Snooping violates confidentiality, and Denial of service violates availability. **Key takeaway: Attack on integrity = Modification.**"
        },
        "vi": {
            "question": "Trong c√°c cu·ªôc t·∫•n c√¥ng ƒëe d·ªça t√≠nh to√†n v·∫πn, v·ªõi cu·ªôc t·∫•n c√¥ng _______, k·∫ª t·∫•n c√¥ng s·ª≠a ƒë·ªïi th√¥ng tin ƒë·ªÉ l√†m cho n√≥ c√≥ l·ª£i cho h·ªç",
            "options": [
                "A. Nghe l√©n",
                "B. Ch·ªëi b·ªè",
                "C. T·ª´ ch·ªëi d·ªãch v·ª•",
                "D. S·ª≠a ƒë·ªïi"
            ],
            "answer": "D. S·ª≠a ƒë·ªïi",
            "explanation": "M·ªôt cu·ªôc t·∫•n c√¥ng s·ª≠a ƒë·ªïi nh·∫Øm tr·ª±c ti·∫øp v√†o t√≠nh to√†n v·∫πn d·ªØ li·ªáu. K·∫ª t·∫•n c√¥ng ch·∫∑n v√† thay ƒë·ªïi d·ªØ li·ªáu ƒëang truy·ªÅn ho·∫∑c ƒëang ƒë∆∞·ª£c l∆∞u tr·ªØ. Nghe l√©n vi ph·∫°m t√≠nh b·∫£o m·∫≠t, v√† T·ª´ ch·ªëi d·ªãch v·ª• vi ph·∫°m t√≠nh s·∫µn s√†ng. **M·∫πo ghi nh·ªõ: T·∫•n c√¥ng t√≠nh to√†n v·∫πn = S·ª≠a ƒë·ªïi.**"
        }
    },
    {
        "id": 271,
        "category": "Chapter 12: Security and Ethical Issues (B·∫£o m·∫≠t & V·∫•n ƒë·ªÅ ƒë·∫°o ƒë·ª©c)",
        "en": {
            "question": "In the attacks that threaten integrity _______ is performed by one of the two parties in the communication: the sender or the receiver.",
            "options": [
                "A. Snooping",
                "B. Modification",
                "C. Repudiation",
                "D. Masquerading"
            ],
            "answer": "C. Repudiation",
            "explanation": "Repudiation is the act of denying that you sent or received a message. For example, a sender could falsely deny having sent a message, or a receiver could falsely deny having received one. This threatens the integrity of the transaction record. **Key takeaway: Denying an action = Repudiation.**"
        },
        "vi": {
            "question": "Trong c√°c cu·ªôc t·∫•n c√¥ng ƒëe d·ªça t√≠nh to√†n v·∫πn, _______ ƒë∆∞·ª£c th·ª±c hi·ªán b·ªüi m·ªôt trong hai b√™n trong giao ti·∫øp: ng∆∞·ªùi g·ª≠i ho·∫∑c ng∆∞·ªùi nh·∫≠n.",
            "options": [
                "A. Nghe l√©n",
                "B. S·ª≠a ƒë·ªïi",
                "C. Ch·ªëi b·ªè",
                "D. Gi·∫£ m·∫°o"
            ],
            "answer": "C. Ch·ªëi b·ªè",
            "explanation": "Ch·ªëi b·ªè l√† h√†nh ƒë·ªông ph·ªß nh·∫≠n r·∫±ng b·∫°n ƒë√£ g·ª≠i ho·∫∑c nh·∫≠n m·ªôt th√¥ng ƒëi·ªáp. V√≠ d·ª•, ng∆∞·ªùi g·ª≠i c√≥ th·ªÉ ph·ªß nh·∫≠n sai r·∫±ng ƒë√£ g·ª≠i m·ªôt th√¥ng ƒëi·ªáp, ho·∫∑c ng∆∞·ªùi nh·∫≠n c√≥ th·ªÉ ph·ªß nh·∫≠n sai r·∫±ng ƒë√£ nh·∫≠n ƒë∆∞·ª£c. ƒêi·ªÅu n√†y ƒëe d·ªça t√≠nh to√†n v·∫πn c·ªßa b·∫£n ghi giao d·ªãch. **M·∫πo ghi nh·ªõ: Ph·ªß nh·∫≠n m·ªôt h√†nh ƒë·ªông = Ch·ªëi b·ªè.**"
        }
    },
    {
        "id": 272,
        "category": "Chapter 12: Security and Ethical Issues (B·∫£o m·∫≠t & V·∫•n ƒë·ªÅ ƒë·∫°o ƒë·ª©c)",
        "en": {
            "question": "In _______ cryptography, everyone has access to everyone's public key.",
            "options": [
                "A. Symmetric-key",
                "B. Asymmetric-key",
                "C. Secret-key",
                "D. Private-key"
            ],
            "answer": "B. Asymmetric-key",
            "explanation": "This is a key feature of asymmetric (or public-key) cryptography. Public keys are designed to be shared openly, allowing anyone to send an encrypted message to the key's owner. **Key takeaway: Public keys are shared = Asymmetric.**"
        },
        "vi": {
            "question": "Trong m·∫≠t m√£ _______, m·ªçi ng∆∞·ªùi ƒë·ªÅu c√≥ quy·ªÅn truy c·∫≠p v√†o kh√≥a c√¥ng khai c·ªßa m·ªçi ng∆∞·ªùi.",
            "options": [
                "A. Kh√≥a ƒë·ªëi x·ª©ng",
                "B. Kh√≥a b·∫•t ƒë·ªëi x·ª©ng",
                "C. Kh√≥a b√≠ m·∫≠t",
                "D. Kh√≥a ri√™ng t∆∞"
            ],
            "answer": "B. Kh√≥a b·∫•t ƒë·ªëi x·ª©ng",
            "explanation": "ƒê√¢y l√† m·ªôt t√≠nh nƒÉng ch√≠nh c·ªßa m·∫≠t m√£ kh√≥a b·∫•t ƒë·ªëi x·ª©ng (ho·∫∑c kh√≥a c√¥ng khai). C√°c kh√≥a c√¥ng khai ƒë∆∞·ª£c thi·∫øt k·∫ø ƒë·ªÉ ƒë∆∞·ª£c chia s·∫ª c√¥ng khai, cho ph√©p b·∫•t k·ª≥ ai g·ª≠i m·ªôt th√¥ng ƒëi·ªáp ƒë∆∞·ª£c m√£ h√≥a ƒë·∫øn ch·ªß s·ªü h·ªØu c·ªßa kh√≥a. **M·∫πo ghi nh·ªõ: Kh√≥a c√¥ng khai ƒë∆∞·ª£c chia s·∫ª = B·∫•t ƒë·ªëi x·ª©ng.**"
        }
    },
    {
        "id": 273,
        "category": "Chapter 12: Security and Ethical Issues (B·∫£o m·∫≠t & V·∫•n ƒë·ªÅ ƒë·∫°o ƒë·ª©c)",
        "en": {
            "question": "In _______ cryptography, the same key is used by the sender and the receiver.",
            "options": [
                "A. Symmetric-key",
                "B. Asymmetric-key",
                "C. Public-key",
                "D. Open-key"
            ],
            "answer": "A. Symmetric-key",
            "explanation": "Symmetric-key cryptography uses a single, shared secret key for both encryption and decryption. This key must be securely exchanged between the sender and receiver beforehand. **Key takeaway: Same key for both ends = Symmetric.**"
        },
        "vi": {
            "question": "Trong m·∫≠t m√£ _______, c√πng m·ªôt kh√≥a ƒë∆∞·ª£c s·ª≠ d·ª•ng b·ªüi ng∆∞·ªùi g·ª≠i v√† ng∆∞·ªùi nh·∫≠n.",
            "options": [
                "A. Kh√≥a ƒë·ªëi x·ª©ng",
                "B. Kh√≥a b·∫•t ƒë·ªëi x·ª©ng",
                "C. Kh√≥a c√¥ng khai",
                "D. Kh√≥a m·ªü"
            ],
            "answer": "A. Kh√≥a ƒë·ªëi x·ª©ng",
            "explanation": "M·∫≠t m√£ kh√≥a ƒë·ªëi x·ª©ng s·ª≠ d·ª•ng m·ªôt kh√≥a b√≠ m·∫≠t duy nh·∫•t, ƒë∆∞·ª£c chia s·∫ª cho c·∫£ vi·ªác m√£ h√≥a v√† gi·∫£i m√£. Kh√≥a n√†y ph·∫£i ƒë∆∞·ª£c trao ƒë·ªïi m·ªôt c√°ch an to√†n gi·ªØa ng∆∞·ªùi g·ª≠i v√† ng∆∞·ªùi nh·∫≠n tr∆∞·ªõc ƒë√≥. **M·∫πo ghi nh·ªõ: C√πng m·ªôt kh√≥a cho c·∫£ hai b√™n = ƒê·ªëi x·ª©ng.**"
        }
    },
    {
        "id": 274,
        "category": "Chapter 12: Security and Ethical Issues (B·∫£o m·∫≠t & V·∫•n ƒë·ªÅ ƒë·∫°o ƒë·ª©c)",
        "en": {
            "question": "In RSA, if user A wants to send an encrypted message to user B, the plaintext is encrypted with the public key of _______ .",
            "options": [
                "A. User A",
                "B. User B",
                "C. The network",
                "D. A third party"
            ],
            "answer": "B. User B",
            "explanation": "In public-key cryptography, to ensure confidentiality, you always encrypt the message with the recipient's public key. Only the recipient, who possesses the corresponding private key, can decrypt it. **Key takeaway: Encrypt with recipient's PUBLIC key.**"
        },
        "vi": {
            "question": "Trong RSA, n·∫øu ng∆∞·ªùi d√πng A mu·ªën g·ª≠i m·ªôt th√¥ng ƒëi·ªáp ƒë∆∞·ª£c m√£ h√≥a cho ng∆∞·ªùi d√πng B, b·∫£n r√µ ƒë∆∞·ª£c m√£ h√≥a b·∫±ng kh√≥a c√¥ng khai c·ªßa _______ .",
            "options": [
                "A. Ng∆∞·ªùi d√πng A",
                "B. Ng∆∞·ªùi d√πng B",
                "C. M·∫°ng",
                "D. M·ªôt b√™n th·ª© ba"
            ],
            "answer": "B. Ng∆∞·ªùi d√πng B",
            "explanation": "Trong m·∫≠t m√£ kh√≥a c√¥ng khai, ƒë·ªÉ ƒë·∫£m b·∫£o t√≠nh b·∫£o m·∫≠t, b·∫°n lu√¥n m√£ h√≥a th√¥ng ƒëi·ªáp b·∫±ng kh√≥a c√¥ng khai c·ªßa ng∆∞·ªùi nh·∫≠n. Ch·ªâ c√≥ ng∆∞·ªùi nh·∫≠n, ng∆∞·ªùi s·ªü h·ªØu kh√≥a ri√™ng t∆∞ t∆∞∆°ng ·ª©ng, m·ªõi c√≥ th·ªÉ gi·∫£i m√£ n√≥. **M·∫πo ghi nh·ªõ: M√£ h√≥a b·∫±ng kh√≥a C√îNG KHAI c·ªßa ng∆∞·ªùi nh·∫≠n.**"
        }
    },
    {
        "id": 275,
        "category": "Chapter 12: Security and Ethical Issues (B·∫£o m·∫≠t & V·∫•n ƒë·ªÅ ƒë·∫°o ƒë·ª©c)",
        "en": {
            "question": "Before transmission the sender transforms the plaintext into the ciphertext--this is _______",
            "options": [
                "A. Plain text",
                "B. Cipher text",
                "C. Encryption",
                "D. Decryption"
            ],
            "answer": "C. Encryption",
            "explanation": "Encryption is the process of converting readable data (plaintext) into an unreadable format (ciphertext) to protect it. **Key takeaway: Plaintext -> Ciphertext = Encryption.**"
        },
        "vi": {
            "question": "Tr∆∞·ªõc khi truy·ªÅn, ng∆∞·ªùi g·ª≠i bi·∫øn ƒë·ªïi b·∫£n r√µ th√†nh b·∫£n m√£--ƒë√¢y l√† _______",
            "options": [
                "A. B·∫£n r√µ",
                "B. B·∫£n m√£",
                "C. M√£ h√≥a",
                "D. Gi·∫£i m√£"
            ],
            "answer": "C. M√£ h√≥a",
            "explanation": "M√£ h√≥a l√† qu√° tr√¨nh chuy·ªÉn ƒë·ªïi d·ªØ li·ªáu c√≥ th·ªÉ ƒë·ªçc ƒë∆∞·ª£c (b·∫£n r√µ) th√†nh m·ªôt ƒë·ªãnh d·∫°ng kh√¥ng th·ªÉ ƒë·ªçc ƒë∆∞·ª£c (b·∫£n m√£) ƒë·ªÉ b·∫£o v·ªá n√≥. **M·∫πo ghi nh·ªõ: B·∫£n r√µ -> B·∫£n m√£ = M√£ h√≥a.**"
        }
    },
    {
        "id": 276,
        "category": "Chapter 12: Security and Ethical Issues (B·∫£o m·∫≠t & V·∫•n ƒë·ªÅ ƒë·∫°o ƒë·ª©c)",
        "en": {
            "question": "When the ciphertext is received the receiver must transform the ciphertext back into the plaintext--this is _______",
            "options": [
                "A. Plain text",
                "B. Cipher text",
                "C. Encryption",
                "D. Decryption"
            ],
            "answer": "D. Decryption",
            "explanation": "Decryption is the process of converting unreadable ciphertext back into its original, readable plaintext form. **Key takeaway: Ciphertext -> Plaintext = Decryption.**"
        },
        "vi": {
            "question": "Khi b·∫£n m√£ ƒë∆∞·ª£c nh·∫≠n, ng∆∞·ªùi nh·∫≠n ph·∫£i bi·∫øn ƒë·ªïi b·∫£n m√£ tr·ªü l·∫°i th√†nh b·∫£n r√µ--ƒë√¢y l√† _______",
            "options": [
                "A. B·∫£n r√µ",
                "B. B·∫£n m√£",
                "C. M√£ h√≥a",
                "D. Gi·∫£i m√£"
            ],
            "answer": "D. Gi·∫£i m√£",
            "explanation": "Gi·∫£i m√£ l√† qu√° tr√¨nh chuy·ªÉn ƒë·ªïi b·∫£n m√£ kh√¥ng th·ªÉ ƒë·ªçc ƒë∆∞·ª£c tr·ªü l·∫°i d·∫°ng b·∫£n r√µ ban ƒë·∫ßu, c√≥ th·ªÉ ƒë·ªçc ƒë∆∞·ª£c. **M·∫πo ghi nh·ªõ: B·∫£n m√£ -> B·∫£n r√µ = Gi·∫£i m√£.**"
        }
    },
    {
        "id": 277,
        "category": "Chapter 12: Security and Ethical Issues (B·∫£o m·∫≠t & V·∫•n ƒë·ªÅ ƒë·∫°o ƒë·ª©c)",
        "en": {
            "question": "Which of following that describe to protect data that information needs to be protected from unauthorized change?",
            "options": [
                "A. Confidentiality",
                "B. Integrity",
                "C. Availability",
                "D. Masquerading"
            ],
            "answer": "B. Integrity",
            "explanation": "Integrity is the 'I' in the CIA triad. It ensures that data is accurate and trustworthy and has not been modified by unauthorized parties. **Key takeaway: Protection from change = Integrity.**"
        },
        "vi": {
            "question": "ƒêi·ªÅu n√†o sau ƒë√¢y m√¥ t·∫£ vi·ªác b·∫£o v·ªá d·ªØ li·ªáu kh·ªèi s·ª± thay ƒë·ªïi tr√°i ph√©p?",
            "options": [
                "A. T√≠nh b·∫£o m·∫≠t",
                "B. T√≠nh to√†n v·∫πn",
                "C. T√≠nh s·∫µn s√†ng",
                "D. Gi·∫£ m·∫°o"
            ],
            "answer": "B. T√≠nh to√†n v·∫πn",
            "explanation": "T√≠nh to√†n v·∫πn l√† ch·ªØ 'I' trong tam gi√°c CIA. N√≥ ƒë·∫£m b·∫£o r·∫±ng d·ªØ li·ªáu l√† ch√≠nh x√°c v√† ƒë√°ng tin c·∫≠y v√† ch∆∞a b·ªã s·ª≠a ƒë·ªïi b·ªüi c√°c b√™n kh√¥ng ƒë∆∞·ª£c ph√©p. **M·∫πo ghi nh·ªõ: B·∫£o v·ªá kh·ªèi s·ª± thay ƒë·ªïi = T√≠nh to√†n v·∫πn.**"
        }
    },
    {
        "id": 278,
        "category": "Chapter 12: Security and Ethical Issues (B·∫£o m·∫≠t & V·∫•n ƒë·ªÅ ƒë·∫°o ƒë·ª©c)",
        "en": {
            "question": "Which of the following attacks is threatening confidentiality?",
            "options": [
                "A. Snooping",
                "B. Repudiation",
                "C. Denial of service",
                "D. Modification"
            ],
            "answer": "A. Snooping",
            "explanation": "Snooping (or eavesdropping) is the act of secretly listening to a private communication, which directly violates confidentiality (secrecy). **Key takeaway: Secretly listening = Snooping = Threat to Confidentiality.**"
        },
        "vi": {
            "question": "Cu·ªôc t·∫•n c√¥ng n√†o sau ƒë√¢y ƒëe d·ªça t√≠nh b·∫£o m·∫≠t?",
            "options": [
                "A. Nghe l√©n",
                "B. Ch·ªëi b·ªè",
                "C. T·ª´ ch·ªëi d·ªãch v·ª•",
                "D. S·ª≠a ƒë·ªïi"
            ],
            "answer": "A. Nghe l√©n",
            "explanation": "Nghe l√©n (ho·∫∑c eavesdropping) l√† h√†nh ƒë·ªông b√≠ m·∫≠t nghe m·ªôt cu·ªôc giao ti·∫øp ri√™ng t∆∞, ƒëi·ªÅu n√†y tr·ª±c ti·∫øp vi ph·∫°m t√≠nh b·∫£o m·∫≠t (b√≠ m·∫≠t). **M·∫πo ghi nh·ªõ: Nghe l√©n = Snooping = ƒêe d·ªça T√≠nh b·∫£o m·∫≠t.**"
        }
    },
    {
        "id": 279,
        "category": "Chapter 12: Security and Ethical Issues (B·∫£o m·∫≠t & V·∫•n ƒë·ªÅ ƒë·∫°o ƒë·ª©c)",
        "en": {
            "question": "Which of the following is the coding of data so that it can't be easily understood if intercepted?",
            "options": [
                "A. Barcode",
                "B. Decoder",
                "C. Encryption",
                "D. Memonics"
            ],
            "answer": "C. Encryption",
            "explanation": "This is the definition of encryption. It is the core technique used to ensure data confidentiality. **Key takeaway: Coding data for secrecy = Encryption.**"
        },
        "vi": {
            "question": "ƒêi·ªÅu n√†o sau ƒë√¢y l√† vi·ªác m√£ h√≥a d·ªØ li·ªáu ƒë·ªÉ n√≥ kh√¥ng th·ªÉ d·ªÖ d√†ng b·ªã hi·ªÉu n·∫øu b·ªã ch·∫∑n l·∫°i?",
            "options": [
                "A. M√£ v·∫°ch",
                "B. B·ªô gi·∫£i m√£",
                "C. M√£ h√≥a",
                "D. G·ª£i nh·ªõ"
            ],
            "answer": "C. M√£ h√≥a",
            "explanation": "ƒê√¢y l√† ƒë·ªãnh nghƒ©a c·ªßa m√£ h√≥a. N√≥ l√† k·ªπ thu·∫≠t c·ªët l√µi ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ ƒë·∫£m b·∫£o t√≠nh b·∫£o m·∫≠t c·ªßa d·ªØ li·ªáu. **M·∫πo ghi nh·ªõ: M√£ h√≥a d·ªØ li·ªáu ƒë·ªÉ b·∫£o m·∫≠t = M√£ h√≥a.**"
        }
    },
    {
        "id": 280,
        "category": "Chapter 12: Security and Ethical Issues (B·∫£o m·∫≠t & V·∫•n ƒë·ªÅ ƒë·∫°o ƒë·ª©c)",
        "en": {
            "question": "The ethical principle that dictates that a decision should be made according to the universally accepted principles of morality is referred to as _______.",
            "options": [
                "A. Moral rules",
                "B. Utilitarian",
                "C. Social contract",
                "D. None of the others"
            ],
            "answer": "A. Moral rules",
            "explanation": "The Moral Rules (or Deontology) approach to ethics states that an action is right or wrong based on whether it adheres to a set of universal moral rules, regardless of the consequences. **Key takeaway: Universal principles = Moral Rules.**"
        },
        "vi": {
            "question": "Nguy√™n t·∫Øc ƒë·∫°o ƒë·ª©c quy ƒë·ªãnh r·∫±ng m·ªôt quy·∫øt ƒë·ªãnh n√™n ƒë∆∞·ª£c ƒë∆∞a ra theo c√°c nguy√™n t·∫Øc ƒë·∫°o ƒë·ª©c ƒë∆∞·ª£c ch·∫•p nh·∫≠n ph·ªï qu√°t ƒë∆∞·ª£c g·ªçi l√† _______.",
            "options": [
                "A. Quy t·∫Øc ƒë·∫°o ƒë·ª©c",
                "B. V·ªã l·ª£i",
                "C. Kh·∫ø ∆∞·ªõc x√£ h·ªôi",
                "D. Kh√¥ng c√≥ ph∆∞∆°ng √°n n√†o kh√°c"
            ],
            "answer": "A. Quy t·∫Øc ƒë·∫°o ƒë·ª©c",
            "explanation": "C√°ch ti·∫øp c·∫≠n Quy t·∫Øc ƒë·∫°o ƒë·ª©c (ho·∫∑c Nghƒ©a v·ª• lu·∫≠n) ƒë·ªëi v·ªõi ƒë·∫°o ƒë·ª©c n√≥i r·∫±ng m·ªôt h√†nh ƒë·ªông l√† ƒë√∫ng hay sai d·ª±a tr√™n vi·ªác n√≥ c√≥ tu√¢n th·ªß m·ªôt t·∫≠p h·ª£p c√°c quy t·∫Øc ƒë·∫°o ƒë·ª©c ph·ªï qu√°t hay kh√¥ng, b·∫•t k·ªÉ h·∫≠u qu·∫£. **M·∫πo ghi nh·ªõ: Nguy√™n t·∫Øc ph·ªï qu√°t = Quy t·∫Øc ƒë·∫°o ƒë·ª©c.**"
        }
    },
    {
        "id": 281,
        "category": "Chapter 12: Security and Ethical Issues (B·∫£o m·∫≠t & V·∫•n ƒë·ªÅ ƒë·∫°o ƒë·ª©c)",
        "en": {
            "question": "_______ are the 'bad guys'. They are the types of hackers who break into computer networks with purely negative motives such as monetary gain or reputation.",
            "options": [
                "A. Black Hat Hacker",
                "B. Grey Hat Hacker",
                "C. Red Hat Hacker",
                "D. Blue Hat Hacker"
            ],
            "answer": "A. Black Hat Hacker",
            "explanation": "Black hat hackers are malicious actors who violate computer security for personal gain or malice. White hats are ethical hackers, and grey hats operate in a morally ambiguous area. **Key takeaway: Malicious hacker = Black Hat.**"
        },
        "vi": {
            "question": "_______ l√† 'nh·ªØng k·∫ª x·∫•u'. H·ªç l√† nh·ªØng lo·∫°i hacker ƒë·ªôt nh·∫≠p v√†o c√°c m·∫°ng m√°y t√≠nh v·ªõi ƒë·ªông c∆° ho√†n to√†n ti√™u c·ª±c nh∆∞ l·ª£i √≠ch ti·ªÅn t·ªá ho·∫∑c danh ti·∫øng.",
            "options": [
                "A. Hacker m≈© ƒëen",
                "B. Hacker m≈© x√°m",
                "C. Hacker m≈© ƒë·ªè",
                "D. Hacker m≈© xanh"
            ],
            "answer": "A. Hacker m≈© ƒëen",
            "explanation": "Hacker m≈© ƒëen l√† nh·ªØng t√°c nh√¢n ƒë·ªôc h·∫°i vi ph·∫°m an ninh m√°y t√≠nh v√¨ l·ª£i √≠ch c√° nh√¢n ho·∫∑c √°c √Ω. M≈© tr·∫Øng l√† hacker c√≥ ƒë·∫°o ƒë·ª©c, v√† m≈© x√°m ho·∫°t ƒë·ªông trong m·ªôt khu v·ª±c ƒë·∫°o ƒë·ª©c kh√¥ng r√µ r√†ng. **M·∫πo ghi nh·ªõ: Hacker ƒë·ªôc h·∫°i = M≈© ƒëen.**"
        }
    },
    {
        "id": 282,
        "category": "Chapter 12: Security and Ethical Issues (B·∫£o m·∫≠t & V·∫•n ƒë·ªÅ ƒë·∫°o ƒë·ª©c)",
        "en": {
            "question": "_______ who create algorithms to break existing internet networks so as to solve the loopholes in them",
            "options": [
                "A. Black Hat Hacker",
                "B. Grey Hat Hacker",
                "C. White Hat Hacker",
                "D. Blue Hat Hacker"
            ],
            "answer": "C. White Hat Hacker",
            "explanation": "White hat hackers, or ethical hackers, use their skills to find security vulnerabilities with permission from the system owner, in order to help fix those vulnerabilities before malicious hackers can exploit them. **Key takeaway: Ethical hacker / Fixes loopholes = White Hat.**"
        },
        "vi": {
            "question": "_______ l√† ng∆∞·ªùi t·∫°o ra c√°c thu·∫≠t to√°n ƒë·ªÉ ph√° v·ª° c√°c m·∫°ng internet hi·ªán c√≥ nh·∫±m gi·∫£i quy·∫øt c√°c l·ªó h·ªïng trong ƒë√≥",
            "options": [
                "A. Hacker m≈© ƒëen",
                "B. Hacker m≈© x√°m",
                "C. Hacker m≈© tr·∫Øng",
                "D. Hacker m≈© xanh"
            ],
            "answer": "C. Hacker m≈© tr·∫Øng",
            "explanation": "Hacker m≈© tr·∫Øng, hay hacker c√≥ ƒë·∫°o ƒë·ª©c, s·ª≠ d·ª•ng k·ªπ nƒÉng c·ªßa h·ªç ƒë·ªÉ t√¨m ra c√°c l·ªó h·ªïng b·∫£o m·∫≠t v·ªõi s·ª± cho ph√©p c·ªßa ch·ªß s·ªü h·ªØu h·ªá th·ªëng, nh·∫±m gi√∫p kh·∫Øc ph·ª•c nh·ªØng l·ªó h·ªïng ƒë√≥ tr∆∞·ªõc khi c√°c hacker ƒë·ªôc h·∫°i c√≥ th·ªÉ khai th√°c ch√∫ng. **M·∫πo ghi nh·ªõ: Hacker c√≥ ƒë·∫°o ƒë·ª©c / S·ª≠a l·ªó h·ªïng = M≈© tr·∫Øng.**"
        }
    },
    {
        "id": 283,
        "category": "Chapter 12: Security and Ethical Issues (B·∫£o m·∫≠t & V·∫•n ƒë·ªÅ ƒë·∫°o ƒë·ª©c)",
        "en": {
            "question": "In the attacks threaten the confidentiality based on _______, they can obtain some other type of information by monitoring online traffic",
            "options": [
                "A. Snooping",
                "B. Repudiation",
                "C. Denial of service",
                "D. Traffic analysis"
            ],
            "answer": "D. Traffic analysis",
            "explanation": "Traffic analysis involves monitoring encrypted traffic to infer information. Even if the content is unreadable (snooping fails), an attacker can learn who is talking to whom, how often, and how much data is being sent, which can reveal valuable intelligence. **Key takeaway: Analyzing patterns in encrypted traffic = Traffic analysis.**"
        },
        "vi": {
            "question": "Trong c√°c cu·ªôc t·∫•n c√¥ng ƒëe d·ªça t√≠nh b·∫£o m·∫≠t d·ª±a tr√™n _______, h·ªç c√≥ th·ªÉ thu ƒë∆∞·ª£c m·ªôt s·ªë lo·∫°i th√¥ng tin kh√°c b·∫±ng c√°ch theo d√µi l∆∞u l∆∞·ª£ng truy c·∫≠p tr·ª±c tuy·∫øn",
            "options": [
                "A. Nghe l√©n",
                "B. Ch·ªëi b·ªè",
                "C. T·ª´ ch·ªëi d·ªãch v·ª•",
                "D. Ph√¢n t√≠ch l∆∞u l∆∞·ª£ng"
            ],
            "answer": "D. Ph√¢n t√≠ch l∆∞u l∆∞·ª£ng",
            "explanation": "Ph√¢n t√≠ch l∆∞u l∆∞·ª£ng li√™n quan ƒë·∫øn vi·ªác theo d√µi l∆∞u l∆∞·ª£ng ƒë√£ ƒë∆∞·ª£c m√£ h√≥a ƒë·ªÉ suy ra th√¥ng tin. Ngay c·∫£ khi n·ªôi dung kh√¥ng th·ªÉ ƒë·ªçc ƒë∆∞·ª£c (nghe l√©n th·∫•t b·∫°i), k·∫ª t·∫•n c√¥ng v·∫´n c√≥ th·ªÉ bi·∫øt ai ƒëang n√≥i chuy·ªán v·ªõi ai, t·∫ßn su·∫•t v√† l∆∞·ª£ng d·ªØ li·ªáu ƒë∆∞·ª£c g·ª≠i, ƒëi·ªÅu n√†y c√≥ th·ªÉ ti·∫øt l·ªô th√¥ng tin t√¨nh b√°o c√≥ gi√° tr·ªã. **M·∫πo ghi nh·ªõ: Ph√¢n t√≠ch c√°c m·∫´u trong l∆∞u l∆∞·ª£ng ƒë√£ m√£ h√≥a = Ph√¢n t√≠ch l∆∞u l∆∞·ª£ng.**"
        }
    },
    {
        "id": 284,
        "category": "Chapter 12: Security and Ethical Issues (B·∫£o m·∫≠t & V·∫•n ƒë·ªÅ ƒë·∫°o ƒë·ª©c)",
        "en": {
            "question": "The _______ of ethics says that an act is ethical if it brings about a useful for society",
            "options": [
                "A. Moral rules",
                "B. Social contract",
                "C. Utilitarian",
                "D. Nonmaleficence"
            ],
            "answer": "C. Utilitarian",
            "explanation": "Utilitarianism is a consequence-based ethical theory. It holds that the most ethical choice is the one that will produce the greatest good for the greatest number of people. **Key takeaway: Greatest good for society = Utilitarian.**"
        },
        "vi": {
            "question": "Nguy√™n t·∫Øc ƒë·∫°o ƒë·ª©c _______ n√≥i r·∫±ng m·ªôt h√†nh ƒë·ªông l√† c√≥ ƒë·∫°o ƒë·ª©c n·∫øu n√≥ mang l·∫°i l·ª£i √≠ch cho x√£ h·ªôi",
            "options": [
                "A. Quy t·∫Øc ƒë·∫°o ƒë·ª©c",
                "B. Kh·∫ø ∆∞·ªõc x√£ h·ªôi",
                "C. V·ªã l·ª£i",
                "D. Kh√¥ng g√¢y h·∫°i"
            ],
            "answer": "C. V·ªã l·ª£i",
            "explanation": "Ch·ªß nghƒ©a v·ªã l·ª£i l√† m·ªôt l√Ω thuy·∫øt ƒë·∫°o ƒë·ª©c d·ª±a tr√™n h·∫≠u qu·∫£. N√≥ cho r·∫±ng l·ª±a ch·ªçn ƒë·∫°o ƒë·ª©c nh·∫•t l√† l·ª±a ch·ªçn s·∫Ω t·∫°o ra l·ª£i √≠ch l·ªõn nh·∫•t cho s·ªë ƒë√¥ng ng∆∞·ªùi nh·∫•t. **M·∫πo ghi nh·ªõ: L·ª£i √≠ch l·ªõn nh·∫•t cho x√£ h·ªôi = V·ªã l·ª£i.**"
        }
    },
    {
        "id": 285,
        "category": "Chapter 12: Security and Ethical Issues (B·∫£o m·∫≠t & V·∫•n ƒë·ªÅ ƒë·∫°o ƒë·ª©c)",
        "en": {
            "question": "The main principles of ethics are _______",
            "options": [
                "A. Moral rules, social contract, utilitarian",
                "B. Ethical decision, social justice, procedural justice",
                "C. Beneficence, procedural justice, fidelity",
                "D. Nonmaleficence, social justice, fidelity"
            ],
            "answer": "A. Moral rules, social contract, utilitarian",
            "explanation": "The provided study material (Chapter 12, Section 3.1) specifically lists these three as the main ethical principles for consideration: Moral Rules, Utilitarianism, and Social Contract. **Key takeaway: The three main ethical frameworks are Moral Rules, Utilitarianism, and Social Contract.**"
        },
        "vi": {
            "question": "C√°c nguy√™n t·∫Øc ch√≠nh c·ªßa ƒë·∫°o ƒë·ª©c l√† _______",
            "options": [
                "A. Quy t·∫Øc ƒë·∫°o ƒë·ª©c, kh·∫ø ∆∞·ªõc x√£ h·ªôi, v·ªã l·ª£i",
                "B. Quy·∫øt ƒë·ªãnh ƒë·∫°o ƒë·ª©c, c√¥ng b·∫±ng x√£ h·ªôi, c√¥ng b·∫±ng th·ªß t·ª•c",
                "C. L√≤ng nh√¢n t·ª´, c√¥ng b·∫±ng th·ªß t·ª•c, l√≤ng trung th√†nh",
                "D. Kh√¥ng g√¢y h·∫°i, c√¥ng b·∫±ng x√£ h·ªôi, l√≤ng trung th√†nh"
            ],
            "answer": "A. Quy t·∫Øc ƒë·∫°o ƒë·ª©c, kh·∫ø ∆∞·ªõc x√£ h·ªôi, v·ªã l·ª£i",
            "explanation": "T√†i li·ªáu h·ªçc t·∫≠p ƒë∆∞·ª£c cung c·∫•p (Ch∆∞∆°ng 12, M·ª•c 3.1) li·ªát k√™ c·ª• th·ªÉ ba nguy√™n t·∫Øc n√†y l√† c√°c nguy√™n t·∫Øc ƒë·∫°o ƒë·ª©c ch√≠nh c·∫ßn xem x√©t: Quy t·∫Øc ƒë·∫°o ƒë·ª©c, Ch·ªß nghƒ©a v·ªã l·ª£i v√† Kh·∫ø ∆∞·ªõc x√£ h·ªôi. **M·∫πo ghi nh·ªõ: Ba khu√¥n kh·ªï ƒë·∫°o ƒë·ª©c ch√≠nh l√† Quy t·∫Øc ƒë·∫°o ƒë·ª©c, V·ªã l·ª£i v√† Kh·∫ø ∆∞·ªõc x√£ h·ªôi.**"
        }
    },
    {
        "id": 286,
        "category": "Chapter 12: Security and Ethical Issues (B·∫£o m·∫≠t & V·∫•n ƒë·ªÅ ƒë·∫°o ƒë·ª©c)",
        "en": {
            "question": "Which type of hacker is described as an 'ethical hacker' who tests systems to improve security?",
            "options": [
                "A. Black Hat Hacker.",
                "B. White Hat Hacker.",
                "C. Grey Hat Hacker.",
                "D. Blue Hat Hacker."
            ],
            "answer": "B. White Hat Hacker.",
            "explanation": "White hat hackers are security professionals who are employed or contracted to find vulnerabilities in systems. They operate with permission and their goal is to help organizations strengthen their security posture. **Key takeaway: White Hat = Ethical = The good guys.**"
        },
        "vi": {
            "question": "Lo·∫°i hacker n√†o ƒë∆∞·ª£c m√¥ t·∫£ l√† 'hacker ƒë·∫°o ƒë·ª©c' (ethical hackers), nh·ªØng ng∆∞·ªùi ki·ªÉm tra h·ªá th·ªëng ƒë·ªÉ tƒÉng c∆∞·ªùng b·∫£o m·∫≠t?",
            "options": [
                "A. Black Hat Hacker (Hacker m≈© ƒëen).",
                "B. White Hat Hacker (Hacker m≈© tr·∫Øng).",
                "C. Grey Hat Hacker (Hacker m≈© x√°m).",
                "D. Blue Hat Hacker (Hacker m≈© xanh)."
            ],
            "answer": "B. White Hat Hacker (Hacker m≈© tr·∫Øng).",
            "explanation": "T√†i li·ªáu (Ch 12, M·ª•c 5.2) ƒë·ªãnh nghƒ©a: 'White Hat Hacker: ethical hackers who test systems to improve security'. **M·∫πo ghi nh·ªõ: White Hat = Ethical = Ng∆∞·ªùi t·ªët.**"
        }
    },
    {
        "id": 287,
        "category": "Miscellaneous",
        "en": {
            "question": "An image can be represented in a computer using the ___ method.",
            "options": [
                "A. Bitmap graphic only",
                "B. Vector graphic only",
                "C. Excess system only",
                "D. Either bitmap or vector graphic"
            ],
            "answer": "D. Either bitmap or vector graphic",
            "explanation": "These are the two primary methods for representing 2D images. Bitmap (or raster) graphics use a grid of pixels, while vector graphics use mathematical equations to define shapes. **Key takeaway: Image representation = Bitmap or Vector.**"
        },
        "vi": {
            "question": "M·ªôt h√¨nh ·∫£nh c√≥ th·ªÉ ƒë∆∞·ª£c bi·ªÉu di·ªÖn trong m√°y t√≠nh b·∫±ng ph∆∞∆°ng ph√°p ___.",
            "options": [
                "A. Ch·ªâ ƒë·ªì h·ªça bitmap",
                "B. Ch·ªâ ƒë·ªì h·ªça vector",
                "C. Ch·ªâ h·ªá th·ªëng Excess",
                "D. Ho·∫∑c bitmap ho·∫∑c ƒë·ªì h·ªça vector"
            ],
            "answer": "D. Ho·∫∑c bitmap ho·∫∑c ƒë·ªì h·ªça vector",
            "explanation": "ƒê√¢y l√† hai ph∆∞∆°ng ph√°p ch√≠nh ƒë·ªÉ bi·ªÉu di·ªÖn h√¨nh ·∫£nh 2D. ƒê·ªì h·ªça bitmap (ho·∫∑c raster) s·ª≠ d·ª•ng m·ªôt l∆∞·ªõi c√°c pixel, trong khi ƒë·ªì h·ªça vector s·ª≠ d·ª•ng c√°c ph∆∞∆°ng tr√¨nh to√°n h·ªçc ƒë·ªÉ ƒë·ªãnh nghƒ©a c√°c h√¨nh d·∫°ng. **M·∫πo ghi nh·ªõ: Bi·ªÉu di·ªÖn h√¨nh ·∫£nh = Bitmap ho·∫∑c Vector.**"
        }
    },
    {
        "id": 288,
        "category": "Miscellaneous",
        "en": {
            "question": "In the ___ graphic method of representing an image, each pixel is assigned bit patterns.",
            "options": [
                "A. Bitmap",
                "B. Vector",
                "C. Quantized",
                "D. Binary"
            ],
            "answer": "A. Bitmap",
            "explanation": "Bitmap graphics (also called raster graphics) represent an image as a grid of pixels. The color of each pixel is defined by a specific bit pattern. **Key takeaway: Grid of pixels = Bitmap.**"
        },
        "vi": {
            "question": "Trong ph∆∞∆°ng ph√°p ƒë·ªì h·ªça ___ ƒë·ªÉ bi·ªÉu di·ªÖn m·ªôt h√¨nh ·∫£nh, m·ªói pixel ƒë∆∞·ª£c g√°n c√°c m·∫´u bit.",
            "options": [
                "A. Bitmap",
                "B. Vector",
                "C. L∆∞·ª£ng t·ª≠ h√≥a",
                "D. Nh·ªã ph√¢n"
            ],
            "answer": "A. Bitmap",
            "explanation": "ƒê·ªì h·ªça bitmap (c√≤n g·ªçi l√† ƒë·ªì h·ªça raster) bi·ªÉu di·ªÖn m·ªôt h√¨nh ·∫£nh d∆∞·ªõi d·∫°ng m·ªôt l∆∞·ªõi c√°c pixel. M√†u c·ªßa m·ªói pixel ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a b·ªüi m·ªôt m·∫´u bit c·ª• th·ªÉ. **M·∫πo ghi nh·ªõ: L∆∞·ªõi pixel = Bitmap.**"
        }
    },
    {
        "id": 289,
        "category": "Miscellaneous",
        "en": {
            "question": "In the ___ graphic method of representing an image, the image is decomposed into a combination of geometrical figures.",
            "options": [
                "A. Bitmap",
                "B. Vector",
                "C. Quantized",
                "D. Binary"
            ],
            "answer": "B. Vector",
            "explanation": "Vector graphics represent images using mathematical primitives like points, lines, curves, and polygons. This allows them to be scaled to any size without losing quality. **Key takeaway: Mathematical shapes = Vector.**"
        },
        "vi": {
            "question": "Trong ph∆∞∆°ng ph√°p ƒë·ªì h·ªça ___ ƒë·ªÉ bi·ªÉu di·ªÖn m·ªôt h√¨nh ·∫£nh, h√¨nh ·∫£nh ƒë∆∞·ª£c ph√¢n t√°ch th√†nh m·ªôt s·ª± k·∫øt h·ª£p c·ªßa c√°c h√¨nh h·ªçc.",
            "options": [
                "A. Bitmap",
                "B. Vector",
                "C. L∆∞·ª£ng t·ª≠ h√≥a",
                "D. Nh·ªã ph√¢n"
            ],
            "answer": "B. Vector",
            "explanation": "ƒê·ªì h·ªça vector bi·ªÉu di·ªÖn h√¨nh ·∫£nh b·∫±ng c√°ch s·ª≠ d·ª•ng c√°c nguy√™n th·ªßy to√°n h·ªçc nh∆∞ ƒëi·ªÉm, ƒë∆∞·ªùng, ƒë∆∞·ªùng cong v√† ƒëa gi√°c. ƒêi·ªÅu n√†y cho ph√©p ch√∫ng c√≥ th·ªÉ ƒë∆∞·ª£c thu ph√≥ng ƒë·∫øn b·∫•t k·ª≥ k√≠ch th∆∞·ªõc n√†o m√† kh√¥ng l√†m m·∫•t ch·∫•t l∆∞·ª£ng. **M·∫πo ghi nh·ªõ: H√¨nh d·∫°ng to√°n h·ªçc = Vector.**"
        }
    },
    {
        "id": 290,
        "category": "Miscellaneous",
        "en": {
            "question": "In the ___ graphic method of representing an image, re-scaling of the image creates a ragged or grainy image.",
            "options": [
                "A. Bitmap",
                "B. Vector",
                "C. Quantized",
                "D. Binary"
            ],
            "answer": "A. Bitmap",
            "explanation": "Because a bitmap is a fixed grid of pixels, enlarging it (re-scaling) forces the computer to guess the colors of the new pixels, which often results in a blocky, pixelated, or 'grainy' appearance. **Key takeaway: Scaling creates grainy image = Bitmap.**"
        },
        "vi": {
            "question": "Trong ph∆∞∆°ng ph√°p ƒë·ªì h·ªça ___ ƒë·ªÉ bi·ªÉu di·ªÖn m·ªôt h√¨nh ·∫£nh, vi·ªác thay ƒë·ªïi k√≠ch th∆∞·ªõc c·ªßa h√¨nh ·∫£nh t·∫°o ra m·ªôt h√¨nh ·∫£nh l·ªüm ch·ªüm ho·∫∑c b·ªã nhi·ªÖu h·∫°t.",
            "options": [
                "A. Bitmap",
                "B. Vector",
                "C. L∆∞·ª£ng t·ª≠ h√≥a",
                "D. Nh·ªã ph√¢n"
            ],
            "answer": "A. Bitmap",
            "explanation": "B·ªüi v√¨ m·ªôt bitmap l√† m·ªôt l∆∞·ªõi pixel c·ªë ƒë·ªãnh, vi·ªác ph√≥ng to n√≥ (thay ƒë·ªïi k√≠ch th∆∞·ªõc) bu·ªôc m√°y t√≠nh ph·∫£i ƒëo√°n m√†u c·ªßa c√°c pixel m·ªõi, ƒëi·ªÅu n√†y th∆∞·ªùng d·∫´n ƒë·∫øn m·ªôt v·∫ª ngo√†i kh·ªëi √¥ vu√¥ng, v·ª° n√©t ho·∫∑c 'nhi·ªÖu h·∫°t'. **M·∫πo ghi nh·ªõ: Thay ƒë·ªïi k√≠ch th∆∞·ªõc l√†m ·∫£nh v·ª° n√©t = Bitmap.**"
        }
    },
    {
        "id": 291,
        "category": "Miscellaneous",
        "en": {
            "question": "In storing images, what is the technique used to encode a pixel using Red, Green, and Blue values?",
            "options": [
                "A. True-color",
                "B. index-color",
                "C. resolution",
                "D. color depth"
            ],
            "answer": "A. True-color",
            "explanation": "True-color, typically 24-bit, stores the color of each pixel by directly specifying the intensity values for the three primary colors: Red, Green, and Blue (RGB). Each component usually gets 8 bits. **Key takeaway: RGB values per pixel = True-color.**"
        },
        "vi": {
            "question": "Trong vi·ªác l∆∞u tr·ªØ h√¨nh ·∫£nh, k·ªπ thu·∫≠t n√†o ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ m√£ h√≥a m·ªôt pixel b·∫±ng c√°ch s·ª≠ d·ª•ng c√°c gi√° tr·ªã ƒê·ªè, Xanh l√°, v√† Xanh d∆∞∆°ng?",
            "options": [
                "A. M√†u th·ª±c (True-color)",
                "B. M√†u ch·ªâ m·ª•c (index-color)",
                "C. ƒê·ªô ph√¢n gi·∫£i",
                "D. ƒê·ªô s√¢u m√†u"
            ],
            "answer": "A. M√†u th·ª±c (True-color)",
            "explanation": "M√†u th·ª±c, th∆∞·ªùng l√† 24-bit, l∆∞u tr·ªØ m√†u c·ªßa m·ªói pixel b·∫±ng c√°ch ch·ªâ ƒë·ªãnh tr·ª±c ti·∫øp c√°c gi√° tr·ªã c∆∞·ªùng ƒë·ªô cho ba m√†u c∆° b·∫£n: ƒê·ªè, Xanh l√° v√† Xanh d∆∞∆°ng (RGB). M·ªói th√†nh ph·∫ßn th∆∞·ªùng c√≥ 8 bit. **M·∫πo ghi nh·ªõ: Gi√° tr·ªã RGB cho m·ªói pixel = M√†u th·ª±c.**"
        }
    },
    {
        "id": 292,
        "category": "Miscellaneous",
        "en": {
            "question": "When we want to store music in a computer, the audio signal must be _____.",
            "options": [
                "A. sampled, quantized, and coded",
                "B. compressed and encrypted",
                "C. loud and clear",
                "D. converted to MIDI"
            ],
            "answer": "A. sampled, quantized, and coded",
            "explanation": "This is the three-step process of converting an analog audio signal to a digital one. Sampling takes measurements at regular intervals, Quantization rounds these measurements to discrete values, and Coding converts these values into binary bit patterns. **Key takeaway: Analog to Digital Audio = Sample, Quantize, Code.**"
        },
        "vi": {
            "question": "Khi ch√∫ng ta mu·ªën l∆∞u tr·ªØ √¢m nh·∫°c trong m√°y t√≠nh, t√≠n hi·ªáu √¢m thanh ph·∫£i ƒë∆∞·ª£c _____.",
            "options": [
                "A. l·∫•y m·∫´u, l∆∞·ª£ng t·ª≠ h√≥a, v√† m√£ h√≥a",
                "B. n√©n v√† m√£ h√≥a",
                "C. to v√† r√µ",
                "D. chuy·ªÉn ƒë·ªïi sang MIDI"
            ],
            "answer": "A. l·∫•y m·∫´u, l∆∞·ª£ng t·ª≠ h√≥a, v√† m√£ h√≥a",
            "explanation": "ƒê√¢y l√† quy tr√¨nh ba b∆∞·ªõc ƒë·ªÉ chuy·ªÉn ƒë·ªïi m·ªôt t√≠n hi·ªáu √¢m thanh analog th√†nh t√≠n hi·ªáu s·ªë. L·∫•y m·∫´u th·ª±c hi·ªán c√°c ph√©p ƒëo t·∫°i c√°c kho·∫£ng th·ªùi gian ƒë·ªÅu ƒë·∫∑n, L∆∞·ª£ng t·ª≠ h√≥a l√†m tr√≤n c√°c ph√©p ƒëo n√†y th√†nh c√°c gi√° tr·ªã r·ªùi r·∫°c, v√† M√£ h√≥a chuy·ªÉn ƒë·ªïi c√°c gi√° tr·ªã n√†y th√†nh c√°c m·∫´u bit nh·ªã ph√¢n. **M·∫πo ghi nh·ªõ: √Çm thanh Analog sang Digital = L·∫•y m·∫´u, L∆∞·ª£ng t·ª≠ h√≥a, M√£ h√≥a.**"
        }
    },
    {
        "id": 293,
        "category": "Miscellaneous",
        "en": {
            "question": "_______ refers to a process that rounds the value of a sample to the closest integer value.",
            "options": [
                "A. Quantization",
                "B. Sampling rate",
                "C. Bit depth",
                "D. Encoding"
            ],
            "answer": "A. Quantization",
            "explanation": "This is a repeated concept. Quantization is the step in analog-to-digital conversion where the continuous range of values from the sampling process is mapped to a finite set of discrete (integer) values. **Key takeaway: Rounding sample values = Quantization.**"
        },
        "vi": {
            "question": "_______ ƒë·ªÅ c·∫≠p ƒë·∫øn m·ªôt qu√° tr√¨nh l√†m tr√≤n gi√° tr·ªã c·ªßa m·ªôt m·∫´u ƒë·∫øn gi√° tr·ªã s·ªë nguy√™n g·∫ßn nh·∫•t.",
            "options": [
                "A. L∆∞·ª£ng t·ª≠ h√≥a",
                "B. T·∫ßn s·ªë l·∫•y m·∫´u",
                "C. ƒê·ªô s√¢u bit",
                "D. M√£ h√≥a"
            ],
            "answer": "A. L∆∞·ª£ng t·ª≠ h√≥a",
            "explanation": "ƒê√¢y l√† m·ªôt kh√°i ni·ªám l·∫∑p l·∫°i. L∆∞·ª£ng t·ª≠ h√≥a l√† b∆∞·ªõc trong qu√° tr√¨nh chuy·ªÉn ƒë·ªïi analog-sang-digital, n∆°i d·∫£i gi√° tr·ªã li√™n t·ª•c t·ª´ qu√° tr√¨nh l·∫•y m·∫´u ƒë∆∞·ª£c √°nh x·∫° v√†o m·ªôt t·∫≠p h·ª£p h·ªØu h·∫°n c√°c gi√° tr·ªã r·ªùi r·∫°c (s·ªë nguy√™n). **M·∫πo ghi nh·ªõ: L√†m tr√≤n gi√° tr·ªã m·∫´u = L∆∞·ª£ng t·ª≠ h√≥a.**"
        }
    },
    {
        "id": 294,
        "category": "Miscellaneous",
        "en": {
            "question": "A floating-point value after normalization is (1.0101)‚ÇÇ √ó 2‚Åª‚Å¥. What is the value of the exponent section in the Excess-127 representation?",
            "options": [
                "A. 122",
                "B. 123",
                "C. 124",
                "D. 131"
            ],
            "answer": "B. 123",
            "explanation": "In Excess-127 representation (used for single-precision floats), the stored exponent is calculated as: Stored Value = Actual Exponent + Bias. Here, the actual exponent is -4 and the bias is 127. So, Stored Value = -4 + 127 = 123. **Key takeaway: Stored Exponent = Actual Exponent + 127.**"
        },
        "vi": {
            "question": "M·ªôt gi√° tr·ªã d·∫•u ph·∫©y ƒë·ªông sau khi chu·∫©n h√≥a l√† (1.0101)‚ÇÇ √ó 2‚Åª‚Å¥. Gi√° tr·ªã c·ªßa ph·∫ßn m≈© trong bi·ªÉu di·ªÖn Excess-127 l√† g√¨?",
            "options": [
                "A. 122",
                "B. 123",
                "C. 124",
                "D. 131"
            ],
            "answer": "B. 123",
            "explanation": "Trong bi·ªÉu di·ªÖn Excess-127 (ƒë∆∞·ª£c s·ª≠ d·ª•ng cho s·ªë th·ª±c ƒë·ªô ch√≠nh x√°c ƒë∆°n), ph·∫ßn m≈© ƒë∆∞·ª£c l∆∞u tr·ªØ ƒë∆∞·ª£c t√≠nh nh∆∞ sau: Gi√° tr·ªã l∆∞u tr·ªØ = M≈© th·ª±c t·∫ø + ƒê·ªô l·ªách. ·ªû ƒë√¢y, m≈© th·ª±c t·∫ø l√† -4 v√† ƒë·ªô l·ªách l√† 127. V√¨ v·∫≠y, Gi√° tr·ªã l∆∞u tr·ªØ = -4 + 127 = 123. **M·∫πo ghi nh·ªõ: M≈© l∆∞u tr·ªØ = M≈© th·ª±c t·∫ø + 127.**"
        }
    },
    {
        "id": 295,
        "category": "Miscellaneous",
        "en": {
            "question": "Assume a new Excess system uses 17 bits to represent the exponent section. What is the bias value in this system?",
            "options": [
                "A. 17",
                "B. 16",
                "C. 65535",
                "D. 65536"
            ],
            "answer": "C. 65535",
            "explanation": "The bias for an n-bit excess system is calculated as 2^(n-1) - 1. For a 17-bit system, n=17. The bias is 2^(17-1) - 1 = 2^16 - 1 = 65536 - 1 = 65535. **Key takeaway: Bias = 2^(n-1) - 1.**"
        },
        "vi": {
            "question": "Gi·∫£ s·ª≠ m·ªôt h·ªá th·ªëng Excess m·ªõi s·ª≠ d·ª•ng 17 bit ƒë·ªÉ bi·ªÉu di·ªÖn ph·∫ßn m≈©. Gi√° tr·ªã ƒë·ªô l·ªách trong h·ªá th·ªëng n√†y l√† g√¨?",
            "options": [
                "A. 17",
                "B. 16",
                "C. 65535",
                "D. 65536"
            ],
            "answer": "C. 65535",
            "explanation": "ƒê·ªô l·ªách cho m·ªôt h·ªá th·ªëng excess n-bit ƒë∆∞·ª£c t√≠nh b·∫±ng c√¥ng th·ª©c 2^(n-1) - 1. ƒê·ªëi v·ªõi m·ªôt h·ªá th·ªëng 17-bit, n=17. ƒê·ªô l·ªách l√† 2^(17-1) - 1 = 2^16 - 1 = 65536 - 1 = 65535. **M·∫πo ghi nh·ªõ: ƒê·ªô l·ªách = 2^(n-1) - 1.**"
        }
    },
    {
        "id": 296,
        "category": "Miscellaneous",
        "en": {
            "question": "Which number representation method is often used to store the exponential value of a fractional part?",
            "options": [
                "A. Unsigned integers",
                "B. Two's complement",
                "C. Excess",
                "D. Ten's complement"
            ],
            "answer": "C. Excess",
            "explanation": "Excess (or biased) representation is standard for storing the exponent in floating-point numbers (like IEEE 754). It allows for easy comparison of exponents because the magnitude of the stored values directly corresponds to the magnitude of the actual exponents. **Key takeaway: Floating-point exponent = Excess representation.**"
        },
        "vi": {
            "question": "Ph∆∞∆°ng ph√°p bi·ªÉu di·ªÖn s·ªë n√†o th∆∞·ªùng ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ l∆∞u tr·ªØ gi√° tr·ªã m≈© c·ªßa m·ªôt ph·∫ßn ph√¢n s·ªë?",
            "options": [
                "A. S·ªë nguy√™n kh√¥ng d·∫•u",
                "B. B√π hai",
                "C. Excess (L·ªách)",
                "D. B√π m∆∞·ªùi"
            ],
            "answer": "C. Excess (L·ªách)",
            "explanation": "Bi·ªÉu di·ªÖn Excess (ho·∫∑c l·ªách) l√† ti√™u chu·∫©n ƒë·ªÉ l∆∞u tr·ªØ ph·∫ßn m≈© trong c√°c s·ªë d·∫•u ph·∫©y ƒë·ªông (nh∆∞ IEEE 754). N√≥ cho ph√©p so s√°nh d·ªÖ d√†ng c√°c ph·∫ßn m≈© v√¨ ƒë·ªô l·ªõn c·ªßa c√°c gi√° tr·ªã ƒë∆∞·ª£c l∆∞u tr·ªØ t∆∞∆°ng ·ª©ng tr·ª±c ti·∫øp v·ªõi ƒë·ªô l·ªõn c·ªßa c√°c ph·∫ßn m≈© th·ª±c t·∫ø. **M·∫πo ghi nh·ªõ: M≈© c·ªßa s·ªë th·ª±c = Bi·ªÉu di·ªÖn Excess.**"
        }
    },
    {
        "id": 297,
        "category": "Miscellaneous",
        "en": {
            "question": "When a fractional part is normalized, the computer stores the ___.",
            "options": [
                "A. Only the sign",
                "B. Only the exponent",
                "C. Only the mantissa",
                "D. The sign, exponent, and mantissa"
            ],
            "answer": "D. The sign, exponent, and mantissa",
            "explanation": "The standard floating-point representation consists of three parts: the sign bit (positive or negative), the exponent (which determines the magnitude or range), and the mantissa (or significand, which determines the precision). **Key takeaway: Floating-point number = Sign + Exponent + Mantissa.**"
        },
        "vi": {
            "question": "Khi m·ªôt ph·∫ßn ph√¢n s·ªë ƒë∆∞·ª£c chu·∫©n h√≥a, m√°y t√≠nh l∆∞u tr·ªØ ___.",
            "options": [
                "A. Ch·ªâ d·∫•u",
                "B. Ch·ªâ ph·∫ßn m≈©",
                "C. Ch·ªâ ph·∫ßn ƒë·ªãnh tr·ªã",
                "D. D·∫•u, ph·∫ßn m≈©, v√† ph·∫ßn ƒë·ªãnh tr·ªã"
            ],
            "answer": "D. D·∫•u, ph·∫ßn m≈©, v√† ph·∫ßn ƒë·ªãnh tr·ªã",
            "explanation": "Bi·ªÉu di·ªÖn d·∫•u ph·∫©y ƒë·ªông ti√™u chu·∫©n bao g·ªìm ba ph·∫ßn: bit d·∫•u (d∆∞∆°ng ho·∫∑c √¢m), ph·∫ßn m≈© (x√°c ƒë·ªãnh ƒë·ªô l·ªõn ho·∫∑c ph·∫°m vi), v√† ph·∫ßn ƒë·ªãnh tr·ªã (hay significand, x√°c ƒë·ªãnh ƒë·ªô ch√≠nh x√°c). **M·∫πo ghi nh·ªõ: S·ªë d·∫•u ph·∫©y ƒë·ªông = D·∫•u + M≈© + ƒê·ªãnh tr·ªã.**"
        }
    },
    {
        "id": 298,
        "category": "Miscellaneous",
        "en": {
            "question": "The precision of the fractional part of a number stored in a computer is defined by the ___.",
            "options": [
                "A. Sign",
                "B. Exponent",
                "C. Mantissa",
                "D. Last digit"
            ],
            "answer": "C. Mantissa",
            "explanation": "In floating-point representation, the mantissa (or significand) holds the significant digits of the number. A longer mantissa allows for more bits of precision. The exponent determines the range (how large or small the number can be). **Key takeaway: Precision = Mantissa. Range = Exponent.**"
        },
        "vi": {
            "question": "ƒê·ªô ch√≠nh x√°c c·ªßa ph·∫ßn ph√¢n s·ªë c·ªßa m·ªôt s·ªë ƒë∆∞·ª£c l∆∞u tr·ªØ trong m√°y t√≠nh ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a b·ªüi ___.",
            "options": [
                "A. D·∫•u",
                "B. Ph·∫ßn m≈©",
                "C. Ph·∫ßn ƒë·ªãnh tr·ªã",
                "D. Ch·ªØ s·ªë cu·ªëi c√πng"
            ],
            "answer": "C. Ph·∫ßn ƒë·ªãnh tr·ªã",
            "explanation": "Trong bi·ªÉu di·ªÖn d·∫•u ph·∫©y ƒë·ªông, ph·∫ßn ƒë·ªãnh tr·ªã (hay significand) gi·ªØ c√°c ch·ªØ s·ªë c√≥ nghƒ©a c·ªßa s·ªë. M·ªôt ph·∫ßn ƒë·ªãnh tr·ªã d√†i h∆°n cho ph√©p c√≥ nhi·ªÅu bit ch√≠nh x√°c h∆°n. Ph·∫ßn m≈© x√°c ƒë·ªãnh ph·∫°m vi (s·ªë c√≥ th·ªÉ l·ªõn hay nh·ªè ƒë·∫øn m·ª©c n√†o). **M·∫πo ghi nh·ªõ: ƒê·ªô ch√≠nh x√°c = ƒê·ªãnh tr·ªã. Ph·∫°m vi = M≈©.**"
        }
    },
    {
        "id": 299,
        "category": "Miscellaneous",
        "en": {
            "question": "___ is an arithmetic operation.",
            "options": [
                "A. The exclusive OR",
                "B. The unary NOT",
                "C. Subtraction",
                "D. The binary AND"
            ],
            "answer": "C. Subtraction",
            "explanation": "Subtraction (along with addition, multiplication, division) is a fundamental arithmetic operation. OR, NOT, and AND are logical bitwise operations. **Key takeaway: Arithmetic = +, -, *, /. Logical = AND, OR, NOT, XOR.**"
        },
        "vi": {
            "question": "___ l√† m·ªôt ph√©p to√°n s·ªë h·ªçc.",
            "options": [
                "A. Ph√©p OR lo·∫°i tr·ª´",
                "B. Ph√©p NOT m·ªôt ng√¥i",
                "C. Ph√©p tr·ª´",
                "D. Ph√©p AND nh·ªã ph√¢n"
            ],
            "answer": "C. Ph√©p tr·ª´",
            "explanation": "Ph√©p tr·ª´ (c√πng v·ªõi c·ªông, nh√¢n, chia) l√† m·ªôt ph√©p to√°n s·ªë h·ªçc c∆° b·∫£n. OR, NOT, v√† AND l√† c√°c ph√©p to√°n logic tr√™n bit. **M·∫πo ghi nh·ªõ: S·ªë h·ªçc = +, -, *, /. Logic = AND, OR, NOT, XOR.**"
        }
    },
    {
        "id": 300,
        "category": "Miscellaneous",
        "en": {
            "question": "___ is a logical bit operator.",
            "options": [
                "A. The exclusive OR",
                "B. The unary NOT",
                "C. The binary AND",
                "D. Exclusive OR, unary NOT, or binary AND"
            ],
            "answer": "D. Exclusive OR, unary NOT, or binary AND",
            "explanation": "All of the listed options (XOR, NOT, AND) are fundamental logical bitwise operators used to manipulate bit patterns. **Key takeaway: AND, OR, NOT, XOR are all logical operators.**"
        },
        "vi": {
            "question": "___ l√† m·ªôt to√°n t·ª≠ bit logic.",
            "options": [
                "A. Ph√©p OR lo·∫°i tr·ª´",
                "B. Ph√©p NOT m·ªôt ng√¥i",
                "C. Ph√©p AND nh·ªã ph√¢n",
                "D. OR lo·∫°i tr·ª´, NOT m·ªôt ng√¥i, ho·∫∑c AND nh·ªã ph√¢n"
            ],
            "answer": "D. OR lo·∫°i tr·ª´, NOT m·ªôt ng√¥i, ho·∫∑c AND nh·ªã ph√¢n",
            "explanation": "T·∫•t c·∫£ c√°c l·ª±a ch·ªçn ƒë∆∞·ª£c li·ªát k√™ (XOR, NOT, AND) ƒë·ªÅu l√† c√°c to√°n t·ª≠ bit logic c∆° b·∫£n ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ thao t√°c c√°c m·∫´u bit. **M·∫πo ghi nh·ªõ: AND, OR, NOT, XOR ƒë·ªÅu l√† c√°c to√°n t·ª≠ logic.**"
        }
    },
    {
        "id": 301,
        "category": "Miscellaneous",
        "en": {
            "question": "We use a bit pattern called a _______ to modify another bit pattern.",
            "options": [
                "A. Mask",
                "B. Carry",
                "C. Float",
                "D. Byte"
            ],
            "answer": "A. Mask",
            "explanation": "A mask is a bit pattern used with logical operations (like AND, OR, XOR) to select, set, or clear specific bits in another bit pattern. For example, ANDing with `00001111` 'masks out' the upper 4 bits and keeps the lower 4 bits. **Key takeaway: Bit pattern for modifying another = Mask.**"
        },
        "vi": {
            "question": "Ch√∫ng ta s·ª≠ d·ª•ng m·ªôt m·∫´u bit ƒë∆∞·ª£c g·ªçi l√† _______ ƒë·ªÉ s·ª≠a ƒë·ªïi m·ªôt m·∫´u bit kh√°c.",
            "options": [
                "A. M·∫∑t n·∫° (Mask)",
                "B. S·ªë nh·ªõ (Carry)",
                "C. S·ªë th·ª±c (Float)",
                "D. Byte"
            ],
            "answer": "A. M·∫∑t n·∫° (Mask)",
            "explanation": "M·∫∑t n·∫° l√† m·ªôt m·∫´u bit ƒë∆∞·ª£c s·ª≠ d·ª•ng v·ªõi c√°c ph√©p to√°n logic (nh∆∞ AND, OR, XOR) ƒë·ªÉ ch·ªçn, thi·∫øt l·∫≠p ho·∫∑c x√≥a c√°c bit c·ª• th·ªÉ trong m·ªôt m·∫´u bit kh√°c. V√≠ d·ª•, th·ª±c hi·ªán ph√©p AND v·ªõi `00001111` s·∫Ω 'che ƒëi' 4 bit tr√™n v√† gi·ªØ l·∫°i 4 bit d∆∞·ªõi. **M·∫πo ghi nh·ªõ: M·∫´u bit ƒë·ªÉ s·ª≠a ƒë·ªïi m·∫´u kh√°c = M·∫∑t n·∫°.**"
        }
    },
    {
        "id": 302,
        "category": "Miscellaneous",
        "en": {
            "question": "Which is a unit representing the number of signal changes per second?",
            "options": [
                "A. Baud",
                "B. Byte",
                "C. Bit",
                "D. Hertz"
            ],
            "answer": "A. Baud",
            "explanation": "Baud rate specifically measures the number of distinct symbol changes (or signaling events) per second on a communication line. While often related to bits per second, they are not the same; one symbol can encode multiple bits. Hertz (Hz) measures cycles per second in a general sense. **Key takeaway: Signal changes per second = Baud.**"
        },
        "vi": {
            "question": "ƒê∆°n v·ªã n√†o bi·ªÉu th·ªã s·ªë l·∫ßn thay ƒë·ªïi t√≠n hi·ªáu m·ªói gi√¢y?",
            "options": [
                "A. Baud",
                "B. Byte",
                "C. Bit",
                "D. Hertz"
            ],
            "answer": "A. Baud",
            "explanation": "T·ªëc ƒë·ªô baud ƒëo l∆∞·ªùng c·ª• th·ªÉ s·ªë l·∫ßn thay ƒë·ªïi k√Ω hi·ªáu ri√™ng bi·ªát (ho·∫∑c c√°c s·ª± ki·ªán t√≠n hi·ªáu) m·ªói gi√¢y tr√™n m·ªôt ƒë∆∞·ªùng truy·ªÅn th√¥ng. M·∫∑c d√π th∆∞·ªùng li√™n quan ƒë·∫øn bit m·ªói gi√¢y, ch√∫ng kh√¥ng gi·ªëng nhau; m·ªôt k√Ω hi·ªáu c√≥ th·ªÉ m√£ h√≥a nhi·ªÅu bit. Hertz (Hz) ƒëo chu k·ª≥ m·ªói gi√¢y theo nghƒ©a chung. **M·∫πo ghi nh·ªõ: S·ªë l·∫ßn thay ƒë·ªïi t√≠n hi·ªáu m·ªói gi√¢y = Baud.**"
        }
    },
    {
        "id": 303,
        "category": "Chapter 12: Security and Ethical Issues (B·∫£o m·∫≠t & V·∫•n ƒë·ªÅ ƒë·∫°o ƒë·ª©c)",
        "en": {
            "question": "Which type of hacker is described as an 'ethical hacker' who tests systems to improve security?",
            "options": [
                "A. Black Hat Hacker.",
                "B. White Hat Hacker.",
                "C. Grey Hat Hacker.",
                "D. Blue Hat Hacker."
            ],
            "answer": "B. White Hat Hacker.",
            "explanation": "White hat hackers are security professionals who are employed or contracted to find vulnerabilities in systems. They operate with permission and their goal is to help organizations strengthen their security posture. **Key takeaway: White Hat = Ethical = The good guys.**"
        },
        "vi": {
            "question": "Lo·∫°i hacker n√†o ƒë∆∞·ª£c m√¥ t·∫£ l√† 'hacker ƒë·∫°o ƒë·ª©c' (ethical hackers), nh·ªØng ng∆∞·ªùi ki·ªÉm tra h·ªá th·ªëng ƒë·ªÉ tƒÉng c∆∞·ªùng b·∫£o m·∫≠t?",
            "options": [
                "A. Black Hat Hacker (Hacker m≈© ƒëen).",
                "B. White Hat Hacker (Hacker m≈© tr·∫Øng).",
                "C. Grey Hat Hacker (Hacker m≈© x√°m).",
                "D. Blue Hat Hacker (Hacker m≈© xanh)."
            ],
            "answer": "B. White Hat Hacker (Hacker m≈© tr·∫Øng).",
            "explanation": "T√†i li·ªáu (Ch 12, M·ª•c 5.2) ƒë·ªãnh nghƒ©a: 'White Hat Hacker: ethical hackers who test systems to improve security'. **M·∫πo ghi nh·ªõ: White Hat = Ethical = Ng∆∞·ªùi t·ªët.**"
        }
    },
    {
        "id": 304,
        "category": "Chapter 11: Databases (C∆° s·ªü d·ªØ li·ªáu)",
        "en": {
            "question": "In the three-level ANSI/SPARC DBMS architecture model, which level is responsible for defining the logical structure of the entire database and hiding physical details?",
            "options": [
                "A. Internal Level.",
                "B. External Level.",
                "C. Conceptual Level.",
                "D. Physical Level."
            ],
            "answer": "C. Conceptual Level.",
            "explanation": "The Conceptual Level provides a global, community view of the database. It describes all entities, attributes, and relationships, independent of how the data is physically stored or how users view it. **Key takeaway: Conceptual = Overall logical structure of the DB.**"
        },
        "vi": {
            "question": "Trong m√¥ h√¨nh ki·∫øn tr√∫c DBMS ba t·∫ßng ANSI/SPARC, t·∫ßng n√†o ch·ªãu tr√°ch nhi·ªám ƒë·ªãnh nghƒ©a c·∫•u tr√∫c logic c·ªßa to√†n b·ªô c∆° s·ªü d·ªØ li·ªáu v√† che gi·∫•u c√°c chi ti·∫øt v·∫≠t l√Ω?",
            "options": [
                "A. Internal Level (T·∫ßng n·ªôi b·ªô).",
                "B. External Level (T·∫ßng ngo·∫°i vi).",
                "C. Conceptual Level (T·∫ßng kh√°i ni·ªám).",
                "D. Physical Level (T·∫ßng v·∫≠t l√Ω)."
            ],
            "answer": "C. Conceptual Level (T·∫ßng kh√°i ni·ªám).",
            "explanation": "T√†i li·ªáu (Ch 11, M·ª•c 2.3) ƒë·ªãnh nghƒ©a Conceptual Level l√† 'Defines the logical structure of the entire database, hiding physical details'. **M·∫πo ghi nh·ªõ: Conceptual = Logic t·ªïng th·ªÉ c·ªßa CSDL.**"
        }
    },
    {
        "id": 305,
        "category": "Chapter 9: Data Structures (C·∫•u tr√∫c d·ªØ li·ªáu)",
        "en": {
            "question": "In a Linked List, what identifies the first element?",
            "options": [
                "A. An index of 0.",
                "B. A pointer variable, which is also the name of the list.",
                "C. The address of the last element.",
                "D. The number of elements in the list."
            ],
            "answer": "B. A pointer variable, which is also the name of the list.",
            "explanation": "A linked list is accessed via its head pointer. This pointer holds the memory address of the first node and is the sole entry point to traverse the entire list. **Key takeaway: Head Pointer = The starting point of a linked list.**"
        },
        "vi": {
            "question": "Trong m·ªôt danh s√°ch li√™n k·∫øt (Linked List), ph·∫ßn t·ª≠ ƒë·∫ßu ti√™n ƒë∆∞·ª£c x√°c ƒë·ªãnh b·ªüi c√°i g√¨?",
            "options": [
                "A. M·ªôt ch·ªâ s·ªë (index) b·∫±ng 0.",
                "B. M·ªôt bi·∫øn con tr·ªè (a pointer variable), c≈©ng l√† t√™n c·ªßa danh s√°ch.",
                "C. ƒê·ªãa ch·ªâ c·ªßa ph·∫ßn t·ª≠ cu·ªëi c√πng.",
                "D. S·ªë l∆∞·ª£ng c√°c ph·∫ßn t·ª≠ trong danh s√°ch."
            ],
            "answer": "B. M·ªôt bi·∫øn con tr·ªè (a pointer variable), c≈©ng l√† t√™n c·ªßa danh s√°ch.",
            "explanation": "T√†i li·ªáu (Ch 9, M·ª•c 3.1) n√™u: 'The first element is identified by a pointer variable (the list's name)'. Con tr·ªè ƒë·∫ßu n√†y l√† c·ªïng v√†o duy nh·∫•t c·ªßa to√†n b·ªô danh s√°ch. **M·∫πo ghi nh·ªõ: Con tr·ªè ƒë·∫ßu (Head Pointer) = ƒêi·ªÉm b·∫Øt ƒë·∫ßu c·ªßa danh s√°ch li√™n k·∫øt.**"
        }
    },
    {
        "id": 311,
        "category": "Chapter 10: File Structure (C·∫•u tr√∫c t·ªáp)",
        "en": {
            "question": "Which file type stores data in the computer's internal format (integers, floats, media) and is generally not human-readable?",
            "options": [
                "A. Text File.",
                "B. Binary File.",
                "C. Sequential File.",
                "D. Indexed File."
            ],
            "answer": "B. Binary File.",
            "explanation": "Binary files store data as raw sequences of bytes, exactly as they are represented in memory. This is efficient for the computer but requires a specific program to decode and understand the data. **Key takeaway: Binary File = Raw computer data, not human-readable.**"
        },
        "vi": {
            "question": "T·ªáp tin n√†o l∆∞u tr·ªØ d·ªØ li·ªáu theo ƒë·ªãnh d·∫°ng n·ªôi b·ªô c·ªßa m√°y t√≠nh (s·ªë nguy√™n, s·ªë th·ª±c, media) v√† th∆∞·ªùng kh√¥ng th·ªÉ ƒë·ªçc ƒë∆∞·ª£c tr·ª±c ti·∫øp b·ªüi con ng∆∞·ªùi?",
            "options": [
                "A. Text File (T·ªáp vƒÉn b·∫£n).",
                "B. Binary File (T·ªáp nh·ªã ph√¢n).",
                "C. Sequential File (T·ªáp tu·∫ßn t·ª±).",
                "D. Indexed File (T·ªáp ch·ªâ m·ª•c)."
            ],
            "answer": "B. Binary File (T·ªáp nh·ªã ph√¢n).",
            "explanation": "T√†i li·ªáu (Ch 10, M·ª•c 2.3) m√¥ t·∫£ t·ªáp nh·ªã ph√¢n 'Store data in the computer's internal format' v√† 'Not human-readable without proper decoding'. **M·∫πo ghi nh·ªõ: Binary File = D·ªØ li·ªáu th√¥ c·ªßa m√°y t√≠nh, ng∆∞·ªùi kh√¥ng ƒë·ªçc tr·ª±c ti·∫øp ƒë∆∞·ª£c.**"
        }
    },
    {
        "id": 306,
        "category": "Chapter 10: File Structure (C·∫•u tr√∫c t·ªáp)",
        "en": {
            "question": "A _______ is a collection of data stored in the internal format of the computer. This contains data that is meaningful only if it is properly interpreted by a program.",
            "options": [
                "A. Text file",
                "B. Binary file",
                "C. Sequential file",
                "D. EOF"
            ],
            "answer": "B. Binary file",
            "explanation": "A binary file stores data in the same raw, binary format that the computer uses internally (e.g., 32-bit integers, IEEE 754 floats). It is not human-readable without a program that knows how to interpret these formats. **Key takeaway: Raw, non-human-readable data = Binary file.**"
        },
        "vi": {
            "question": "M·ªôt _______ l√† m·ªôt t·∫≠p h·ª£p d·ªØ li·ªáu ƒë∆∞·ª£c l∆∞u tr·ªØ theo ƒë·ªãnh d·∫°ng n·ªôi b·ªô c·ªßa m√°y t√≠nh. N√≥ ch·ª©a d·ªØ li·ªáu ch·ªâ c√≥ √Ω nghƒ©a n·∫øu ƒë∆∞·ª£c m·ªôt ch∆∞∆°ng tr√¨nh di·ªÖn gi·∫£i ƒë√∫ng c√°ch.",
            "options": [
                "A. T·ªáp vƒÉn b·∫£n",
                "B. T·ªáp nh·ªã ph√¢n",
                "C. T·ªáp tu·∫ßn t·ª±",
                "D. EOF"
            ],
            "answer": "B. T·ªáp nh·ªã ph√¢n",
            "explanation": "M·ªôt t·ªáp nh·ªã ph√¢n l∆∞u tr·ªØ d·ªØ li·ªáu ·ªü c√πng ƒë·ªãnh d·∫°ng nh·ªã ph√¢n th√¥ m√† m√°y t√≠nh s·ª≠ d·ª•ng n·ªôi b·ªô (v√≠ d·ª•: s·ªë nguy√™n 32-bit, s·ªë th·ª±c IEEE 754). Con ng∆∞·ªùi kh√¥ng th·ªÉ ƒë·ªçc ƒë∆∞·ª£c n√≥ n·∫øu kh√¥ng c√≥ m·ªôt ch∆∞∆°ng tr√¨nh bi·∫øt c√°ch di·ªÖn gi·∫£i c√°c ƒë·ªãnh d·∫°ng n√†y. **M·∫πo ghi nh·ªõ: D·ªØ li·ªáu th√¥, kh√¥ng th·ªÉ ƒë·ªçc b·ªüi ng∆∞·ªùi = T·ªáp nh·ªã ph√¢n.**"
        }
    },
    {
        "id": 307,
        "category": "Chapter 10: File Structure (C·∫•u tr√∫c t·ªáp)",
        "en": {
            "question": "_______ are provided by most operating systems for organizing files. This performs the same function as a folder in a filing cabinet.",
            "options": [
                "A. Operating system",
                "B. Files",
                "C. Binary files",
                "D. Directories"
            ],
            "answer": "D. Directories",
            "explanation": "Directories, also known as folders, are a feature of the file system that allow for the hierarchical organization of files. **Key takeaway: File organization structure = Directory/Folder.**"
        },
        "vi": {
            "question": "_______ ƒë∆∞·ª£c cung c·∫•p b·ªüi h·∫ßu h·∫øt c√°c h·ªá ƒëi·ªÅu h√†nh ƒë·ªÉ t·ªï ch·ª©c c√°c t·ªáp. Ch√∫ng th·ª±c hi·ªán ch·ª©c nƒÉng t∆∞∆°ng t·ª± nh∆∞ m·ªôt th∆∞ m·ª•c trong t·ªß h·ªì s∆°.",
            "options": [
                "A. H·ªá ƒëi·ªÅu h√†nh",
                "B. T·ªáp",
                "C. T·ªáp nh·ªã ph√¢n",
                "D. Th∆∞ m·ª•c"
            ],
            "answer": "D. Th∆∞ m·ª•c",
            "explanation": "Th∆∞ m·ª•c, c√≤n ƒë∆∞·ª£c g·ªçi l√† folder, l√† m·ªôt t√≠nh nƒÉng c·ªßa h·ªá th·ªëng t·ªáp cho ph√©p t·ªï ch·ª©c c√°c t·ªáp theo c·∫•u tr√∫c ph√¢n c·∫•p. **M·∫πo ghi nh·ªõ: C·∫•u tr√∫c t·ªï ch·ª©c t·ªáp = Th∆∞ m·ª•c (Directory/Folder).**"
        }
    },
    {
        "id": 308,
        "category": "Chapter 10: File Structure (C·∫•u tr√∫c t·ªáp)",
        "en": {
            "question": "In the sequential file we process the records one by one. After the operating system processes the last record the _______ is detected and the loop is exited.",
            "options": [
                "A. Hashed file",
                "B. Sequential file",
                "C. EOF",
                "D. None of others"
            ],
            "answer": "C. EOF",
            "explanation": "EOF stands for End-Of-File. It is a special marker or condition that the operating system uses to signal that there is no more data to be read from a file. **Key takeaway: Marker at end of file = EOF.**"
        },
        "vi": {
            "question": "Trong t·ªáp tu·∫ßn t·ª±, ch√∫ng ta x·ª≠ l√Ω c√°c b·∫£n ghi l·∫ßn l∆∞·ª£t. Sau khi h·ªá ƒëi·ªÅu h√†nh x·ª≠ l√Ω b·∫£n ghi cu·ªëi c√πng, _______ ƒë∆∞·ª£c ph√°t hi·ªán v√† v√≤ng l·∫∑p ƒë∆∞·ª£c tho√°t ra.",
            "options": [
                "A. T·ªáp bƒÉm",
                "B. T·ªáp tu·∫ßn t·ª±",
                "C. EOF",
                "D. Kh√¥ng c√≥ ph∆∞∆°ng √°n n√†o kh√°c"
            ],
            "answer": "C. EOF",
            "explanation": "EOF l√† vi·∫øt t·∫Øt c·ªßa End-Of-File (Cu·ªëi t·ªáp). N√≥ l√† m·ªôt d·∫•u hi·ªáu ho·∫∑c ƒëi·ªÅu ki·ªán ƒë·∫∑c bi·ªát m√† h·ªá ƒëi·ªÅu h√†nh s·ª≠ d·ª•ng ƒë·ªÉ b√°o hi·ªáu r·∫±ng kh√¥ng c√≤n d·ªØ li·ªáu ƒë·ªÉ ƒë·ªçc t·ª´ m·ªôt t·ªáp. **M·∫πo ghi nh·ªõ: D·∫•u hi·ªáu ·ªü cu·ªëi t·ªáp = EOF.**"
        }
    },
    {
        "id": 309,
        "category": "Chapter 10: File Structure (C·∫•u tr√∫c t·ªáp)",
        "en": {
            "question": "_______ file can be accessed sequentially.",
            "options": [
                "A. A sequential",
                "B. An indexed",
                "C. A hashed",
                "D. No"
            ],
            "answer": "A. A sequential",
            "explanation": "By definition, a sequential file is designed to be read from beginning to end, one record after another. **Key takeaway: Sequential file = Sequential access.**"
        },
        "vi": {
            "question": "T·ªáp _______ c√≥ th·ªÉ ƒë∆∞·ª£c truy c·∫≠p tu·∫ßn t·ª±.",
            "options": [
                "A. tu·∫ßn t·ª±",
                "B. ƒë∆∞·ª£c l·∫≠p ch·ªâ m·ª•c",
                "C. ƒë∆∞·ª£c bƒÉm",
                "D. kh√¥ng"
            ],
            "answer": "A. tu·∫ßn t·ª±",
            "explanation": "Theo ƒë·ªãnh nghƒ©a, m·ªôt t·ªáp tu·∫ßn t·ª± ƒë∆∞·ª£c thi·∫øt k·∫ø ƒë·ªÉ ƒë∆∞·ª£c ƒë·ªçc t·ª´ ƒë·∫ßu ƒë·∫øn cu·ªëi, h·∫øt b·∫£n ghi n√†y ƒë·∫øn b·∫£n ghi kh√°c. **M·∫πo ghi nh·ªõ: T·ªáp tu·∫ßn t·ª± = Truy c·∫≠p tu·∫ßn t·ª±.**"
        }
    },
    {
        "id": 310,
        "category": "Chapter 10: File Structure (C·∫•u tr√∫c t·ªáp)",
        "en": {
            "question": "The file structure allows random access is _______",
            "options": [
                "A. Hashed file",
                "B. Sequential file",
                "C. EOF",
                "D. None of others"
            ],
            "answer": "A. Hashed file",
            "explanation": "A hashed file uses a hash function to compute the address of a record directly from its key. This allows for very fast random (or direct) access. Indexed files also allow random access. **Key takeaway: Hashing = Fast random access.**"
        },
        "vi": {
            "question": "C·∫•u tr√∫c t·ªáp cho ph√©p truy c·∫≠p ng·∫´u nhi√™n l√† _______",
            "options": [
                "A. T·ªáp bƒÉm",
                "B. T·ªáp tu·∫ßn t·ª±",
                "C. EOF",
                "D. Kh√¥ng c√≥ ph∆∞∆°ng √°n n√†o kh√°c"
            ],
            "answer": "A. T·ªáp bƒÉm",
            "explanation": "M·ªôt t·ªáp bƒÉm s·ª≠ d·ª•ng m·ªôt h√†m bƒÉm ƒë·ªÉ t√≠nh to√°n ƒë·ªãa ch·ªâ c·ªßa m·ªôt b·∫£n ghi tr·ª±c ti·∫øp t·ª´ kh√≥a c·ªßa n√≥. ƒêi·ªÅu n√†y cho ph√©p truy c·∫≠p ng·∫´u nhi√™n (ho·∫∑c tr·ª±c ti·∫øp) r·∫•t nhanh. T·ªáp ƒë∆∞·ª£c l·∫≠p ch·ªâ m·ª•c c≈©ng cho ph√©p truy c·∫≠p ng·∫´u nhi√™n. **M·∫πo ghi nh·ªõ: BƒÉm = Truy c·∫≠p ng·∫´u nhi√™n nhanh.**"
        }
    },
    {
        "id": 311,
        "category": "Chapter 10: File Structure (C·∫•u tr√∫c t·ªáp)",
        "en": null,
        "vi": {
            "question": "T·ªáp tin n√†o l∆∞u tr·ªØ d·ªØ li·ªáu theo ƒë·ªãnh d·∫°ng n·ªôi b·ªô c·ªßa m√°y t√≠nh (s·ªë nguy√™n, s·ªë th·ª±c, media) v√† th∆∞·ªùng kh√¥ng th·ªÉ ƒë·ªçc ƒë∆∞·ª£c tr·ª±c ti·∫øp b·ªüi con ng∆∞·ªùi?",
            "options": [
                "A. Text File (T·ªáp vƒÉn b·∫£n).",
                "B. Binary File (T·ªáp nh·ªã ph√¢n).",
                "C. Sequential File (T·ªáp tu·∫ßn t·ª±).",
                "D. Indexed File (T·ªáp ch·ªâ m·ª•c)."
            ],
            "answer": "B. Binary File (T·ªáp nh·ªã ph√¢n).",
            "explanation": "T√†i li·ªáu (Ch 10, M·ª•c 2.3) m√¥ t·∫£ t·ªáp nh·ªã ph√¢n 'Store data in the computer's internal format' v√† 'Not human-readable without proper decoding'. **M·∫πo ghi nh·ªõ: Binary File = D·ªØ li·ªáu th√¥ c·ªßa m√°y t√≠nh, ng∆∞·ªùi kh√¥ng ƒë·ªçc tr·ª±c ti·∫øp ƒë∆∞·ª£c.**"
        }
    }

    ];
    // --------------------------------

    // ======================================================
    // 2. LOGIC HO√ÄN CH·ªàNH
    // ======================================================
    
    const naturalSort = (a, b) => a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' });
    
    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }

    const compareArrays = (a, b) => {
        const sortedA = [...a].sort();
        const sortedB = [...b].sort();
        return sortedA.length === sortedB.length && sortedA.every((val, index) => val === sortedB[index]);
    };

    function getCorrectIndices(data, qObj) {
        const rawAnswers = Array.isArray(data.answer) ? data.answer : [data.answer];
        const options = data.options;
        let originalIndices = [];
        const clean = (str) => (typeof str === 'string') ? str.replace(/^[A-F][\.\)]\s*/i, '').trim().toLowerCase() : '';

        rawAnswers.forEach(ans => {
            let idx = -1;
            const cleanAns = clean(ans);
            idx = options.findIndex(opt => clean(opt) === cleanAns);
            if (idx === -1 && ans.trim().length === 1) {
                const charCode = ans.trim().toUpperCase().charCodeAt(0) - 65; 
                if (charCode >= 0 && charCode < options.length) idx = charCode;
            }
            if (idx === -1) {
                idx = options.findIndex(opt => clean(opt).includes(cleanAns) || cleanAns.includes(clean(opt)));
            }
            if (idx !== -1) originalIndices.push(idx);
        });
        return [...new Set(originalIndices)];
    }

    let state = {
        isVietnamese: true, activeTab: 'flashcard', fcIndex: 0, filteredFlashcards: [],
        quizPhase: 'setup', activeQuestions: [], userAnswers: {}, currentQuizIndex: 0, quizResults: {},
        checkedQuestions: {} 
    };

    const texts = {
        vi: {
            setupTitle: "C·∫•u h√¨nh luy·ªán t·∫≠p", total: "C√≥ s·∫µn:", qCount: "2. S·ªë l∆∞·ª£ng c√¢u h·ªèi:", start: "B·∫Øt ƒë·∫ßu l√†m b√†i üöÄ", mapTitle: "C√¢u h·ªèi",
            submit: "N·ªôp b√†i", resultTitle: "K·∫øt qu·∫£", prev: "Quay l·∫°i", next: "Ti·∫øp theo", fcAnsLabel: "ƒê√°p √Ån", fcExpLabel: "Gi·∫£i th√≠ch:",
            legCur: "ƒêang ch·ªçn", legCor: "ƒê√∫ng", legWro: "Sai", qOf: "C√¢u", correctAns: "ƒê√°p √°n ƒë√∫ng:", unanswered: "‚ö™ Ch∆∞a l√†m", correct: "‚úî Ch√≠nh x√°c!",
            wrong: "‚úò Sai r·ªìi", chapter: "Ch·ªß ƒë·ªÅ:", confirmSubmit: "B·∫°n c√≥ ch·∫Øc mu·ªën n·ªôp b√†i?", 
            shortcutHelp: "Ph√≠m t·∫Øt: 1-4 (Ch·ªçn ƒë√°p √°n) | Enter (ƒê·ªïi ng√¥n ng·ªØ) | Space (L·∫≠t/Check) | ‚¨Ö/‚û° (Chuy·ªÉn)",
            chooseOne: "Ch·ªçn 1 ƒë√°p √°n", chooseMulti: "H√£y ch·ªçn {n} ƒë√°p √°n", checkBtn: "Ki·ªÉm tra ƒë√°p √°n ‚ú®", explanation: "Gi·∫£i th√≠ch chi ti·∫øt:"
        },
        en: {
            setupTitle: "Practice Configuration", total: "Available:", qCount: "2. Number of questions:", start: "Start Now üöÄ", mapTitle: "Question Map",
            submit: "Submit", resultTitle: "Quiz Results", prev: "Back", next: "Next", fcAnsLabel: "Answer", fcExpLabel: "Explanation:",
            legCur: "Current", legCor: "Correct", legWro: "Wrong", qOf: "Question", correctAns: "Correct answer:", unanswered: "‚ö™ Unanswered", correct: "‚úî Correct",
            wrong: "‚úò Wrong", chapter: "Chapter:", confirmSubmit: "Are you sure you want to submit?", 
            shortcutHelp: "Shortcuts: 1-4 (Select Option) | Enter (Language) | Space (Flip/Check) | ‚¨Ö/‚û° (Navigate)",
            chooseOne: "Choose 1 answer", chooseMulti: "Choose {n} answers", checkBtn: "Check Answer ‚ú®", explanation: "Detailed Explanation:"
        }
    };

    function init() {
        if (typeof quizData === 'undefined' || quizData.length === 0) {
            document.body.innerHTML = `<div style="padding:20px; text-align:center; color:red;"><h2>Ch∆∞a c√≥ d·ªØ li·ªáu. Vui l√≤ng d√°n JSON v√†o code.</h2></div>`;
            return;
        }
        const uniqueCats = Array.from(new Set(quizData.map(q => q.category || "Kh√°c")));
        uniqueCats.sort(naturalSort);
        const populate = (id) => {
            const sel = document.getElementById(id);
            sel.innerHTML = '<option value="all">-- T·∫•t c·∫£ / All Chapters --</option>';
            uniqueCats.forEach(cat => { sel.innerHTML += `<option value="${cat}">${cat}</option>`; });
        };
        populate('fc-category-select');
        populate('quiz-category-select');
        updateFlashcardFilter();
        updateQuizCountMax();
        updateLanguageTexts();
        updateView();
    }

    function updateView() {
        document.querySelectorAll('.view-section').forEach(el => el.classList.remove('active-view'));
        document.getElementById('quiz-sidebar').classList.add('hidden');
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        if (state.activeTab === 'flashcard') {
            document.querySelector('.tab-btn[onclick*="flashcard"]').classList.add('active');
            document.getElementById('flashcard-view').classList.add('active-view');
        } else {
            document.querySelector('.tab-btn[onclick*="quiz"]').classList.add('active');
            const phaseMap = { setup: 'quiz-setup', active: 'quiz-active', result: 'quiz-result' };
            document.getElementById(phaseMap[state.quizPhase]).classList.add('active-view');
            if (state.quizPhase !== 'setup') document.getElementById('quiz-sidebar').classList.remove('hidden');
        }
    }

    function switchTab(tab) { state.activeTab = tab; updateView(); }
    
    // --- FLASHCARD ---
    function updateFlashcardFilter() {
        const cat = document.getElementById('fc-category-select').value;
        state.filteredFlashcards = (cat === 'all') ? quizData : quizData.filter(q => (q.category || "Kh√°c") === cat);
        state.fcIndex = 0;
        renderFlashcard();
    }

    function renderFlashcard() {
        const countSpan = document.getElementById('fc-counter');
        const wrapper = document.querySelector('.flashcard-wrapper');
        if (state.filteredFlashcards.length === 0) { wrapper.style.display = 'none'; countSpan.innerText = "0 / 0"; return; }
        wrapper.style.display = 'flex';
        const q = state.filteredFlashcards[state.fcIndex];
        const data = state.isVietnamese ? q.vi : q.en;
        document.querySelector('.flashcard').classList.remove('flipped');
        document.getElementById('fc-tag').innerText = q.category || "General";
        let contentHtml = `<div>${data.question}</div>`;
        if (data.options) {
            contentHtml += '<ul style="text-align:left; margin-top:20px; padding-left:0; list-style:none; font-size:16px; width:100%;">';
            data.options.forEach(o => contentHtml += `<li style="margin-bottom:8px; padding:8px; background:#f8f9fa; border-radius:8px; border:1px solid #eee;">${o}</li>`);
            contentHtml += '</ul>';
        }
        document.getElementById('fc-content').innerHTML = contentHtml;
        const answerText = Array.isArray(data.answer) ? data.answer.join('\n') : data.answer;
        document.getElementById('fc-answer').innerText = answerText;
        document.getElementById('fc-explanation').innerHTML = data.explanation;
        countSpan.innerText = `${state.fcIndex + 1} / ${state.filteredFlashcards.length}`;
    }

    function navFlashcard(dir) {
        let next = state.fcIndex + dir;
        if (next >= 0 && next < state.filteredFlashcards.length) { state.fcIndex = next; renderFlashcard(); }
    }

    // --- QUIZ ---
    function updateQuizCountMax() {
        const cat = document.getElementById('quiz-category-select').value;
        let count = (cat === 'all') ? quizData.length : quizData.filter(q => (q.category || "Kh√°c") === cat).length;
        document.getElementById('total-qs').innerText = count;
        const input = document.getElementById('quiz-count-input');
        input.max = count;
        input.value = Math.min(parseInt(input.value) || 20, count);
    }

    function startQuiz() {
        const cat = document.getElementById('quiz-category-select').value;
        let pool = (cat === 'all') ? [...quizData] : quizData.filter(q => (q.category || "Kh√°c") === cat);
        if (pool.length === 0) { alert(state.isVietnamese ? "Kh√¥ng c√≥ c√¢u h·ªèi!" : "No questions!"); return; }
        let count = Math.min(parseInt(document.getElementById('quiz-count-input').value), pool.length);
        if (isNaN(count) || count <= 0) count = 1;

        const selectedQuestions = shuffleArray([...pool]).slice(0, count);
        
        state.activeQuestions = selectedQuestions.map(q => ({ 
            ...q, 
            shuffledIndices: shuffleArray(Array.from({ length: (q.en.options || []).length }, (_, i) => i)) 
        }));
        
        state.userAnswers = {};
        state.quizResults = {}; 
        state.checkedQuestions = {}; 
        state.currentQuizIndex = 0;
        state.quizPhase = 'active';
        updateView();
        renderQuestionCard();
        renderMap();
    }

    function renderQuestionCard() {
        if (!state.activeQuestions[state.currentQuizIndex]) return;

        const t = state.isVietnamese ? texts.vi : texts.en;
        const idx = state.currentQuizIndex;
        const qObj = state.activeQuestions[idx];
        const data = state.isVietnamese ? qObj.vi : qObj.en;
        const userSelections = state.userAnswers[idx] || [];
        
        const correctIndices = getCorrectIndices(data, qObj);
        const numCorrect = correctIndices.length;
        const isMulti = numCorrect > 1;
        const isChecked = state.checkedQuestions[idx] === true;

        const hintBadge = document.getElementById('multi-select-badge');
        hintBadge.classList.remove('hidden');
        if(isMulti) {
            hintBadge.innerText = t.chooseMulti.replace('{n}', numCorrect);
            hintBadge.style.color = '#856404'; hintBadge.style.backgroundColor = '#fff3cd'; hintBadge.style.border = '1px solid #ffeeba';
        } else {
            hintBadge.innerText = t.chooseOne;
            hintBadge.style.color = '#495057'; hintBadge.style.backgroundColor = '#f1f3f5'; hintBadge.style.border = 'none';
        }
        
        document.getElementById('q-category-badge').innerText = qObj.category || "General";
        document.getElementById('quiz-progress').innerText = `${t.qOf} ${idx + 1}/${state.activeQuestions.length}`;
        document.getElementById('q-content').innerHTML = `<div>${data.question}</div>`;
        
        const ul = document.getElementById('q-options');
        ul.innerHTML = '';
        if (isChecked) ul.classList.add('checked');
        else ul.classList.remove('checked');

        const labels = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];
        
        qObj.shuffledIndices.forEach((originalIndex, displayPos) => {
            const li = document.createElement('li');
            li.innerHTML = (data.options[originalIndex] || '').replace(/^[A-F][\.\)]\s*/, ''); 
            li.setAttribute('data-label', labels[displayPos]);
            
            const isSelected = userSelections.includes(originalIndex);
            const isCorrectOption = correctIndices.includes(originalIndex);

            if (isSelected) li.classList.add('selected');

            if (isChecked) {
                if (isCorrectOption) li.classList.add('is-correct-answer');
                else if (isSelected && !isCorrectOption) li.classList.add('is-wrong-answer');
                li.onclick = null;
            } else {
                li.onclick = () => handleAnswer(idx, originalIndex, isMulti, isChecked, correctIndices);
            }
            ul.appendChild(li);
        });

        const checkBtnContainer = document.getElementById('check-btn-container');
        const checkBtn = document.getElementById('btn-manual-check');
        const explainDiv = document.getElementById('instant-explain-area');

        checkBtn.innerText = t.checkBtn;
        const newBtn = checkBtn.cloneNode(true);
        checkBtn.parentNode.replaceChild(newBtn, checkBtn);
        newBtn.onclick = () => performCheck(idx, correctIndices);

        if (isChecked) {
            checkBtnContainer.classList.add('hidden');
            const isUserCorrect = compareArrays(userSelections, correctIndices);
            explainDiv.className = `instant-explanation show ${isUserCorrect ? 'correct' : 'wrong'}`;
            explainDiv.innerHTML = `<strong>${isUserCorrect ? t.correct : t.wrong}</strong><br>
                                    <strong>${t.explanation}</strong> ${data.explanation || "..."}`;
        } else {
            explainDiv.className = 'instant-explanation'; explainDiv.innerHTML = '';
            if (isMulti) {
                checkBtnContainer.classList.remove('hidden');
                newBtn.disabled = userSelections.length === 0;
            } else {
                checkBtnContainer.classList.add('hidden');
            }
        }
        
        document.getElementById('btn-prev').disabled = idx === 0;
        document.getElementById('btn-next').disabled = idx === state.activeQuestions.length - 1;
        renderMap();
    }

    function handleAnswer(qIdx, originalIndex, isMulti, isChecked, correctIndices) {
        if (isChecked) return;

        state.userAnswers[qIdx] = state.userAnswers[qIdx] || [];
        const currentSelection = state.userAnswers[qIdx];
        
        if (isMulti) {
            const selectionIndex = currentSelection.indexOf(originalIndex);
            if (selectionIndex > -1) currentSelection.splice(selectionIndex, 1);
            else currentSelection.push(originalIndex);
            renderQuestionCard(); 
        } else {
            state.userAnswers[qIdx] = [originalIndex];
            performCheck(qIdx, correctIndices); 
        }
    }

    function performCheck(qIdx, correctIndices) {
        state.checkedQuestions[qIdx] = true;
        const userIndices = state.userAnswers[qIdx] || [];
        const isCorrect = compareArrays(userIndices, correctIndices);
        state.quizResults[qIdx] = { isCorrect };
        renderQuestionCard();
        renderMap();
    }

    function navQuiz(dir) {
        let next = state.currentQuizIndex + dir;
        if (next >= 0 && next < state.activeQuestions.length) { state.currentQuizIndex = next; renderQuestionCard(); }
    }

    function finishQuiz() {
        if (!confirm(state.isVietnamese ? texts.vi.confirmSubmit : texts.en.confirmSubmit)) return;
        
        let correctCount = 0;
        state.activeQuestions.forEach((q, i) => {
            if (!state.checkedQuestions[i]) {
                 const data = state.isVietnamese ? q.vi : q.en;
                 const correctIndices = getCorrectIndices(data, q);
                 const userIndices = state.userAnswers[i] || [];
                 const isCorrect = compareArrays(userIndices, correctIndices);
                 state.quizResults[i] = { isCorrect };
            }
            if (state.quizResults[i] && state.quizResults[i].isCorrect) correctCount++;
        });

        state.quizPhase = 'result';
        updateView();
        const total = state.activeQuestions.length;
        document.getElementById('score-val').innerText = `${correctCount}/${total}`;
        document.getElementById('score-percent').innerText = `(${(total > 0 ? Math.round(correctCount / total * 100) : 0)}%)`;
        renderResultView();
        renderMap();
    }

    function renderResultView() {
        const t = state.isVietnamese ? texts.vi : texts.en;
        const list = document.getElementById('review-list');
        list.innerHTML = '';
        state.activeQuestions.forEach((qObj, idx) => {
            const data = state.isVietnamese ? qObj.vi : qObj.en;
            const result = state.quizResults[idx];
            const status = result ? (result.isCorrect ? `<span style="color:var(--secondary-color)">${t.correct}</span>` : `<span style="color:var(--danger-color)">${t.wrong}</span>`) : `<span style="color:gray">${t.unanswered}</span>`;
            const correctAnswerText = Array.isArray(data.answer) ? data.answer.join('<br>') : data.answer;
            list.innerHTML += `<div class="question-card" style="background:#f8f9fa; border:1px solid #eee; padding:20px;">
                <div style="margin-bottom:10px; display:flex; justify-content:space-between;"><strong>${t.qOf} ${idx + 1}</strong> ${status}</div>
                <div style="color:#666; font-size:12px; margin-bottom:10px;">${t.chapter} ${qObj.category || 'General'}</div>
                <div style="margin-bottom:10px;">${data.question}</div>
                <div style="margin-top:10px; font-weight:bold; color:var(--secondary-color)">${t.correctAns}<br>${correctAnswerText}</div>
                <div style="margin-top:5px; font-style:italic; color:#555;">${data.explanation}</div>
            </div>`;
        });
    }

    function resetQuiz() { state.quizPhase = 'setup'; state.userAnswers = {}; state.quizResults = {}; state.activeQuestions = []; state.checkedQuestions = {}; updateView(); updateQuizCountMax(); }

    function renderMap() {
        const grid = document.getElementById('map-grid');
        grid.innerHTML = '';
        state.activeQuestions.forEach((_, i) => {
            const btn = document.createElement('button');
            btn.className = 'map-btn';
            btn.innerText = i + 1;
            const isChecked = state.checkedQuestions[i];
            const hasAnswer = state.userAnswers[i] && state.userAnswers[i].length > 0;
            
            if (state.quizPhase === 'result') {
                const result = state.quizResults[i];
                if (result) btn.classList.add(result.isCorrect ? 'correct' : 'wrong');
            } else {
                if (state.currentQuizIndex === i) btn.classList.add('active');
                if (isChecked) {
                    const result = state.quizResults[i];
                    if (result) btn.classList.add(result.isCorrect ? 'correct' : 'wrong');
                } else if (hasAnswer) {
                    btn.classList.add('answered');
                }
            }
            btn.onclick = () => { 
                if(state.quizPhase !== 'result') { state.currentQuizIndex = i; renderQuestionCard(); }
            };
            grid.appendChild(btn);
        });
    }

    function toggleLanguage() {
        state.isVietnamese = !state.isVietnamese;
        updateLanguageTexts();
        if (state.activeTab === 'flashcard') renderFlashcard();
        else if (state.activeTab === 'quiz') {
            if (state.quizPhase === 'active') renderQuestionCard();
            else if (state.quizPhase === 'result') renderResultView();
        }
    }

    function updateLanguageTexts() {
        const t = state.isVietnamese ? texts.vi : texts.en;
        document.getElementById('current-lang-text').innerText = state.isVietnamese ? "VN" : "EN";
        document.getElementById('txt-setup-title').innerText = t.setupTitle;
        document.getElementById('txt-total').innerText = t.total;
        document.getElementById('txt-q-count').innerText = t.qCount;
        document.getElementById('txt-start').innerHTML = t.start;
        document.getElementById('btn-prev').innerText = t.prev;
        document.getElementById('btn-next').innerText = t.next;
        document.getElementById('btn-submit').innerText = t.submit;
        document.getElementById('txt-result-title').innerText = t.resultTitle;
        document.getElementById('fc-answer-label').innerText = t.fcAnsLabel;
        document.getElementById('fc-explanation-label').innerText = t.fcExpLabel;
        document.getElementById('leg-current').innerText = t.legCur;
        document.getElementById('leg-correct').innerText = t.legCor;
        document.getElementById('leg-wrong').innerText = t.legWro;
        document.getElementById('txt-map-title').innerText = t.mapTitle;
        document.getElementById('shortcut-help').innerText = t.shortcutHelp;
    }

    // --- S·ª∞ KI·ªÜN B√ÄN PH√çM C·∫¨P NH·∫¨T ---
    document.addEventListener('keydown', e => {
        // Kh√¥ng k√≠ch ho·∫°t khi ƒëang nh·∫≠p li·ªáu
        if (['INPUT', 'SELECT', 'TEXTAREA'].includes(document.activeElement.tagName)) return;

        // 1. ƒê·ªïi ng√¥n ng·ªØ b·∫±ng ENTER (Theo y√™u c·∫ßu)
        if (e.key === 'Enter') {
            e.preventDefault();
            toggleLanguage();
            return; 
        }

        // 2. Flashcard navigation
        if (state.activeTab === 'flashcard') {
            if (e.key === 'ArrowLeft') navFlashcard(-1);
            if (e.key === 'ArrowRight') navFlashcard(1);
            
            // D√πng Space, Up, Down ƒë·ªÉ l·∫≠t th·∫ª (Enter gi·ªù l√† ƒë·ªïi ng√¥n ng·ªØ)
            if ([' ', 'ArrowUp', 'ArrowDown'].includes(e.key)) {
                e.preventDefault(); 
                document.querySelector('.flashcard').classList.toggle('flipped');
            }
        } 
        
        // 3. Quiz navigation & Selection
        else if (state.activeTab === 'quiz' && state.quizPhase === 'active') {
            if (e.key === 'ArrowLeft') navQuiz(-1);
            if (e.key === 'ArrowRight') navQuiz(1);

            // Ch·ªçn ƒë√°p √°n b·∫±ng ph√≠m s·ªë (1, 2, 3, 4 -> A, B, C, D)
            if (e.key >= '1' && e.key <= '8') {
                const displayIndex = parseInt(e.key) - 1; 
                const idx = state.currentQuizIndex;
                
                if (state.activeQuestions[idx] && !state.checkedQuestions[idx]) {
                    const qObj = state.activeQuestions[idx];
                    const data = state.isVietnamese ? qObj.vi : qObj.en;
                    
                    if (displayIndex < (data.options || []).length) {
                        const originalIndex = qObj.shuffledIndices[displayIndex];
                        const correctIndices = getCorrectIndices(data, qObj);
                        const isMulti = correctIndices.length > 1;
                        
                        handleAnswer(idx, originalIndex, isMulti, false, correctIndices);
                    }
                }
            }
        }

        // D√πng SPACE ƒë·ªÉ "N·ªôp" cho c√¢u h·ªèi nhi·ªÅu l·ª±a ch·ªçn
        if (e.key === ' ') {
            e.preventDefault(); 
            const checkBtn = document.getElementById('btn-manual-check');
            if (checkBtn && !checkBtn.parentElement.classList.contains('hidden') && !checkBtn.disabled) {
                checkBtn.click();
            }
        }
    });

    document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
